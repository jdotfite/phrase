PROJECT ANALYSIS
Generated: 03/15/2025 17:21:23
Directory: C:\_websites\catch-phrase\src

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: 5.1.19041.5607
OS: Microsoft Windows 10 Pro
Computer Name: OFFICE

============================================================

FILE CONTENTS:

============================================================

FILE: .\claude.ps1
SIZE: 2.94 KB
LAST MODIFIED: 02/13/2025 10:17:39

# Get current directory path and script start time
$currentPath = (Get-Location).Path
$startTime = Get-Date
$outputFile = "code_dump_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"

# Add exclusion patterns for folders and files
$excludedPaths = @(
    'node_modules',
    '.git',
    'bin',
    'obj',
    'dist',
    'build',
    '.vscode',
    'packages'
)

# Write initial info to console
Write-Host "Starting analysis of $currentPath"
Write-Host "Excluding folders: $($excludedPaths -join ', ')"

# Initial file header
$envInfo = @"
PROJECT ANALYSIS
Generated: $(Get-Date)
Directory: $currentPath

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: $($PSVersionTable.PSVersion)
OS: $(Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty Caption)
Computer Name: $env:COMPUTERNAME
"@
Set-Content -Path $outputFile -Value $envInfo -Encoding utf8

Write-Host "Gathering file list..."

# Get all files, excluding problematic paths
$allFiles = Get-ChildItem -Path $currentPath -Recurse -File | Where-Object {
    $fullPath = $_.FullName
    $exclude = $false
    foreach ($path in $excludedPaths) {
        if ($fullPath -like "*\$path\*") {
            $exclude = $true
            break
        }
    }
    -not $exclude -and
    $_.Name -ne $outputFile -and
    -not $_.Name.EndsWith(".tmp")
}

# Process each file
"`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
"FILE CONTENTS:" | Out-File $outputFile -Append -Encoding utf8

$fileCounter = 0
$totalFiles = $allFiles.Count

# Avoid division by zero
if ($totalFiles -eq 0) {
    Write-Host "No files found to process. Exiting."
    exit
}

$allFiles | Where-Object {
    $_.Extension -notmatch '\.(exe|dll|pdb|obj|bin|cache|jpg|jpeg|png|gif|bmp|ico|mp3|mp4|zip|rar|7z)$' -and
    $_.Length -lt 5MB
} | ForEach-Object {
    $fileCounter++
    $percentComplete = [math]::Round(($fileCounter / $totalFiles) * 100, 1)
    Write-Progress -Activity "Processing Files" -Status "$fileCounter of $totalFiles ($percentComplete%)" -PercentComplete $percentComplete
    Write-Host "Processing ($fileCounter/$totalFiles): $($_.Name)"

    try {
        # Write file metadata
        $relPath = $_.FullName.Replace($currentPath, ".")
        $fileSize = [math]::Round($_.Length / 1KB, 2)
        
        "`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
        "FILE: $relPath`nSIZE: $fileSize KB`nLAST MODIFIED: $($_.LastWriteTime)`n" | Out-File $outputFile -Append -Encoding utf8
        
        # Append file content
        Get-Content $_.FullName -Raw | Out-File $outputFile -Append -Encoding utf8
    } catch {
        Write-Warning "Error processing $($_.FullName): $_"
    }
}

Write-Host "Analysis complete. Output saved to $outputFile"


============================================================

FILE: .\create.ps1
SIZE: 14.8 KB
LAST MODIFIED: 03/09/2025 21:46:04

# Dashboard Refactoring PowerShell Script - Part 3 (Continued)
# This script creates the PhraseSearch component and the refactored CleanDashboard

# Base directory - adjust this to your project root
$baseDir = "."

# Create directories if they don't exist
$directories = @(
    "$baseDir\components\dashboard",
    "$baseDir\hooks\dashboard"
)

foreach ($dir in $directories) {
    if (-not (Test-Path $dir)) {
        New-Item -ItemType Directory -Path $dir -Force
        Write-Host "Created directory: $dir" -ForegroundColor Green
    }
}

# Create PhraseSearch component with full implementation
$phraseSearchContent = @'
import React from 'react';
import { DataTableFilters } from '@/components/tables/data-table/filters';
import { TableState } from '@/components/tables/types';

interface PhraseSearchProps {
  tableState: TableState;
  onTableStateChange: (state: Partial<TableState>) => void;
}

export const PhraseSearch: React.FC<PhraseSearchProps> = ({ 
  tableState, onTableStateChange 
}) => {
  return (
    <div className="px-2">
      <DataTableFilters
        tableState={tableState}
        onTableStateChange={onTableStateChange}
      />
    </div>
  );
};
'@

# Create usePhraseTimeline hook
$phraseTimelineHookContent = @'
import { useState, useEffect } from 'react';
import { DashboardDataService } from '@/services/dashboard-data-service';

export const usePhraseTimeline = () => {
  const [phrasesOverTime, setPhrasesOverTime] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      const { data, error } = await DashboardDataService.fetchPhrasesOverTime();
      
      if (error || !data) {
        setPhrasesOverTime(DashboardDataService.getErrorStateData());
        setError(error);
      } else {
        const monthlyData = DashboardDataService.processTimestampData(data);
        setPhrasesOverTime(monthlyData);
      }
      setLoading(false);
    };
    
    fetchData();
  }, []);

  return { phrasesOverTime, loading, error };
};
'@

# Create a refactored version of CleanDashboard with all components
$cleanDashboardContent = @'
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useTheme } from 'next-themes';
import './dashboard.css';

// Refactored Components
import { DashboardHeader } from '@/components/dashboard/DashboardHeader';
import { StatsCards } from '@/components/dashboard/StatsCards';
import { AnalyticsCharts } from '@/components/dashboard/AnalyticsCharts';
import { PhraseSearch } from '@/components/dashboard/PhraseSearch';

// Original Components
import { PhrasesTable } from '@/components/phrases/phrases-table';
import BulkImportForm from '@/features/shared/BulkImportForm';
import FilterModal from '@/components/common/FilterModal';
import ExportModal from '@/components/common/ExportModal';

// UI Components
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

// Services and Hooks
import { supabase } from '@/lib/services/supabase';
import { DashboardDataService } from '@/services/dashboard-data-service';
import { usePhraseTimeline } from '@/hooks/dashboard/usePhraseTimeline';
import { useStats } from '@/hooks/useStats';
import { usePhrases } from '@/hooks/usePhrases';
import { usePhraseMetadata } from '@/hooks/usePhraseMetadata';
import { useReviewers } from '@/hooks/useReviewers';

const CleanDashboard = () => {
  const router = useRouter();
  const { theme, setTheme } = useTheme();

  // State
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [activeTab, setActiveTab] = useState('phrases');
  const [showFilterModal, setShowFilterModal] = useState(false);
  const [subcategories, setSubcategories] = useState([]);
  const [showExportModal, setShowExportModal] = useState(false);
  const [isExporting, setIsExporting] = useState(false);

  // Words Added Data for the radial chart
  const wordsAddedData = [
    { name: "Words Added", value: 45, fill: "hsl(var(--primary))" },
    { name: "Goal", value: 100, fill: "hsl(var(--muted))" },
  ];
  
  // Analytics data
  const [monthlyActivityData, setMonthlyActivityData] = useState([]);
  const [categoryData, setCategoryData] = useState([]);

  // Hooks
  const { stats, loading: statsLoading } = useStats();
  const { reviewers } = useReviewers();
  const { phrasesOverTime } = usePhraseTimeline();
  const { categories, difficulties, partsOfSpeech } = usePhraseMetadata();
  const {
    phrases,
    loading: phrasesLoading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    editPhrase,
    deletePhrase,
    resetFilters,
  } = usePhrases();

  // Table State
  const [tableState, setTableState] = useState({
    sortConfig,
    pagination: {
      ...pagination,
      rowsPerPage: 10,
      totalItems: phrases?.length || 0,
      totalPages: Math.ceil((phrases?.length || 0) / 10),
    },
    filters,
  });

  // Effect to hide any debug JSON output
  useEffect(() => {
    // Find and hide pre tags with JSON state data
    const preElements = document.querySelectorAll('pre');
    preElements.forEach(el => {
      if (el.textContent && 
          el.textContent.includes('"dataLength":') && 
          el.textContent.includes('"totalItems":')) {
        el.style.display = 'none';
      }
    });
  }, []);

  // Sync Table State with Hook State
  useEffect(() => {
    if (phrases && pagination) {
      setTableState((prev) => ({
        sortConfig,
        pagination: {
          ...pagination,
          totalItems: pagination.totalItems || phrases.length || 0,
          totalPages: pagination.totalPages || Math.ceil((phrases.length || 0) / pagination.rowsPerPage),
        },
        filters,
      }));
    }
  }, [sortConfig, pagination, filters, phrases]);

  // Force rows per page to be 10
  useEffect(() => {
    if (pagination && pagination.rowsPerPage !== 10) {
      console.log('Forcing rows per page to 10');
      handleRowsPerPageChange(10);
    }
  }, [pagination, handleRowsPerPageChange]);

  // Fetch Subcategories
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!filters.category) {
        setSubcategories([]);
        return;
      }

      try {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');

          if (subcategoryData) {
            setSubcategories(subcategoryData.map((sub) => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      }
    };

    fetchSubcategories();
  }, [filters.category]);

  // Initialize analytics data
  useEffect(() => {
    setMonthlyActivityData(DashboardDataService.generateMonthlyActivityData());
    setCategoryData(DashboardDataService.generateCategoryData(categories));
  }, [categories]);

  // Handle table state changes
  const handleTableStateChange = (updates) => {
    console.log('Table state change requested:', updates);
    
    // Update local state first
    setTableState(prev => ({
      ...prev,
      ...updates
    }));
    
    // Handle filter changes
    if (updates.filters && JSON.stringify(updates.filters) !== JSON.stringify(filters)) {
      console.log('Applying filters:', updates.filters);
      handleFilterChange(updates.filters);
      
      // Reset to page 1 when filtering
      if (pagination.currentPage !== 1) {
        handlePageChange(1);
      }
    }
    
    // Handle sort changes
    if (updates.sortConfig && 
      (updates.sortConfig.key !== sortConfig.key || 
       updates.sortConfig.direction !== sortConfig.direction)) {
      console.log('Updating sort:', updates.sortConfig);
      handleSort(updates.sortConfig.key);
    }
    
    // Handle pagination changes
    if (updates.pagination) {
      // Handle page changes
      if (updates.pagination.currentPage !== undefined && 
          updates.pagination.currentPage !== pagination.currentPage) {
        console.log('Changing page to:', updates.pagination.currentPage);
        handlePageChange(updates.pagination.currentPage);
      }
      
      // Handle rows per page changes
      if (updates.pagination.rowsPerPage !== undefined && 
          updates.pagination.rowsPerPage !== pagination.rowsPerPage) {
        console.log('Changing rows per page to:', updates.pagination.rowsPerPage);
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
    }
  };

  const handleExport = async (options) => {
    try {
      setIsExporting(true);
      const result = await DashboardDataService.handleExport(options);
      setIsExporting(false);
      return result;
    } catch (error) {
      console.error('Export error:', error);
      setIsExporting(false);
      return null;
    }
  };

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <DashboardHeader
        theme={theme}
        setTheme={setTheme}
        onReviewClick={() => router.push('/review')}
        onExportClick={() => setShowExportModal(true)}
        onLoginClick={() => setShowLoginModal(true)}
      />

      {/* Stats Cards */}
      <StatsCards
        phrasesOverTime={phrasesOverTime}
        stats={stats}
        reviewers={reviewers}
      />

      {/* Tabs */}
      <Tabs defaultValue="phrases" value={activeTab} onValueChange={setActiveTab} className="space-y-4">
        <div className="border-b">
          <div className="flex">
            <TabsList className="bg-transparent">
              <TabsTrigger value="phrases" className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent">
                Phrases
              </TabsTrigger>
              <TabsTrigger value="analytics" className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent">
                Analytics
              </TabsTrigger>
              <TabsTrigger value="import" className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent">
                Import
              </TabsTrigger>
            </TabsList>
          </div>
        </div>

        {/* Phrases Tab */}
        <TabsContent value="phrases" className="m-0">
          <div className="flex flex-col space-y-4">
            {/* Search Input */}
            <PhraseSearch
              tableState={tableState}
              onTableStateChange={handleTableStateChange}
            />
            
            {/* Phrases Table */}
            <PhrasesTable
              phrases={phrases}
              loading={phrasesLoading}
              tableState={tableState}
              onTableStateChange={handleTableStateChange}
              onEdit={editPhrase}
              onDelete={deletePhrase}
              newIds={[]}
            />
          </div>
        </TabsContent>

        {/* Analytics Tab */}
        <TabsContent value="analytics" className="m-0">
          <AnalyticsCharts
            monthlyActivityData={monthlyActivityData}
            categoryData={categoryData}
            wordsAddedData={wordsAddedData}
          />
        </TabsContent>

        {/* Import Tab */}
        <TabsContent value="import" className="m-0">
          <BulkImportForm
            onSuccess={() => setActiveTab('phrases')}
            onError={() => {}}
          />
        </TabsContent>
      </Tabs>

      {/* Modals */}
      <FilterModal
        isOpen={showFilterModal}
        onClose={() => setShowFilterModal(false)}
        filters={filters}
        onChange={handleFilterChange}
        onReset={resetFilters}
        categories={categories}
        difficulties={difficulties}
        partsOfSpeech={partsOfSpeech}
        subcategories={subcategories}
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        onExport={handleExport}
        isLoading={isExporting}
      />
    </div>
  );
};

export default CleanDashboard;
'@

# Write files
$filesToCreate = @{
    "$baseDir\components\dashboard\PhraseSearch.tsx" = $phraseSearchContent
    "$baseDir\hooks\dashboard\usePhraseTimeline.ts" = $phraseTimelineHookContent
    "$baseDir\pages\dashboard\RefactoredCleanDashboard.tsx" = $cleanDashboardContent
}

foreach ($file in $filesToCreate.Keys) {
    if (-not (Test-Path $file)) {
        Set-Content -Path $file -Value $filesToCreate[$file]
        Write-Host "Created file: $file" -ForegroundColor Green
    } else {
        Write-Host "File already exists: $file" -ForegroundColor Yellow
        $overwrite = Read-Host "Do you want to overwrite it? (y/n)"
        if ($overwrite -eq "y") {
            Set-Content -Path $file -Value $filesToCreate[$file]
            Write-Host "Overwritten file: $file" -ForegroundColor Green
        }
    }
}

Write-Host "`nDashboard refactoring Part 3 completed!" -ForegroundColor Cyan
Write-Host "Created the following components:" -ForegroundColor Cyan
Write-Host " - PhraseSearch" -ForegroundColor White
Write-Host " - usePhraseTimeline (hook)" -ForegroundColor White
Write-Host " - RefactoredCleanDashboard" -ForegroundColor White
Write-Host "`nRefactoring Status:" -ForegroundColor Cyan
Write-Host "All refactored components and services have been created." -ForegroundColor Green
Write-Host "The RefactoredCleanDashboard.tsx file contains the fully refactored dashboard." -ForegroundColor Green
Write-Host "`nTo complete the refactoring:" -ForegroundColor Cyan
Write-Host "1. Review all created components and make any necessary adjustments" -ForegroundColor White
Write-Host "2. Test the refactored dashboard by importing and using RefactoredCleanDashboard" -ForegroundColor White
Write-Host "3. Once satisfied, replace the original CleanDashboard.tsx with the refactored version" -ForegroundColor White
Write-Host "`nBenefits of this refactoring:" -ForegroundColor Cyan
Write-Host "- Reduced component size (600+ lines to <200 lines)" -ForegroundColor White
Write-Host "- Improved maintainability and readability" -ForegroundColor White
Write-Host "- Better separation of concerns" -ForegroundColor White
Write-Host "- Reusable components that can be used elsewhere" -ForegroundColor White

============================================================

FILE: .\db-structure.txt
SIZE: 28.94 KB
LAST MODIFIED: 03/10/2025 14:35:18

[
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": "nextval('main_categories_id_seq'::regclass)",
    "constraint_type": "UNIQUE",
    "referenced_table": "categories",
    "referenced_column": "name"
  },
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": "nextval('main_categories_id_seq'::regclass)",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": "nextval('main_categories_id_seq'::regclass)",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": "nextval('main_categories_id_seq'::regclass)",
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "categories",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "UNIQUE",
    "referenced_table": "categories",
    "referenced_column": "name"
  },
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "categories",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "categories",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "phrase_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "tag_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "phrase_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "tag_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "tag_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "tag_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "phrase_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrase_tags",
    "referenced_column": "phrase_id"
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrase_tags",
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "NO",
    "column_default": "nextval('phrases_id_seq'::regclass)",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "NO",
    "column_default": "nextval('phrases_id_seq'::regclass)",
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "NO",
    "column_default": "nextval('phrases_id_seq'::regclass)",
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "NO",
    "column_default": "nextval('phrases_id_seq'::regclass)",
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "NO",
    "column_default": "nextval('phrases_id_seq'::regclass)",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "category_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "category_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "category_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "category_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "category_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "subcategory_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "subcategory_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "subcategory_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "subcategory_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "subcategory_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "difficulty",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "difficulty",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "difficulty",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "difficulty",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "difficulty",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "phrases",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "FOREIGN KEY",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "category",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "difficulty",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "subcategory",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "last_used",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "tags",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_backup_2_12",
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "category",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "difficulty",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "subcategory",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "last_used",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "tags",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "phrases_old",
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "constraint_type": null,
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()",
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "reviewers",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "reviewers",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "total_reviews",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "total_reviews",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0",
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "reviewers",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "total_reviews",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "total_reviews",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "total_reviews",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "NO",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "NO",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "PRIMARY KEY",
    "referenced_table": "reviewers",
    "referenced_column": "id"
  },
  {
    "table_schema": "public",
    "table_name": "reviewers",
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "NO",
    "column_default": "timezone('utc'::text, now())",
    "constraint_type": "CHECK",
    "referenced_table": null,
    "referenced_column": null
  }
]

============================================================

FILE: .\restruct.ps1
SIZE: 0 KB
LAST MODIFIED: 03/14/2025 10:44:15


============================================================

FILE: .\app\globals.css
SIZE: 1.67 KB
LAST MODIFIED: 03/04/2025 21:05:06

@tailwind base;
@tailwind components;
@tailwind utilities;



@layer base {
  :root {

    --background: 0 0% 100%;

    --foreground: 0 0% 3.9%;

    --card: 0 0% 100%;

    --card-foreground: 0 0% 3.9%;

    --popover: 0 0% 100%;

    --popover-foreground: 0 0% 3.9%;

    --primary: 0 0% 9%;

    --primary-foreground: 0 0% 98%;

    --secondary: 0 0% 96.1%;

    --secondary-foreground: 0 0% 9%;

    --muted: 0 0% 96.1%;

    --muted-foreground: 0 0% 45.1%;

    --accent: 0 0% 96.1%;

    --accent-foreground: 0 0% 9%;

    --destructive: 0 84.2% 60.2%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 89.8%;

    --input: 0 0% 89.8%;

    --ring: 0 0% 3.9%;

    --chart-1: 12 76% 61%;

    --chart-2: 173 58% 39%;

    --chart-3: 197 37% 24%;

    --chart-4: 43 74% 66%;

    --chart-5: 27 87% 67%;

    --radius: 0.5rem
  }
  .dark {

    --background: 0 0% 3.9%;

    --foreground: 0 0% 98%;

    --card: 0 0% 3.9%;

    --card-foreground: 0 0% 98%;

    --popover: 0 0% 3.9%;

    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 98%;

    --primary-foreground: 0 0% 9%;

    --secondary: 0 0% 14.9%;

    --secondary-foreground: 0 0% 98%;

    --muted: 0 0% 14.9%;

    --muted-foreground: 0 0% 63.9%;

    --accent: 0 0% 14.9%;

    --accent-foreground: 0 0% 98%;

    --destructive: 0 62.8% 30.6%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 14.9%;

    --input: 0 0% 14.9%;

    --ring: 0 0% 83.1%;

    --chart-1: 220 70% 50%;

    --chart-2: 160 60% 45%;

    --chart-3: 30 80% 55%;

    --chart-4: 280 65% 60%;

    --chart-5: 340 75% 55%
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


============================================================

FILE: .\app\layout.tsx
SIZE: 0.58 KB
LAST MODIFIED: 03/05/2025 16:27:42

import type { Metadata } from "next";
import "./globals.css";
import { ThemeProvider } from "@/providers/ThemeProvider";

export const metadata: Metadata = {
  title: "Catch Phrase Admin",
  description: "Manage your catch phrases",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="font-sans antialiased">
        <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

============================================================

FILE: .\app\page.tsx
SIZE: 0.23 KB
LAST MODIFIED: 02/07/2025 09:27:36

'use client'
 
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
 
export default function Home() {
  const router = useRouter()
  
  useEffect(() => {
    router.push('/admin')
  }, [router])
  
  return null
}

============================================================

FILE: .\app\admin\page.tsx
SIZE: 0.25 KB
LAST MODIFIED: 03/15/2025 17:17:29

'use client'

import dynamic from 'next/dynamic';

// Import the refactored dashboard component
const Dashboard = dynamic(() => import('@/features/dashboard/Dashboard'), {
  ssr: false
});

export default function AdminPage() {
  return <Dashboard />;
}

============================================================

FILE: .\app\api\claude\route.ts
SIZE: 1.41 KB
LAST MODIFIED: 03/01/2025 15:23:07

import { NextResponse } from 'next/server';

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';

export async function POST(req: Request) {
  if (!CLAUDE_API_KEY) {
    console.error('Claude API key is not configured');
    return NextResponse.json(
      { error: 'Claude API key is not configured' },
      { status: 500 }
    );
  }

  try {
    const body = await req.json();
    
    const claudeResponse = await fetch(CLAUDE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-7-sonnet-20250219', // Updated model
        max_tokens: 150,
        messages: body.messages
      })
    });

    if (!claudeResponse.ok) {
      const errorText = await claudeResponse.text();
      console.error('Claude API error:', errorText);
      return NextResponse.json(
        { error: `Claude API error: ${claudeResponse.statusText}` },
        { status: claudeResponse.status }
      );
    }

    const data = await claudeResponse.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

============================================================

FILE: .\app\api\claude\suggest-category\route.ts
SIZE: 2.76 KB
LAST MODIFIED: 03/04/2025 10:15:32

import { NextResponse } from 'next/server';

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';

export async function POST(req: Request) {
  if (!CLAUDE_API_KEY) {
    console.error('Claude API key is not configured');
    return NextResponse.json(
      { error: 'Claude API key is not configured' },
      { status: 500 }
    );
  }

  try {
    const { phrase, categories } = await req.json();
    
    if (!phrase || !Array.isArray(categories) || categories.length === 0) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const messages = [
      {
        role: 'user',
        content: `Choose the most appropriate category for this word or phrase: "${phrase}"
                  
                  Available categories:
                  ${categories.map((cat: string) => `- ${cat}`).join('\n')}
                  
                  Rules:
                  1. Choose exactly ONE category from the list provided
                  2. Consider the meaning, theme, and subject matter
                  3. For ambiguous terms, choose the most likely category
                  4. DO NOT suggest new categories or modify existing ones
                  
                  Return ONLY the exact category name, nothing else.
                  Example: "Sports & Fitness"`
      }
    ];

    const claudeResponse = await fetch(CLAUDE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-7-sonnet-20250219',
        max_tokens: 50,
        messages: messages
      })
    });

    if (!claudeResponse.ok) {
      const errorText = await claudeResponse.text();
      console.error('Claude API error:', errorText);
      return NextResponse.json(
        { error: `Claude API error: ${claudeResponse.statusText}` },
        { status: claudeResponse.status }
      );
    }

    const data = await claudeResponse.json();
    const suggestedCategory = data.content[0].text.trim();
    
    // Verify the category is in our list
    if (!categories.includes(suggestedCategory)) {
      console.error(`Claude suggested an invalid category: "${suggestedCategory}"`);
      return NextResponse.json(
        { error: 'Invalid category suggestion' },
        { status: 500 }
      );
    }

    return NextResponse.json({ category: suggestedCategory });
  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

============================================================

FILE: .\app\components-demo\page.tsx
SIZE: 5.66 KB
LAST MODIFIED: 03/04/2025 21:19:21

// app/components-demo/page.tsx
'use client'

import React from 'react'
import { StatCard } from "@/components/ui/stat-card"
import { FileText, Users, Award, ChevronDown, TrendingUp, TrendingDown } from "lucide-react"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Table, TableBody, TableCaption, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"

export default function ComponentsDemo() {
  return (
    <div className="container mx-auto p-6 space-y-10">
      <div>
        <h1 className="text-3xl font-bold mb-6">Components Demo</h1>
        <p className="text-gray-400 mb-10">
          This page demonstrates the new UI components built with Shadcn/UI.
        </p>
      </div>

      <section>
        <h2 className="text-2xl font-semibold mb-4">Stat Cards</h2>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          <StatCard
            title="Total Phrases"
            value={1392}
            description="Total catch phrases in database"
            icon={<FileText className="h-4 w-4" />}
          />
          <StatCard
            title="Categories"
            value={13}
            description="Different word categories"
            icon={<ChevronDown className="h-4 w-4" />}
            trend={{ value: 2.5, label: "from last month", direction: "up" }}
          />
          <StatCard
            title="Active Reviewers"
            value={8}
            description="Contributors this month"
            icon={<Users className="h-4 w-4" />}
            trend={{ value: 12, label: "from last month", direction: "up" }}
          />
          <StatCard
            title="Top Contributor"
            value="Sarah"
            description="289 reviews"
            icon={<Award className="h-4 w-4" />}
            trend={{ value: 5, label: "increase in streak", direction: "up" }}
          />
        </div>
      </section>

      <section>
        <h2 className="text-2xl font-semibold mb-4">Cards</h2>
        <div className="grid gap-6 md:grid-cols-2">
          <Card>
            <CardHeader>
              <CardTitle>Create New Phrase</CardTitle>
              <CardDescription>Add a new phrase to the database</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid gap-4">
                <div className="grid gap-2">
                  <Label htmlFor="phrase">Phrase</Label>
                  <Input id="phrase" placeholder="Enter phrase" />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="category">Category</Label>
                  <Select>
                    <SelectTrigger id="category">
                      <SelectValue placeholder="Select a category" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="movies">Movies</SelectItem>
                      <SelectItem value="sports">Sports</SelectItem>
                      <SelectItem value="food">Food</SelectItem>
                      <SelectItem value="animals">Animals</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </CardContent>
            <CardFooter className="flex justify-end gap-2">
              <Button variant="outline">Cancel</Button>
              <Button>Create</Button>
            </CardFooter>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Recent Activity</CardTitle>
              <CardDescription>Last 5 reviews</CardDescription>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Reviewer</TableHead>
                    <TableHead>Phrase</TableHead>
                    <TableHead>Date</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  <TableRow>
                    <TableCell>Sarah</TableCell>
                    <TableCell>Mind over matter</TableCell>
                    <TableCell>Today</TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell>John</TableCell>
                    <TableCell>Break a leg</TableCell>
                    <TableCell>Yesterday</TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell>Emma</TableCell>
                    <TableCell>Piece of cake</TableCell>
                    <TableCell>Mar 3</TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </CardContent>
            <CardFooter>
              <Button variant="ghost" className="ml-auto">View All</Button>
            </CardFooter>
          </Card>
        </div>
      </section>

      <section>
        <h2 className="text-2xl font-semibold mb-4">Buttons</h2>
        <div className="flex flex-wrap gap-4">
          <Button>Primary</Button>
          <Button variant="secondary">Secondary</Button>
          <Button variant="destructive">Destructive</Button>
          <Button variant="outline">Outline</Button>
          <Button variant="ghost">Ghost</Button>
          <Button variant="link">Link</Button>
        </div>
      </section>
    </div>
  )
}

============================================================

FILE: .\app\review\page.tsx
SIZE: 22.25 KB
LAST MODIFIED: 03/10/2025 15:02:33

'use client';

import React, { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';
import ReviewerSelection from '@/components/review/ReviewerSelection';
import ReviewProgress from '@/components/review/ReviewProgress';
import { CategoryFilter } from '@/components/review/CategoryFilter';
import { usePhrases } from '@/hooks/use-data/usePhrases';
import { generateTags, generateHint } from '@/lib/services/claudeService';
import WordCreator from '@/components/review/WordCreator';
import type {
  Phrase,
  Reviewer,
  Vote,
  VoteCategory,
  PhraseTag,
  PhraseTagWithTag,
  Tag,
  SubcategoryName
} from '@/types/types';

// Mode type definition
type ReviewMode = 'review' | 'create';

interface FieldProps {
  label: string;
  value: string | number | undefined;
  isEditing?: boolean;
  onChange?: (value: string) => void;
  options?: string[];
  type?: 'text' | 'select' | 'number';
  currentPhrase?: Phrase;
}

interface PhraseFieldProps {
  phrase: string;
  onVote: (isLike: boolean) => void;
  rating?: boolean;
}

interface EditedPhrase {
  id: number;
  category: string | undefined;
  subcategory?: string | undefined;
  hint?: string | undefined;
  difficulty?: number | undefined;
  tags?: string | undefined;
}

const Field: React.FC<FieldProps> = ({
  label,
  value,
  isEditing = false,
  onChange,
  options = [],
  type = 'text',
  currentPhrase
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [tagInputs, setTagInputs] = useState<string[]>(() => {
    if (value && label === 'Tags') {
      const tags = value.toString().split(',').map(tag => tag.trim());
      return [...tags.slice(0, 3), ...Array(3 - tags.length).fill('')].slice(0, 3);
    }
    return ['', '', ''];
  });

  useEffect(() => {
    if (value && label === 'Tags') {
      const tags = value.toString().split(',').map(tag => tag.trim());
      setTagInputs([...tags.slice(0, 3), ...Array(3 - tags.length).fill('')].slice(0, 3));
    }
  }, [value, label]);

  const handleGenerateTags = async () => {
    if (!isEditing || !onChange || !currentPhrase?.phrase) return;

    setIsLoading(true);
    try {
      const result = await generateTags(currentPhrase.phrase);
      if (result.tags.length > 0) {
        const newTags = result.tags.slice(0, 3);
        setTagInputs([...newTags, ...Array(3 - newTags.length).fill('')]);
        onChange(newTags.join(','));
      }
    } catch (error) {
      console.error('Error generating tags:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!isEditing || !onChange || !currentPhrase?.phrase) return;
  
    setIsLoading(true);
    try {
      const result = await generateHint(currentPhrase.phrase);
      if (result.hint) {
        onChange(result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleTagChange = (index: number, newValue: string) => {
    if (!onChange) return;

    const newTags = [...tagInputs];
    newTags[index] = newValue.trim().replace(/\s+/g, '');
    setTagInputs(newTags);
    const validTags = newTags.filter(Boolean);
    onChange(validTags.join(','));
  };

  if (isEditing && label === 'Tags') {
    return (
      <div className="mb-4">
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <div className="space-y-2">
          <div className="grid grid-cols-3 gap-2">
            {tagInputs.map((tag, index) => (
              <input
                key={`tag-${index}`}
                type="text"
                value={tag}
                onChange={(e) => handleTagChange(index, e.target.value)}
                className="p-2 rounded bg-gray-700 text-white border border-gray-600"
                placeholder={`Tag ${index + 1}`}
                maxLength={16}
              />
            ))}
          </div>
          <button
            onClick={handleGenerateTags}
            disabled={isLoading}
            className="px-4 py-2 bg-blue-600 rounded hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed w-full"
          >
            {isLoading ? 'Generating...' : 'ðŸ¤– Ask AI'}
          </button>
        </div>
      </div>
    );
  }

  if (isEditing && label === 'Hint') {
    return (
      <div className="mb-4">
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <div className="flex items-center gap-2">
          <input
            type="text"
            value={value?.toString() || ''}
            onChange={(e) => onChange?.(e.target.value)}
            className="flex-1 p-2 rounded bg-gray-700 text-white border border-gray-600"
          />
          <button
            onClick={handleGenerateHint}
            disabled={isLoading}
            className="shrink-0 px-4 py-2 bg-blue-600 rounded hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center gap-2"
          >
            <span>ðŸ¤–</span>
            <span>Ask AI</span>
          </button>
        </div>
      </div>
    );
  }

  if (isEditing) {
    if (type === 'select') {
      return (
        <div className="mb-4">
          <label className="block text-gray-400 text-sm mb-1">{label}</label>
          <select
            value={value || ''}
            onChange={(e) => onChange?.(e.target.value)}
            className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
          >
            <option value="">Select {label}</option>
            {options.map((opt) => (
              <option key={opt} value={opt}>
                {opt}
              </option>
            ))}
          </select>
        </div>
      );
    }
    return (
      <div className="mb-4">
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <input
          type={type}
          value={value?.toString() || ''}
          onChange={(e) => onChange?.(e.target.value)}
          className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
        />
      </div>
    );
  }

  return (
    <div className="mb-4">
      <span className="block text-gray-400 text-sm">{label}</span>
      <span className="block text-white">{value || '-'}</span>
    </div>
  );
};

const PhraseField: React.FC<PhraseFieldProps> = ({
  phrase,
  onVote,
  rating = false
}) => {
  const buttonKey = `flag-button-${rating}`;
  
  return (
    <div className="mb-4">
      <label className="block text-gray-400 text-sm mb-1">Phrase</label>
      <div className="flex gap-2">
        <div className="flex-1 p-2 rounded bg-gray-700">
          <span className="text-white">{phrase}</span>
        </div>
        <button
          key={buttonKey}
          onClick={() => onVote(!rating)}
          type="button"
          className={`px-4 py-2 rounded flex items-center justify-center gap-2 ${
            rating 
              ? 'bg-blue-600 hover:bg-blue-700' 
              : 'bg-gray-700 hover:bg-blue-600'
          }`}
        >
          <span>ðŸš©</span>
          <span>Flag for Removal</span>
        </button>
      </div>
    </div>
  );
};

const ReviewPage: React.FC = () => {
  const [mode, setMode] = useState<ReviewMode>('review');
  const [currentReviewer, setCurrentReviewer] = useState<Reviewer | null>(null);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [previousIndex, setPreviousIndex] = useState<number | null>(null);
  const [phraseRating, setPhraseRating] = useState<boolean>(false);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [categories, setCategories] = useState<string[]>([]);
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [isEditing] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [editedPhrase, setEditedPhrase] = useState<EditedPhrase>({
    id: -1,
    category: undefined,
    subcategory: undefined,
    hint: undefined,
    difficulty: undefined,
    tags: undefined
  });
  const [hasChanges, setHasChanges] = useState(false);

  const {
    phrases,
    loading: phrasesLoading,
    handleFilterChange,
    fetchCategories: fetchCategoriesFromHook,
    fetchPhrases
  } = usePhrases();

  useEffect(() => {
    const loadCategories = async () => {
      const fetchedCategories = await fetchCategoriesFromHook();
      if (fetchedCategories) {
        setCategories(fetchedCategories);
      }
    };
    loadCategories();
  }, [fetchCategoriesFromHook]);

  useEffect(() => {
    const loadSubcategories = async () => {
      if (editedPhrase.category) {
        try {
          const { data: categoryData, error } = await supabase
            .from('categories')
            .select('id')
            .eq('name', editedPhrase.category)
            .single();
    
          if (error || !categoryData) {
            console.error('Error fetching category:', error);
            setSubcategories([]);
            return;
          }
    
          // At this point, we know categoryData exists and has an id
          const { data: subcategoryData, error: subError } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');
    
          if (subError || !subcategoryData) {
            console.error('Error fetching subcategories:', subError);
            setSubcategories([]);
            return;
          }
    
          setSubcategories(subcategoryData.map(sub => sub.name));
        } catch (err) {
          console.error('Exception in loadSubcategories:', err);
          setSubcategories([]);
        }
      } else {
        setSubcategories([]);
      }
    };

    loadSubcategories();
  }, [editedPhrase.category]);

  useEffect(() => {
    const loadPhraseData = async () => {
      const currentPhrase = phrases[currentIndex];
      if (currentPhrase) {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('name')
          .eq('id', currentPhrase.category_id)
          .single();

        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('name')
          .eq('id', currentPhrase.subcategory_id)
          .single();

        setEditedPhrase({
          id: currentPhrase.id,
          category: categoryData?.name || undefined,
          subcategory: subcategoryData?.name || undefined,
          hint: currentPhrase.hint || undefined,
          difficulty: currentPhrase.difficulty || undefined,
          tags: currentPhrase.tags || undefined
        });
        setHasChanges(false);
      }
    };

    if (mode === 'review') {
      loadPhraseData();
    }
  }, [phrases, currentIndex, mode]);

  const handleReviewerSelect = (reviewer: Reviewer) => {
    setCurrentReviewer(reviewer);
  };

  const handleCategorySelect = (category: string | null) => {
    setSelectedCategory(category);
    handleFilterChange('category', category ?? '');
    setCurrentIndex(0);
    setPhraseRating(undefined);
  };

  const handleVote = async (newFlagState: boolean) => {
    if (!currentReviewer || !phrases[currentIndex]) return;
  
    setPhraseRating(newFlagState);
  
    try {
      if (newFlagState) {
        const { error } = await supabase
          .from('votes')
          .insert({
            reviewer_id: currentReviewer.id,
            phrase_id: phrases[currentIndex].id,
            category: 'phrase',
            vote: false,
            created_at: new Date().toISOString()
          });
  
        if (error) {
          setPhraseRating(!newFlagState);
          throw error;
        }
      } else {
        const { error: deleteError } = await supabase
          .from('votes')
          .delete()
          .eq('reviewer_id', currentReviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase');
  
        if (deleteError) {
          setPhraseRating(!newFlagState);
          throw deleteError;
        }
      }
    } catch (err) {
      console.error('Error recording vote:', err);
    }
  };

  const handleFieldChange = (field: keyof EditedPhrase, value: string) => {
    setEditedPhrase(prev => ({ ...prev, [field]: value }));
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!editedPhrase.id || editedPhrase.id === -1) return;

    setIsSaving(true);
    try {
      const categoryId = await getCategoryId(editedPhrase.category);
      const subcategoryId = await getSubcategoryId(editedPhrase.category, editedPhrase.subcategory);

      const { error: phraseError } = await supabase
        .from('phrases')
        .update({
          hint: editedPhrase.hint,
          difficulty: editedPhrase.difficulty,
          category_id: categoryId,
          subcategory_id: subcategoryId
        })
        .eq('id', editedPhrase.id);

      if (phraseError) throw phraseError;

      if (editedPhrase.tags) {
        const newTags = editedPhrase.tags.split(',').map(tag => tag.trim()).filter(Boolean);
        const { data: existingTagsData } = await supabase
          .from('phrase_tags')
          .select('tags(id, tag)')
          .eq('phrase_id', editedPhrase.id);

        const existingTags = existingTagsData?.map((pt: PhraseTagWithTag) => pt.tags.tag) || [];

        const tagsToRemove = existingTags.filter((tag: string) => !newTags.includes(tag));
                for (const tagToRemove of tagsToRemove) {
          const { data: tagData } = await supabase
            .from('tags')
            .select('id')
            .eq('tag', tagToRemove)
            .single();

          if (tagData) {
            await supabase
              .from('phrase_tags')
              .delete()
              .eq('phrase_id', editedPhrase.id)
              .eq('tag_id', tagData.id);
          }
        }

        for (const newTag of newTags) {
          if (!existingTags.includes(newTag)) {
            let tagId: number | undefined;
            const { data: existingTag } = await supabase
              .from('tags')
              .select('id')
              .eq('tag', newTag)
              .single();

            if (existingTag) {
              tagId = existingTag.id;
            } else {
              const { data: newTagData } = await supabase
                .from('tags')
                .insert({ tag: newTag })
                .select('id')
                .single();

              if (newTagData) tagId = newTagData.id;
            }

            if (tagId) {
              await supabase
                .from('phrase_tags')
                .insert({
                  phrase_id: editedPhrase.id,
                  tag_id: tagId
                });
            }
          }
        }
      }

      await fetchPhrases();
      setHasChanges(false);
    } catch (err) {
      console.error('Error saving changes:', err);
    } finally {
      setIsSaving(false);
    }
  };

  const getCategoryId = async (categoryName: string | undefined) => {
    if (!categoryName) return null;
    const { data } = await supabase
      .from('categories')
      .select('id')
      .eq('name', categoryName)
      .single();
    return data?.id;
  };

  const getSubcategoryId = async (categoryName: string | undefined, subcategoryName: string | undefined) => {
    if (!categoryName || !subcategoryName) return null;
    const categoryId = await getCategoryId(categoryName);
    if (!categoryId) return null;

    const { data } = await supabase
      .from('subcategories')
      .select('id')
      .eq('name', subcategoryName)
      .eq('category_id', categoryId)
      .single();
    return data?.id;
  };

  const handleNext = () => {
    setPreviousIndex(currentIndex);
    setCurrentIndex(prev => prev + 1);
    setPhraseRating(false); // Reset rating for next phrase
  };

  const handleBack = () => {
    if (previousIndex !== null) {
      setCurrentIndex(previousIndex);
      setPreviousIndex(null);
      setPhraseRating(undefined);
    }
  };

  const handleModeChange = (newMode: ReviewMode) => {
    setMode(newMode);
  };

  if (phrasesLoading) {
    return (
      <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
        Loading...
      </div>
    );
  }

  if (!currentReviewer) {
    return (
      <ReviewerSelection
        onSelectReviewer={handleReviewerSelect}
        onClose={() => {}}
      />
    );
  }

  // Show word creator if in create mode
  if (mode === 'create') {
    return (
      <WordCreator 
        reviewer={currentReviewer} 
        categories={categories}
        onSwitchMode={() => setMode('review')}
      />
    );
  }

  const currentPhrase = phrases[currentIndex];

  if (!currentPhrase) {
    return (
      <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-4">All caught up! ðŸŽ‰</h2>
          <p>You've reviewed all available phrases.</p>
          <div className="flex gap-4 justify-center mt-6">
            <button
              onClick={() => setCurrentReviewer(null)}
              className="px-4 py-2 bg-blue-600 rounded hover:bg-blue-700"
            >
              Switch Reviewer
            </button>
            <button
              onClick={() => setMode('create')}
              className="px-4 py-2 bg-green-600 rounded hover:bg-green-700"
            >
              Create New Words
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4">
      <div className="max-w-2xl mx-auto">
        <div className="mb-6">
          <div className="flex justify-between items-start">
            <div>
              <h1 className="text-2xl font-bold">Phrase Review</h1>
              <p className="text-gray-400 mt-2">
                Reviewer: {currentReviewer.name} ({currentReviewer.total_reviews} reviews)
              </p>
            </div>
            <div className="flex gap-2">
              <button
                onClick={() => setMode('create')}
                className="px-4 py-2 bg-green-600 rounded hover:bg-green-700"
              >
                Create New Words
              </button>
              <button
                onClick={() => setCurrentReviewer(null)}
                className="px-4 py-2 bg-gray-800 rounded hover:bg-gray-700"
              >
                Switch Reviewer
              </button>
            </div>
          </div>
        </div>

        <div className="flex items-center gap-4 mb-6">
          <CategoryFilter
            categories={categories}
            selectedCategory={selectedCategory}
            onSelect={handleCategorySelect}
          />
          <div className="flex-1">
            <ReviewProgress streak={currentReviewer.current_streak} />
          </div>
        </div>

        <div className="bg-gray-800 rounded p-6">
          <PhraseField
            phrase={currentPhrase.phrase}
            onVote={handleVote}
            rating={phraseRating}
          />
          <Field
            label="Difficulty"
            value={
              editedPhrase.difficulty === 1 ? 'Easy' :
              editedPhrase.difficulty === 2 ? 'Medium' :
              editedPhrase.difficulty === 3 ? 'Hard' :
              '-'
            }
            isEditing={isEditing}
            onChange={(value) => {
              const difficultyMap = { 'Easy': 1, 'Medium': 2, 'Hard': 3 };
              handleFieldChange('difficulty', difficultyMap[value as keyof typeof difficultyMap].toString());
            }}
            type="select"
            options={['Easy', 'Medium', 'Hard']}
          />
          <Field
            label="Category"
            value={editedPhrase.category || ''}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('category', value)}
            type="select"
            options={categories}
          />
          <Field
            label="Subcategory"
            value={editedPhrase.subcategory || ''}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('subcategory', value)}
            type="select"
            options={subcategories}
          />
          <Field
            label="Tags"
            value={editedPhrase.tags}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('tags', value)}
            currentPhrase={currentPhrase}
          />
          <Field
            label="Hint"
            value={editedPhrase.hint}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('hint', value)}
            currentPhrase={currentPhrase}
          />
          <div className="flex justify-between items-center mt-6">
            <button
              onClick={handleSave}
              disabled={!hasChanges || isSaving}
              className={`px-4 py-2 md:text-base rounded ${
                hasChanges ? 'bg-blue-600 hover:bg-blue-700' : 'bg-gray-600 cursor-not-allowed'
              }`}
            >
              {isSaving ? 'Saving...' : 'Save Changes'}
            </button>
            <div className="flex items-center gap-4">
              <div className="flex gap-2">
                {previousIndex !== null && (
                  <button
                    className="w-12 h-12 rounded-full flex items-center justify-center bg-gray-700 hover:bg-gray-600"
                    onClick={handleBack}
                  >
                    â†
                  </button>
                )}
                <button
                  className="w-12 h-12 rounded-full flex items-center justify-center bg-blue-600 hover:bg-blue-700"
                  onClick={handleNext}
                >
                  â†’
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ReviewPage;


============================================================

FILE: .\components\AdminNavBar.tsx
SIZE: 1.6 KB
LAST MODIFIED: 03/05/2025 15:03:18

import React from 'react';
import { supabase } from '@/lib/services/supabase';
import { Button } from "@/components/ui/button";
import type { Session } from '@supabase/supabase-js';

interface AdminNavBarProps {
  session: Session | null;
  setShowLoginModal: (show: boolean) => void;
}

const AdminNavBar: React.FC<AdminNavBarProps> = ({ 
  session, 
  setShowLoginModal 
}) => {
  const handleLogout = async () => {
    await supabase.auth.signOut();
    window.location.href = '/admin';
  };

  return (
    <div className="max-w-[1920px] mx-auto">
    <nav className="bg-gray-800 p-6 rounded-lg shadow mb-8">
      <div className="flex justify-between items-center">
        <div className="flex items-center">
          <div className="text-white text-xl font-bold">Admin Dashboard</div>
    
          {session?.user && (
            <span className="text-gray-400 text-sm">
              {session.user.email}
            </span>
          )}
        </div>
        <div className="flex items-center gap-4">
          {session ? (
            <>
              <Button
                onClick={handleLogout}
                variant="destructive"
                className="hover:bg-red-700"
              >
                Logout
              </Button>
            </>
          ) : (
            <Button
              onClick={() => setShowLoginModal(true)}
              className="bg-blue-600 hover:bg-blue-700"
            >
              Login
            </Button>
          )}
        </div>
      </div>
    </nav>
    </div>
  );
};

export default AdminNavBar;


============================================================

FILE: .\components\Login.tsx
SIZE: 3.1 KB
LAST MODIFIED: 03/05/2025 15:03:18

import React, { useState } from 'react';
import { supabase } from '@/lib/services/supabase';
import { X } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface LoginProps {
  onClose: () => void;
}

const Login: React.FC<LoginProps> = ({ onClose }) => {
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const handleLogin = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    setSuccess(false);

    try {
      const { error } = await supabase.auth.signInWithOtp({ 
        email,
        options: {
          emailRedirectTo: window.location.origin + '/admin'
        }
      });

      if (error) throw error;

      setSuccess(true);
    } catch (err) {
      console.error('Login error:', err);
      setError(
        err instanceof Error 
          ? err.message 
          : 'An unexpected error occurred'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="relative">
      <button
        onClick={onClose}
        className="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors"
      >
        <X className="h-6 w-6" />
      </button>

      <div className="p-6">
        <h2 className="text-2xl font-bold mb-6">Admin Login</h2>

        {error && (
          <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-6">
            {error}
          </div>
        )}

        {success ? (
          <div className="bg-green-900 border border-green-700 text-green-100 px-4 py-3 rounded mb-6">
            Check your email for the login link!
          </div>
        ) : (
          <form onSubmit={handleLogin} className="space-y-6">
            <div>
              <label 
                htmlFor="email"
                className="block text-sm font-medium mb-2"
              >
                Email Address
              </label>
              <input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Enter your email"
                required
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:outline-none focus:ring-2 
                         focus:ring-blue-500 focus:border-transparent"
              />
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="w-full"
            >
              {loading ? 'Sending...' : 'Send Magic Link'}
            </Button>

            <p className="text-sm text-gray-400 mt-4">
              A magic link will be sent to your email address.
              Click the link to log in to the admin dashboard.
            </p>
          </form>
        )}
      </div>
    </div>
  );
};

export default Login;


============================================================

FILE: .\components\AdminDashboard\index.tsx
SIZE: 7.4 KB
LAST MODIFIED: 03/10/2025 15:00:22

'use client'

import React, { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { AuthChangeEvent, Session } from '@supabase/supabase-js';
import type { 
  Phrase, 
  NewPhrase,
  Stats,
  Filters,
  PaginationState,
  SortConfig 
} from '@/types/types';

// Component imports
import AdminNavBar from '@/components/admin/AdminNavBar';
import StatsSection from '@/components/common/StatsSection';
import AddPhraseForm from '@/components/shared/AddPhraseForm';
import BulkImportForm from '@/components/shared/BulkImportForm';
import FilterControls from '@/components/common/FilterControls';
import PhrasesTable from '@/components/common/PhrasesTable';
import CardViewModal from '@/components/shared/CardViewModal';
import Login from '@/components/common/Login';

// Hook imports
import { usePhrases } from '@/hooks/usePhrases';
import { usePhraseMetadata } from '@/hooks/use-data/usePhraseMetadata';
import { useStats } from '@/hooks/useStats';

		// Type definitions
		interface EditorState {
		  showCardModal: boolean;
		  currentCardIndex: number;
		  isEditing: boolean;
		  editedPhrase: Phrase | null;
		  newIds: number[];
		}

		const AdminDashboard: React.FC = () => {
		  // Auth State
		  const [showLoginModal, setShowLoginModal] = useState<boolean>(false);
		  const [session, setSession] = useState<Session | null>(null);
		  const [isLoading, setIsLoading] = useState<boolean>(true);

		  // Initialize Hooks
		  const {
			phrases,
			loading: phrasesLoading,
			error,
			setError,
			pagination,
			sortConfig,
			filters,
			handleSort,
			handlePageChange,
			handleRowsPerPageChange,
			handleFilterChange,
			addPhrase,
			editPhrase,
			deletePhrase,
			fetchPhrases,
			resetFilters,
			sortByIdDesc
		  } = usePhrases();

		  const { 
			categories, 
			difficulties, 
			partsOfSpeech, 
			loading: metadataLoading 
		  } = usePhraseMetadata();

		  const { stats, loading: statsLoading } = useStats();

		  // Editor State
		  const [editorState, setEditorState] = useState<EditorState>({
			showCardModal: false,
			currentCardIndex: 0,
			isEditing: false,
			editedPhrase: null,
			newIds: []
		  });

		  // Initialize Auth
		  useEffect(() => {
			const initializeAuth = async () => {
			  const { data: { session } } = await supabase.auth.getSession();
			  setSession(session);
			  setIsLoading(false);
			};

			initializeAuth();

			const { data: { subscription } } = supabase.auth.onAuthStateChange(
			  (event: AuthChangeEvent, session: Session | null) => {
				setSession(session);
				if (session) {
				  setShowLoginModal(false);
				}
			  }
			);

			return () => subscription.unsubscribe();
		  }, []);

		  // Handlers
		  const handleBulkImportSuccess = (importedIds: number[] = []) => {
			fetchPhrases();
			sortByIdDesc();
			setEditorState(prev => ({ ...prev, newIds: importedIds }));
			setError(null);

			if (importedIds.length > 0) {
			  setTimeout(() => setEditorState(prev => ({ ...prev, newIds: [] })), 2000);
			}
		  };

		  const handleBulkImportError = (errorMessage: string) => {
			setError(errorMessage);
		  };

		  // Auth check
		  const checkAuth = async (): Promise<boolean> => {
			const { data: { session } } = await supabase.auth.getSession();
			setSession(session);
			if (!session) {
			  setShowLoginModal(true);
			  return false;
			}
			return true;
		  };

		  // Card Modal Handlers
		  const handleCardEdit = async () => {
			if (!(await checkAuth())) return;
			const phrase = phrases[editorState.currentCardIndex];
			if (!phrase) return;
			
			setEditorState(prev => ({
			  ...prev,
			  editedPhrase: phrase,
			  isEditing: true
			}));
		  };

		  const handleCardSave = async () => {
			if (!editorState.editedPhrase) return;
			await editPhrase(editorState.editedPhrase);
			setEditorState(prev => ({
			  ...prev,
			  showCardModal: false,
			  isEditing: false
			}));
		  };

		  const handleCardCancel = () => {
			setEditorState(prev => ({
			  ...prev,
			  editedPhrase: null,
			  isEditing: false
			}));
		  };

		  const handleTagClick = (tag: string) => {
			handleFilterChange('searchTerm', tag);
			setEditorState(prev => ({ ...prev, showCardModal: false }));
		  };

		  if (isLoading) {
			return (
			  <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
				<div className="text-xl">Loading dashboard...</div>
			  </div>
			);
		  }

		  return (
			<div className="min-h-screen bg-gray-900 text-white p-4 lg:p-8">
			  {/* Navigation */}
			  <AdminNavBar 
				session={session} 
				setShowLoginModal={setShowLoginModal} 
			  />

			  {/* Main Content */}
			  <div className="max-w-[1920px] mx-auto">
				{/* Error Display */}
				{error && (
				  <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-6">
					{error}
				  </div>
				)}

				{/* Stats Section */}
				<StatsSection 
				  stats={stats} 
				  loading={statsLoading} 
				/>

				{/* Forms Section */}
				<div className="grid grid-cols-2 gap-6 mb-8">
				  <AddPhraseForm
					onAddPhrase={addPhrase}
					categories={categories}
					difficulties={difficulties}
					partsOfSpeech={partsOfSpeech}
					loading={metadataLoading}
				  />
				  <BulkImportForm
					onSuccess={handleBulkImportSuccess}
					onError={handleBulkImportError}
				  />
				</div>

				{/* Filters */}
				<FilterControls
				  filters={filters}
				  onChange={handleFilterChange}
				  onReset={resetFilters}
				  categories={categories}
				  difficulties={difficulties}
				  partsOfSpeech={partsOfSpeech}
				/>

				{/* Table */}
				<PhrasesTable
				  phrases={phrases}
				  loading={phrasesLoading}
				  pagination={pagination}
				  sortConfig={sortConfig}
				  onSort={handleSort}
				  onPageChange={handlePageChange}
				  onRowsPerPageChange={handleRowsPerPageChange}
				  onEdit={editPhrase}
				  onDelete={deletePhrase}
				  onShowCardView={() => setEditorState(prev => ({ ...prev, showCardModal: true }))}
				  newIds={editorState.newIds}
				/>

				{/* Modals */}
				{showLoginModal && (
				  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
					<div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full">
					  <Login onClose={() => setShowLoginModal(false)} />
					</div>
				  </div>
				)}

				{editorState.showCardModal && (
				  <CardViewModal
					isOpen={editorState.showCardModal}
					onClose={() => setEditorState(prev => ({ ...prev, showCardModal: false }))}
					phrases={phrases}
					currentIndex={editorState.currentCardIndex}
					onNavigate={(index) => setEditorState(prev => ({ ...prev, currentCardIndex: index }))}
					isEditing={editorState.isEditing}
					editedPhrase={editorState.editedPhrase}
					onEdit={handleCardEdit}
					onSave={handleCardSave}
					onCancel={handleCardCancel}
					onEditChange={(field, value) => {
					  if (editorState.editedPhrase) {
						setEditorState(prev => ({
						  ...prev,
						  editedPhrase: { ...prev.editedPhrase!, [field]: value }
						}));
					  }
					}}
					categories={categories}
					difficulties={difficulties}
					partsOfSpeech={partsOfSpeech}
					onTagClick={handleTagClick}
				  />
				)}
			  </div>
			</div>
		  );
		};

		export default AdminDashboard;

============================================================

FILE: .\components\common\CategorySelect.tsx
SIZE: 1.14 KB
LAST MODIFIED: 02/09/2025 10:30:14

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import type { SelectProps } from '@/types/types';

const CategorySelect: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  placeholder = "Select Category",
  required = false,
  disabled = false,
  className = ''
}) => {
  return (
    <div className={`w-full space-y-2 ${className}`}>
      <Select
        value={value}
        onValueChange={onChange}
        required={required}
        disabled={disabled}
      >
        <SelectTrigger className="w-full bg-gray-700 border-gray-600">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {!required && (
            <SelectItem value="">
              All Categories
            </SelectItem>
          )}
          {options.map((option) => (
            <SelectItem key={option} value={option}>
              {option}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default CategorySelect;

============================================================

FILE: .\components\common\DifficultySelect.tsx
SIZE: 1.4 KB
LAST MODIFIED: 02/09/2025 10:30:23

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import type { SelectProps } from '@/types/types';

const difficultyColors = {
  Easy: 'text-green-400',
  Medium: 'text-yellow-400',
  Hard: 'text-red-400'
};

const DifficultySelect: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  placeholder = "Select Difficulty",
  required = false,
  disabled = false,
  className = ''
}) => {
  return (
    <div className={`w-full space-y-2 ${className}`}>
      <Select
        value={value}
        onValueChange={onChange}
        required={required}
        disabled={disabled}
      >
        <SelectTrigger className="w-full bg-gray-700 border-gray-600">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {!required && (
            <SelectItem value="">
              All Difficulties
            </SelectItem>
          )}
          {options.map((difficulty) => (
            <SelectItem 
              key={difficulty} 
              value={difficulty}
              className={difficultyColors[difficulty as keyof typeof difficultyColors]}
            >
              {difficulty}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DifficultySelect;

============================================================

FILE: .\components\common\ExportModal.tsx
SIZE: 3.91 KB
LAST MODIFIED: 03/07/2025 17:10:25

// src/components/common/ExportModal.tsx

import React, { useState } from 'react';
import { saveAs } from 'file-saver';
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogFooter, 
  DialogHeader, 
  DialogTitle
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

interface ExportModalProps {
  isOpen: boolean;
  onClose: () => void;
  onExport: (options: ExportOptions) => Promise<ExportResult | null>;
  isLoading: boolean;
}

interface ExportOptions {
  exportJson: boolean;
  exportHeader: boolean;
  optimizeForESP32: boolean;
}

interface ExportResult {
  jsonData: any;
  headerContent: string;
}

const ExportModal: React.FC<ExportModalProps> = ({ 
  isOpen, 
  onClose, 
  onExport,
  isLoading
}) => {
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    exportJson: true,
    exportHeader: true,
    optimizeForESP32: true
  });

  const handleOptionChange = (option: keyof ExportOptions) => {
    setExportOptions(prev => ({
      ...prev,
      [option]: !prev[option]
    }));
  };

  const handleExport = async () => {
    const data = await onExport(exportOptions);
    
    if (!data) return;

    // Download files based on options
    if (exportOptions.exportJson) {
      const jsonBlob = new Blob(
        [JSON.stringify(data.jsonData, null, 2)], 
        { type: 'application/json' }
      );
      saveAs(jsonBlob, 'phrases_esp32.json');
    }
    
    if (exportOptions.exportHeader) {
      const headerBlob = new Blob(
        [data.headerContent], 
        { type: 'text/plain' }
      );
      saveAs(headerBlob, 'phrases.h');
    }

    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Export Phrases for ESP32</DialogTitle>
          <DialogDescription>
            Choose export options for your ESP32 catch phrase game
          </DialogDescription>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-json" 
              checked={exportOptions.exportJson} 
              onCheckedChange={() => handleOptionChange('exportJson')}
            />
            <Label htmlFor="export-json">Export JSON file (for SPIFFS)</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-header" 
              checked={exportOptions.exportHeader} 
              onCheckedChange={() => handleOptionChange('exportHeader')}
            />
            <Label htmlFor="export-header">Export Arduino header file</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="optimize" 
              checked={exportOptions.optimizeForESP32} 
              onCheckedChange={() => handleOptionChange('optimizeForESP32')}
            />
            <Label htmlFor="optimize">Optimize for ESP32 memory usage</Label>
          </div>
        </div>
        
        <DialogFooter>
          <Button type="button" variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleExport}
            disabled={isLoading}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Exporting...
              </>
            ) : (
              'Export'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default ExportModal;

============================================================

FILE: .\components\common\FilterControls.tsx
SIZE: 7.79 KB
LAST MODIFIED: 03/05/2025 15:03:18

import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Search, X } from 'lucide-react';
import type { FilterControlsProps, Filters } from '@/types/types';
import { supabase } from '@/lib/services/supabase';

// Add interface for subcategory data
interface SubcategoryData {
  name: string;
}

const FilterControls: React.FC<FilterControlsProps> = ({
  filters,
  onChange,
  onReset,
  categories = [],
  difficulties = [],
  partsOfSpeech = [],
  loading = false
}) => {
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  // Fetch subcategories when category changes
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!filters.category) {
        setSubcategories([]);
        return;
      }

      setIsLoading(true);
      try {
        // First get category_id
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          // Then get subcategories for this category
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');

          if (subcategoryData) {
            setSubcategories(subcategoryData.map((sub: SubcategoryData) => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchSubcategories();
  }, [filters.category]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    // Reset subcategory when category changes
    if (name === 'category' && value !== filters.category) {
      onChange('subcategory', '');
    }
    onChange(name, value);
  };

  const handleSearchClear = () => {
    onChange('searchTerm', '');
  };

  const handleFilterClear = (filterName: keyof Filters) => {
    onChange(filterName, '');
  };

  // Render active filters pills
  const renderActiveFilters = () => {
    const activeFilters = Object.entries(filters).filter(([_, value]) => value);
    if (activeFilters.length === 0) return null;

    return (
      <div className="mt-4 flex flex-wrap gap-2">
        {activeFilters.map(([key, value]) => (
          <div
            key={key}
            className="flex items-center gap-1 px-2 py-1 bg-gray-700 rounded-full text-sm"
          >
            <span className="text-gray-400">
              {key === 'searchTerm' ? 'Search' : key}:
            </span>
            <span className="text-white">{value}</span>
            <button
              onClick={() => handleFilterClear(key as keyof Filters)}
              className="ml-1 text-gray-400 hover:text-white"
            >
              <X className="h-3 w-3" />
            </button>
          </div>
        ))}
      </div>
    );
  };

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow mb-8">
      <h2 className="text-xl font-semibold mb-4">Filters</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
        {/* Search Input */}
        <div className="relative">
          <label className="block text-sm font-medium mb-1">
            Search
          </label>
          <div className="relative">
            <input
              type="text"
              name="searchTerm"
              value={filters.searchTerm}
              onChange={handleChange}
              placeholder="Search phrases or tags..."
              className="w-full pl-10 pr-10 py-2 bg-gray-700 border border-gray-600 
                       rounded text-white placeholder-gray-400
                       focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <Search className="absolute left-3 top-2.5 h-5 w-5 text-gray-400" />
            {filters.searchTerm && (
              <button
                onClick={handleSearchClear}
                className="absolute right-3 top-2.5 text-gray-400 
                         hover:text-gray-300 transition-colors"
              >
                <X className="h-5 w-5" />
              </button>
            )}
          </div>
        </div>

        {/* Category Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Category
          </label>
          <select
            name="category"
            value={filters.category}
            onChange={handleChange}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Categories</option>
            {categories.map(category => (
              <option key={category} value={category}>
                {category}
              </option>
            ))}
          </select>
        </div>

        {/* Subcategory Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Subcategory
          </label>
          <select
            name="subcategory"
            value={filters.subcategory}
            onChange={handleChange}
            disabled={!filters.category || isLoading}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500 
                     disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <option value="">All Subcategories</option>
            {subcategories.map(subcategory => (
              <option key={subcategory} value={subcategory}>
                {subcategory}
              </option>
            ))}
          </select>
        </div>

        {/* Difficulty Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Difficulty
          </label>
          <select
            name="difficulty"
            value={filters.difficulty}
            onChange={handleChange}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Difficulties</option>
            {difficulties.map(difficulty => (
              <option key={difficulty} value={difficulty}>
                {difficulty}
              </option>
            ))}
          </select>
        </div>

        {/* Part of Speech Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Part of Speech
          </label>
          <select
            name="part_of_speech"
            value={filters.part_of_speech}
            onChange={handleChange}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Parts of Speech</option>
            {partsOfSpeech.map(pos => (
              <option key={pos} value={pos}>
                {pos}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Filter Actions */}
      <div className="flex justify-end gap-4">
        <Button
          variant="outline"
          onClick={onReset}
          className="flex items-center gap-2"
        >
          <X className="h-4 w-4" />
          Reset Filters
        </Button>
      </div>

      {/* Active Filters */}
      {renderActiveFilters()}
    </div>
  );
};

export default FilterControls;


============================================================

FILE: .\components\common\FilterModal.tsx
SIZE: 5.5 KB
LAST MODIFIED: 03/05/2025 16:59:06

// components/common/FilterModal.tsx
import React from 'react';
import { X, Search } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface FilterModalProps {
  isOpen: boolean;
  onClose: () => void;
  filters: {
    searchTerm: string;
    category: string;
    difficulty: string;
    subcategory: string;
    part_of_speech: string;
  };
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  subcategories: string[];
}

const FilterModal: React.FC<FilterModalProps> = ({
  isOpen,
  onClose,
  filters,
  onChange,
  onReset,
  categories,
  difficulties,
  partsOfSpeech,
  subcategories = []
}) => {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Filter Phrases</DialogTitle>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          {/* Search */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Search</label>
            <div className="relative">
              <Search className="absolute left-3 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                value={filters.searchTerm}
                onChange={(e) => onChange('searchTerm', e.target.value)}
                placeholder="Search phrases or tags..."
                className="pl-9"
              />
            </div>
          </div>
          
          {/* Category */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Category</label>
            <Select
              value={filters.category}
              onValueChange={(value) => onChange('category', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Categories</SelectItem>
                {categories.map(category => (
                  <SelectItem key={category} value={category}>
                    {category}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Subcategory */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Subcategory</label>
            <Select
              value={filters.subcategory}
              onValueChange={(value) => onChange('subcategory', value)}
              disabled={!filters.category}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Subcategories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Subcategories</SelectItem>
                {subcategories.map(subcategory => (
                  <SelectItem key={subcategory} value={subcategory}>
                    {subcategory}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Difficulty */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Difficulty</label>
            <Select
              value={filters.difficulty}
              onValueChange={(value) => onChange('difficulty', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Difficulties" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Difficulties</SelectItem>
                {difficulties.map(difficulty => (
                  <SelectItem key={difficulty} value={difficulty}>
                    {difficulty}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Part of Speech */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Part of Speech</label>
            <Select
              value={filters.part_of_speech}
              onValueChange={(value) => onChange('part_of_speech', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Parts of Speech" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Parts of Speech</SelectItem>
                {partsOfSpeech.map(pos => (
                  <SelectItem key={pos} value={pos}>
                    {pos}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
        
        <DialogFooter className="flex justify-between">
          <Button 
            variant="outline" 
            onClick={onReset}
            className="flex items-center gap-1"
          >
            <X className="h-4 w-4" />
            Reset Filters
          </Button>
          <Button type="submit" onClick={onClose}>Apply Filters</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default FilterModal;

============================================================

FILE: .\components\common\LoadingSpinner.tsx
SIZE: 0.6 KB
LAST MODIFIED: 02/09/2025 10:29:05

import React from 'react';
import type { LoadingSpinnerProps } from '@/types/types';

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  size = 'medium',
  className = ''
}) => {
  const sizeClasses = {
    small: 'h-4 w-4',
    medium: 'h-8 w-8',
    large: 'h-12 w-12'
  };

  return (
    <div className={`flex justify-center items-center ${className}`}>
      <div
        className={`
          animate-spin rounded-full
          border-t-2 border-b-2 border-blue-500
          ${sizeClasses[size]}
        `}
      />
    </div>
  );
};

export default LoadingSpinner;

============================================================

FILE: .\components\common\Login.tsx
SIZE: 3.1 KB
LAST MODIFIED: 03/05/2025 15:03:18

import React, { useState } from 'react';
import { supabase } from '@/lib/services/supabase';
import { X } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface LoginProps {
  onClose: () => void;
}

const Login: React.FC<LoginProps> = ({ onClose }) => {
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const handleLogin = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    setSuccess(false);

    try {
      const { error } = await supabase.auth.signInWithOtp({ 
        email,
        options: {
          emailRedirectTo: window.location.origin + '/admin'
        }
      });

      if (error) throw error;

      setSuccess(true);
    } catch (err) {
      console.error('Login error:', err);
      setError(
        err instanceof Error 
          ? err.message 
          : 'An unexpected error occurred'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="relative">
      <button
        onClick={onClose}
        className="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors"
      >
        <X className="h-6 w-6" />
      </button>

      <div className="p-6">
        <h2 className="text-2xl font-bold mb-6">Admin Login</h2>

        {error && (
          <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-6">
            {error}
          </div>
        )}

        {success ? (
          <div className="bg-green-900 border border-green-700 text-green-100 px-4 py-3 rounded mb-6">
            Check your email for the login link!
          </div>
        ) : (
          <form onSubmit={handleLogin} className="space-y-6">
            <div>
              <label 
                htmlFor="email"
                className="block text-sm font-medium mb-2"
              >
                Email Address
              </label>
              <input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Enter your email"
                required
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:outline-none focus:ring-2 
                         focus:ring-blue-500 focus:border-transparent"
              />
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="w-full"
            >
              {loading ? 'Sending...' : 'Send Magic Link'}
            </Button>

            <p className="text-sm text-gray-400 mt-4">
              A magic link will be sent to your email address.
              Click the link to log in to the admin dashboard.
            </p>
          </form>
        )}
      </div>
    </div>
  );
};

export default Login;


============================================================

FILE: .\components\common\PaginationBar.tsx
SIZE: 1 KB
LAST MODIFIED: 02/09/2025 10:32:15

import React from 'react';

interface PaginationInfoProps {
  currentPage: number;
  pageSize: number;
  totalItems: number;
  className?: string;
}

const PaginationInfo: React.FC<PaginationInfoProps> = ({
  currentPage,
  pageSize,
  totalItems,
  className = ''
}) => {
  const startIndex = (currentPage - 1) * pageSize + 1;
  const endIndex = Math.min(startIndex + pageSize - 1, totalItems);

  return (
    <div className={`text-sm text-gray-400 ${className}`}>
      {totalItems === 0 ? (
        'No items'
      ) : (
        <>
          Showing{' '}
          <span className="font-medium text-white">
            {startIndex}
          </span>{' '}
          to{' '}
          <span className="font-medium text-white">
            {endIndex}
          </span>{' '}
          of{' '}
          <span className="font-medium text-white">
            {totalItems}
          </span>{' '}
          items
        </>
      )}
    </div>
  );
};

export default PaginationInfo;

============================================================

FILE: .\components\common\PaginationControls.tsx
SIZE: 3.22 KB
LAST MODIFIED: 02/09/2025 10:31:02

import React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface PaginationControlsProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  showPageNumbers?: boolean;
  siblingCount?: number;
  boundaryCount?: number;
}

const PaginationControls: React.FC<PaginationControlsProps> = ({
  currentPage,
  totalPages,
  onPageChange,
  showPageNumbers = true,
  siblingCount = 1,
  boundaryCount = 1
}) => {
  const getPageNumbers = () => {
    const totalNumbers = (siblingCount * 2) + 3;
    const totalBlocks = totalNumbers + 2;

    if (totalPages <= totalBlocks) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    const leftSiblingIndex = Math.max(currentPage - siblingCount, boundaryCount);
    const rightSiblingIndex = Math.min(
      currentPage + siblingCount,
      totalPages - boundaryCount
    );

    const shouldShowLeftDots = leftSiblingIndex > boundaryCount + 2;
    const shouldShowRightDots = rightSiblingIndex < totalPages - (boundaryCount + 1);

    if (!shouldShowLeftDots && shouldShowRightDots) {
      const leftItemCount = 3 + 2 * siblingCount;
      const leftRange = Array.from({ length: leftItemCount }, (_, i) => i + 1);
      return [...leftRange, '...', totalPages];
    }

    if (shouldShowLeftDots && !shouldShowRightDots) {
      const rightItemCount = 3 + 2 * siblingCount;
      const rightRange = Array.from(
        { length: rightItemCount },
        (_, i) => totalPages - rightItemCount + i + 1
      );
      return [1, '...', ...rightRange];
    }

    if (shouldShowLeftDots && shouldShowRightDots) {
      const middleRange = Array.from(
        { length: rightSiblingIndex - leftSiblingIndex + 1 },
        (_, i) => leftSiblingIndex + i
      );
      return [1, '...', ...middleRange, '...', totalPages];
    }
  };

  return (
    <div className="flex items-center justify-center gap-2">
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
        className="h-8 w-8 p-0"
      >
        <ChevronLeft className="h-4 w-4" />
      </Button>

      {showPageNumbers && getPageNumbers()?.map((page, index) => {
        if (page === '...') {
          return (
            <span 
              key={`ellipsis-${index}`}
              className="px-2 text-gray-400"
            >
              &#8230;
            </span>
          );
        }

        return (
          <Button
            key={page}
            variant={currentPage === page ? 'default' : 'outline'}
            size="sm"
            onClick={() => onPageChange(page as number)}
            className={`h-8 w-8 p-0 ${
              currentPage === page
                ? 'bg-blue-600 hover:bg-blue-700'
                : 'hover:bg-gray-700'
            }`}
          >
            {page}
          </Button>
        );
      })}

      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
        className="h-8 w-8 p-0"
      >
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
};

export default PaginationControls;

============================================================

FILE: .\components\common\PaginationInfo.tsx
SIZE: 1 KB
LAST MODIFIED: 02/09/2025 10:31:50

import React from 'react';

interface PaginationInfoProps {
  currentPage: number;
  pageSize: number;
  totalItems: number;
  className?: string;
}

const PaginationInfo: React.FC<PaginationInfoProps> = ({
  currentPage,
  pageSize,
  totalItems,
  className = ''
}) => {
  const startIndex = (currentPage - 1) * pageSize + 1;
  const endIndex = Math.min(startIndex + pageSize - 1, totalItems);

  return (
    <div className={`text-sm text-gray-400 ${className}`}>
      {totalItems === 0 ? (
        'No items'
      ) : (
        <>
          Showing{' '}
          <span className="font-medium text-white">
            {startIndex}
          </span>{' '}
          to{' '}
          <span className="font-medium text-white">
            {endIndex}
          </span>{' '}
          of{' '}
          <span className="font-medium text-white">
            {totalItems}
          </span>{' '}
          items
        </>
      )}
    </div>
  );
};

export default PaginationInfo;

============================================================

FILE: .\components\common\PartOfSpeechSelect.tsx
SIZE: 1.18 KB
LAST MODIFIED: 02/09/2025 10:30:30

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import type { SelectProps } from '@/types/types';

const PartOfSpeechSelect: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  placeholder = "Select Part of Speech",
  required = false,
  disabled = false,
  className = ''
}) => {
  return (
    <div className={`w-full space-y-2 ${className}`}>
      <Select
        value={value}
        onValueChange={onChange}
        required={required}
        disabled={disabled}
      >
        <SelectTrigger className="w-full bg-gray-700 border-gray-600">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {!required && (
            <SelectItem value="">
              All Parts of Speech
            </SelectItem>
          )}
          {options.map((partOfSpeech) => (
            <SelectItem key={partOfSpeech} value={partOfSpeech}>
              {partOfSpeech}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default PartOfSpeechSelect;

============================================================

FILE: .\components\common\PhrasesTable.tsx
SIZE: 12.17 KB
LAST MODIFIED: 03/10/2025 14:32:15

// components/common/PhrasesTable.tsx
import React, { useEffect, useState } from 'react';
import { ChevronDown, ChevronUp, Pencil, Trash2, Filter, MoreHorizontal } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Checkbox } from "@/components/ui/checkbox";
import TagDisplay from '@/components/common/TagDisplay';
import { cn } from "@/lib/utils";

const PhrasesTable = ({
  phrases = [],
  loading,
  sortConfig = { key: '', direction: 'asc' },
  pagination,
  onSort,
  onEdit,
  onDelete,
  onPageChange,
  onRowsPerPageChange,
  newIds = [],
  onShowFilters
}) => {
  // State for selected rows
  const [selectedRows, setSelectedRows] = useState([]);
  
  // Column headers definition
  const columnHeaders = [
    { key: 'id', label: 'ID' },
    { key: 'phrase', label: 'Phrase' },
    { key: 'category', label: 'Category' },
    { key: 'difficulty', label: 'Difficulty' },
    { key: 'tags', label: 'Tags' },
    { key: 'hint', label: 'Hint' }
  ];

  // Define difficulty labels
  const difficultyLabels = {
    1: 'Easy',
    2: 'Medium',
    3: 'Hard',
  };

  // Ensure the dropdown displays the correct rows per page on load
  useEffect(() => {
    // This ensures we show the correct value in the dropdown
    if (pagination.rowsPerPage !== 20) {
      onRowsPerPageChange(20);
    }
  }, []);

  // Clear selected rows when page changes
  useEffect(() => {
    setSelectedRows([]);
  }, [pagination.currentPage]);

  const handleDelete = async (id) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      await onDelete(id);
    }
  };

  const handleBulkDelete = async () => {
    if (window.confirm(`Are you sure you want to delete ${selectedRows.length} phrases?`)) {
      // Assuming onDelete can handle an array of IDs for bulk deletion
      // If it can't, you would need to loop through and delete each one
      await Promise.all(selectedRows.map(id => onDelete(id)));
      setSelectedRows([]);
    }
  };

  const toggleSelectAll = () => {
    if (selectedRows.length === phrases.length) {
      setSelectedRows([]);
    } else {
      setSelectedRows(phrases.map(phrase => phrase.id));
    }
  };

  const toggleRowSelection = (id) => {
    if (selectedRows.includes(id)) {
      setSelectedRows(selectedRows.filter(rowId => rowId !== id));
    } else {
      setSelectedRows([...selectedRows, id]);
    }
  };

  const getDifficultyColor = (difficulty) => {
    // If difficulty is null or undefined, return the default color
    if (difficulty === null || difficulty === undefined) {
      return 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    }

    // Handle numeric difficulty values - using the gray shades from the chart
    switch (difficulty) {
      case 1: // Easy
        return 'bg-[#EEEEEE] text-gray-800 dark:bg-gray-700 dark:text-gray-300';
      case 2: // Medium
        return 'bg-[#AAAAAA] text-white dark:bg-gray-600 dark:text-gray-200';
      case 3: // Hard
        return 'bg-[#666666] text-white dark:bg-gray-800 dark:text-gray-100';
      default:
        return 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    }
  };

  if (loading) {
    return (
      <div className="rounded-lg border bg-card p-8 text-center text-muted-foreground">
        Loading phrases...
      </div>
    );
  }

  return (
    <div className="rounded-lg border">
      {/* Table Header Controls */}
      <div className="p-4 border-b flex flex-wrap justify-between items-center gap-4">
        <div className="flex items-center gap-4">
          {/* Delete Selected Button - Shows only when rows are selected */}
          {selectedRows.length > 0 && (
            <Button 
              variant="destructive" 
              size="sm" 
              onClick={handleBulkDelete}
              className="flex items-center gap-1"
            >
              <Trash2 className="h-4 w-4" />
              Delete {selectedRows.length} selected
            </Button>
          )}
          
          {selectedRows.length === 0 && (
            <>
              {/* Rows per page selector */}
              <Select
                value={pagination.rowsPerPage.toString()}
                onValueChange={(value) => onRowsPerPageChange(Number(value))}
                defaultValue="20"
              >
                <SelectTrigger className="w-[120px]">
                  <SelectValue placeholder="20 per page" />
                </SelectTrigger>
                <SelectContent>
                  {[10, 20, 25, 50, 100].map(value => (
                    <SelectItem key={value} value={value.toString()}>
                      {value} per page
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              
              <span className="text-sm text-muted-foreground">
                {pagination.totalPages > 0
                  ? `Page ${pagination.currentPage} of ${pagination.totalPages}`
                  : 'No results'}
              </span>
            </>
          )}
        </div>

        <div className="flex gap-2">
          {/* Filter button - Hide when rows are selected */}
          {selectedRows.length === 0 && (
            <Button 
              variant="outline" 
              size="sm" 
              className="flex items-center gap-1"
              onClick={onShowFilters}
            >
              <Filter className="h-4 w-4" />
              Filters
            </Button>
          )}
          
          {/* Pagination Controls */}
          <div className="flex gap-2">
            <Button
              onClick={() => onPageChange(pagination.currentPage - 1)}
              disabled={pagination.currentPage === 1}
              variant="outline"
              size="sm"
            >
              Previous
            </Button>
            <Button
              onClick={() => onPageChange(pagination.currentPage + 1)}
              disabled={pagination.currentPage === pagination.totalPages}
              variant="outline"
              size="sm"
            >
              Next
            </Button>
          </div>
        </div>
      </div>

      {/* Table */}
      <div className="overflow-x-auto">
        <Table>
          <TableHeader>
            <TableRow>
              {/* Select All Checkbox */}
              <TableHead className="w-12">
                <Checkbox 
                  checked={phrases.length > 0 && selectedRows.length === phrases.length}
                  indeterminate={selectedRows.length > 0 && selectedRows.length < phrases.length}
                  onCheckedChange={toggleSelectAll}
                  aria-label="Select all"
                />
              </TableHead>
              
              {columnHeaders.map(({ key, label }) => (
                <TableHead 
                  key={key}
                  onClick={() => onSort(key)}
                  className="cursor-pointer"
                >
                  <div className="flex items-center gap-2">
                    {label}
                    {sortConfig.key === key && (
                      sortConfig.direction === 'asc' 
                        ? <ChevronUp className="w-4 h-4" />
                        : <ChevronDown className="w-4 h-4" />
                    )}
                  </div>
                </TableHead>
              ))}
              <TableHead className="w-10"></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {phrases.length === 0 ? (
              <TableRow>
                <TableCell 
                  colSpan={columnHeaders.length + 2} 
                  className="text-center h-24"
                >
                  No phrases found
                </TableCell>
              </TableRow>
            ) : (
              phrases.map((phrase, index) => (
                <TableRow 
                  key={phrase.id}
                  className={cn(
                    newIds.includes(phrase.id) ? 'animate-flash' : '',
                    selectedRows.includes(phrase.id) ? 'bg-muted' : ''
                  )}
                >
                  {/* Row Selection Checkbox */}
                  <TableCell className="w-12">
                    <Checkbox 
                      checked={selectedRows.includes(phrase.id)}
                      onCheckedChange={() => toggleRowSelection(phrase.id)}
                      aria-label={`Select row ${index}`}
                    />
                  </TableCell>
                  
                  <TableCell className="text-muted-foreground">{phrase.id}</TableCell>
                  <TableCell>{phrase.phrase}</TableCell>
                  <TableCell className="text-muted-foreground">{phrase.category}</TableCell>
                  <TableCell>
                    <span className={cn(
                      "px-2 py-1 rounded-full text-xs",
                      getDifficultyColor(phrase.difficulty)
                    )}>
                      {difficultyLabels[phrase.difficulty] || '-'}
                    </span>
                  </TableCell>
                  <TableCell>
                    <TagDisplay tags={phrase.tags} />
                  </TableCell>
                  <TableCell className="text-muted-foreground">{phrase.hint || '-'}</TableCell>
                  <TableCell>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" className="h-8 w-8 p-0">
                          <span className="sr-only">Open menu</span>
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuLabel>Actions</DropdownMenuLabel>
                        <DropdownMenuItem onClick={() => onEdit(phrase)}>
                          <Pencil className="mr-2 h-4 w-4" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem 
                          onClick={() => handleDelete(phrase.id)}
                          className="text-red-600"
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Bottom Pagination */}
      <div className="p-4 border-t flex justify-between items-center">
        <span className="text-sm text-muted-foreground">
          {`Showing ${phrases.length} of ${pagination.totalPages * pagination.rowsPerPage} phrases`}
          {selectedRows.length > 0 && ` â€¢ ${selectedRows.length} selected`}
        </span>
        <div className="flex gap-2">
          <Button
            onClick={() => onPageChange(pagination.currentPage - 1)}
            disabled={pagination.currentPage === 1}
            variant="outline"
            size="sm"
            className="rounded-md"
          >
            Previous
          </Button>
          <Button
            onClick={() => onPageChange(pagination.currentPage + 1)}
            disabled={pagination.currentPage === pagination.totalPages}
            variant="outline"
            size="sm"
            className="rounded-md"
          >
            Next
          </Button>
        </div>
      </div>
    </div>
  );
};

export default PhrasesTable;

============================================================

FILE: .\components\common\RowsPerPageSelect.tsx
SIZE: 1.11 KB
LAST MODIFIED: 02/09/2025 10:31:21

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';

interface RowsPerPageSelectProps {
  value: number;
  onChange: (value: number) => void;
  options?: number[];
  className?: string;
}

const RowsPerPageSelect: React.FC<RowsPerPageSelectProps> = ({
  value,
  onChange,
  options = [10, 25, 50, 100],
  className = ''
}) => {
  return (
    <div className={`flex items-center gap-2 ${className}`}>
      <span className="text-sm text-gray-400">
        Rows per page:
      </span>
      <Select
        value={value.toString()}
        onValueChange={(val) => onChange(Number(val))}
      >
        <SelectTrigger className="w-[100px] bg-gray-700 border-gray-600">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {options.map((option) => (
            <SelectItem 
              key={option} 
              value={option.toString()}
            >
              {option}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default RowsPerPageSelect;

============================================================

FILE: .\components\common\Select.tsx
SIZE: 0.9 KB
LAST MODIFIED: 03/05/2025 17:02:39

import React from "react";

interface SelectProps {
  value: string | number;
  onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
  options: Array<{ value: string | number; label: string }>;
  className?: string;
  placeholder?: string;
}

export const Select: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  className = "",
  placeholder,
}) => {
  return (
    <select
      value={value || "placeholder"} // Ensure value is not empty
      onChange={onChange}
      className={`p-2 border rounded-md bg-white dark:bg-gray-800 dark:border-gray-700 ${className}`}
    >
      {placeholder && (
        <option value="placeholder" disabled>
          {placeholder}
        </option>
      )}
      {options.map((option) => (
        <option key={option.value} value={option.value}>
          {option.label}
        </option>
      ))}
    </select>
  );
};


============================================================

FILE: .\components\common\StatCard.tsx
SIZE: 2.62 KB
LAST MODIFIED: 02/09/2025 15:30:45

import React from 'react';
import { useCountUp } from '@/hooks/useCountUp';
import { cn } from '@/lib/utils';

interface StatCardProps {
  title: string;
  value: number;
  prefix?: string;
  suffix?: string;
  change?: number;
  loading?: boolean;
  trend?: 'up' | 'down' | 'neutral';
  icon?: React.ReactNode;
  iconBackground?: string;
  description?: string;
  className?: string;
}

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  prefix = '',
  suffix = '',
  change,
  loading = false,
  trend,
  icon,
  iconBackground,
  description,
  className
}) => {
  const animatedValue = useCountUp(value, {
    duration: 2000
  });

  const trendColors = {
    up: 'text-green-500',
    down: 'text-red-500',
    neutral: 'text-gray-500'
  };

  if (loading) {
    return (
      <div className={cn(
        "bg-gray-800 p-6 rounded-lg shadow animate-pulse",
        className
      )}>
        <div className="h-4 bg-gray-700 rounded w-24 mb-3" />
        <div className="h-8 bg-gray-700 rounded w-32" />
      </div>
    );
  }

  return (
    <div className={cn(
      "bg-gray-800 p-6 rounded-lg shadow",
      className
    )}>
      <div className="flex justify-between">
        <div>
          <p className="text-sm font-medium text-gray-400">
            {title}
          </p>
          <div className="mt-2 flex items-baseline">
            {prefix && (
              <span className="text-xl font-semibold text-gray-300 mr-1">
                {prefix}
              </span>
            )}
            <span className="text-2xl font-bold text-white">
              {animatedValue.toLocaleString()}
            </span>
            {suffix && (
              <span className="text-xl font-semibold text-gray-300 ml-1">
                {suffix}
              </span>
            )}
          </div>
          {change !== undefined && (
            <p className={cn(
              "mt-2 flex items-center text-sm",
              trendColors[trend || 'neutral']
            )}>
              {trend === 'up' && 'â†‘'}
              {trend === 'down' && 'â†“'}
              {change > 0 && '+'}
              {change}%
            </p>
          )}
          {description && (
            <p className="mt-2 text-sm text-gray-400">
              {description}
            </p>
          )}
        </div>
        {icon && (
          <div className={cn(
            "rounded-lg p-3",
            iconBackground || 'bg-blue-500/10'
          )}>
            {icon}
          </div>
        )}
      </div>
    </div>
  );
};

export default StatCard;

============================================================

FILE: .\components\common\StatsSection.tsx
SIZE: 2.39 KB
LAST MODIFIED: 02/13/2025 12:32:44

import React from 'react';
import { useCountUp } from '@/hooks/useCountUp';
import type { StatsSectionProps } from '@/types/types';

interface StatCardProps {
  title: string;
  value: number;
  suffix?: string;
  delay?: number;
}

const StatCard: React.FC<StatCardProps> = ({ 
  title, 
  value, 
  suffix = '', 
  delay = 0 
}) => {
  const animatedValue = useCountUp(value, { 
    duration: 2000,
    delay 
  });

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow">
      <div className="text-2xl font-bold text-white">
        {animatedValue.toLocaleString()}{suffix}
      </div>
      <div className="text-gray-400">{title}</div>
    </div>
  );
};

const StatsSection: React.FC<StatsSectionProps> = ({ stats, loading }) => {
  if (loading) {
    return (
      <div className="grid grid-cols-2 md:grid-cols-5 gap-6 mb-8">
        {[...Array(5)].map((_, i) => (
          <div 
            key={i}
            className="bg-gray-800 p-6 rounded-lg shadow animate-pulse"
          >
            <div className="h-8 bg-gray-700 rounded w-24 mb-2" />
            <div className="h-4 bg-gray-700 rounded w-16" />
          </div>
        ))}
      </div>
    );
  }

  // Handle case where stats is null or undefined
  if (!stats) {
    return (
      <div className="grid grid-cols-2 md:grid-cols-5 gap-6 mb-8">
        <div className="bg-gray-800 p-6 rounded-lg shadow">
          <div className="text-2xl font-bold text-white">0</div>
          <div className="text-gray-400">No data available</div>
        </div>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-2 md:grid-cols-5 gap-6 mb-8">
      <StatCard
        title="Total Phrases"
        value={stats.total || 0}
        delay={0}
      />
      <StatCard
        title="Unique Categories"
        value={stats.uniqueCategories || 0}
        delay={100}
      />
      <StatCard
        title="Easy Phrases"
        value={stats.difficultyBreakdown?.easy || 0}
        suffix="%"
        delay={200}
      />
      <StatCard
        title="Medium Phrases"
        value={stats.difficultyBreakdown?.medium || 0}
        suffix="%"
        delay={300}
      />
      <StatCard
        title="Hard Phrases"
        value={stats.difficultyBreakdown?.hard || 0}
        suffix="%"
        delay={400}
      />
    </div>
  );
};

export default StatsSection;

============================================================

FILE: .\components\common\TagDisplay.tsx
SIZE: 1.03 KB
LAST MODIFIED: 03/11/2025 21:48:59

import React from 'react';
import { cn } from '@/lib/utils';

interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
  className?: string;
}

const TagDisplay: React.FC<TagDisplayProps> = ({ 
  tags, 
  onClick,
  className
}) => {
  if (!tags) return null;
  
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  if (tagArray.length === 0) return null;
  
  return (
    <div className={cn("flex flex-wrap gap-1", className)}>
      {tagArray.map((tag, idx) => (
        <button
          key={`${tag}-${idx}`}
          onClick={() => onClick?.(tag)}
          className={cn(
            "px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300",
            onClick ? "hover:bg-gray-200 dark:hover:bg-gray-600 cursor-pointer" : "cursor-default",
            "transition-colors duration-150",
            className
          )}
        >
          {tag}
        </button>
      ))}
    </div>
  );
};

export default TagDisplay;

============================================================

FILE: .\components\dashboard\AnalyticsCharts.tsx
SIZE: 7.18 KB
LAST MODIFIED: 03/09/2025 21:52:46

// src/components/dashboard/AnalyticsCharts.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { 
  BarChart, Bar, PieChart, Pie, RadialBarChart, RadialBar, XAxis, YAxis, CartesianGrid, 
  Tooltip, ResponsiveContainer, Cell, Legend, PolarGrid, PolarRadiusAxis
} from 'recharts';

interface AnalyticsChartsProps {
  monthlyActivityData: any[];
  categoryData: any[];
  wordsAddedData: any[];
}

export const AnalyticsCharts: React.FC<AnalyticsChartsProps> = ({ 
  monthlyActivityData, categoryData, wordsAddedData 
}) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {/* Monthly Activity */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Monthly Activity</CardTitle>
          <CardDescription>Reviews, additions and edits over time</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={monthlyActivityData} margin={{ top: 10, right: 10, left: 0, bottom: 20 }}>
                <CartesianGrid vertical={false} stroke="#3F3F46" strokeDasharray="3 3" />
                <XAxis dataKey="name" tick={{ fill: "white" }} tickLine={{ stroke: "#3F3F46" }} axisLine={{ stroke: "#3F3F46" }} />
                <YAxis tick={{ fill: "white" }} tickLine={{ stroke: "#3F3F46" }} axisLine={{ stroke: "#3F3F46" }} />
                <Tooltip contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', borderRadius: '0.5rem' }} />
                <Legend wrapperStyle={{ paddingTop: 20 }} />
                <Bar dataKey="reviews" fill="#71717A" />
                <Bar dataKey="additions" fill="#3F3F46" />
                <Bar dataKey="edits" fill="#18181B" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Category Distribution */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Category Distribution</CardTitle>
          <CardDescription>Phrases by category</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={categoryData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={90}
                  paddingAngle={2}
                  dataKey="value"
                  label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                >
                  <Cell fill="#D4D4D8" />
                  <Cell fill="#A1A1AA" />
                  <Cell fill="#71717A" />
                  <Cell fill="#3F3F46" />
                  <Cell fill="#18181B" />
                </Pie>
                <Tooltip contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', borderRadius: '0.5rem' }} />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      
      {/* Top Reviewers Performance */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Top Reviewers Performance</CardTitle>
          <CardDescription>Reviews and streaks by contributor</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                layout="vertical"
                data={[
                  { name: "Kari", reviews: 120, streak: 14 },
                  { name: "Sarah", reviews: 85, streak: 7 },
                  { name: "Justin", reviews: 65, streak: 5 },
                  { name: "Alex", reviews: 45, streak: 3 },
                  { name: "Morgan", reviews: 30, streak: 2 }
                ]}
                margin={{ top: 20, right: 30, left: 60, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#3F3F46" />
                <XAxis 
                  type="number"
                  tick={{ fill: "white" }}
                  tickLine={{ stroke: "#3F3F46" }}
                  axisLine={{ stroke: "#3F3F46" }}
                />
                <YAxis 
                  dataKey="name" 
                  type="category"
                  tick={{ fill: "white" }}
                  tickLine={{ stroke: "#3F3F46" }}
                  axisLine={{ stroke: "#3F3F46" }}
                />
                <Tooltip
                  contentStyle={{ 
                    backgroundColor: '#27272A', 
                    borderColor: '#3F3F46',
                    color: 'white',
                    borderRadius: '0.5rem' 
                  }}
                />
                <Legend />
                <Bar dataKey="reviews" fill="#71717A" />
                <Bar dataKey="streak" fill="#18181B" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Words Added This Month */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Words Added This Month</CardTitle>
          <CardDescription>Progress towards the goal of 100 words</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <RadialBarChart
                data={wordsAddedData}
                innerRadius="80%"
                outerRadius="100%"
                startAngle={180}
                endAngle={0}
              >
                <PolarGrid stroke="hsl(var(--muted))" />
                <PolarRadiusAxis angle={30} domain={[0, 100]} tick={false} />
                <RadialBar
                  dataKey="value"
                  cornerRadius={10}
                  background
                  fill="hsl(var(--primary))"
                />
                <text
                  x="50%"
                  y="50%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground text-2xl font-bold"
                >
                  {wordsAddedData[0].value} / 100
                </text>
              </RadialBarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
        <CardFooter>
          <div className="w-full flex justify-between items-center">
            <div className="text-sm text-muted-foreground">
              Goal: <span className="font-bold text-white">100 words</span>
            </div>
            <div className="text-sm text-muted-foreground">
              Remaining: <span className="font-bold text-white">{100 - wordsAddedData[0].value}</span>
            </div>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
};

============================================================

FILE: .\components\dashboard\DashboardHeader.tsx
SIZE: 1.63 KB
LAST MODIFIED: 03/09/2025 21:52:53

// src/components/dashboard/DashboardHeader.tsx
import React from 'react';
import { Button } from "@/components/ui/button";
import { Sun, Moon, FileDownIcon } from "lucide-react";

interface DashboardHeaderProps {
  theme: string;
  setTheme: (theme: string) => void;
  onReviewClick: () => void;
  onExportClick: () => void;
  onLoginClick: () => void;
}

export const DashboardHeader: React.FC<DashboardHeaderProps> = ({ 
  theme, 
  setTheme, 
  onReviewClick, 
  onExportClick, 
  onLoginClick 
}) => {
  return (
    <div className="flex justify-between items-center">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground">Manage your catch phrases</p>
      </div>

      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="icon"
          onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
          className="h-9 w-9 rounded-md"
        >
          {theme === 'dark' ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />}
        </Button>

        <Button 
          variant="outline" 
          className="rounded-md"
          onClick={onReviewClick}
        >
          Review Words
        </Button>

        <Button 
          variant="outline" 
          className="rounded-md"
          onClick={onExportClick}
        >
          <FileDownIcon className="mr-2 h-4 w-4" />
          Export
        </Button>

        <Button 
          variant="outline" 
          className="rounded-md bg-white text-black"
          onClick={onLoginClick}
        >
          Login
        </Button>
      </div>
    </div>
  );
};

============================================================

FILE: .\components\dashboard\DashboardView.tsx
SIZE: 12.41 KB
LAST MODIFIED: 03/10/2025 14:56:25

// components/ImprovedDashboard/index.tsx
'use client'

import React, { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';
import { LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { Clock, Users, FileText, Award, ChevronDown } from 'lucide-react';
import { Button } from '@/components/ui/button';
import FilterControls from '@/components/common/FilterControls';
import PhrasesTable from '@/components/common/PhrasesTable';
import BulkImportForm from '@/components/shared/BulkImportForm';
import Login from '@/components/common/Login';
import { useStats } from '@/hooks/useStats';
import { usePhrases } from '@/hooks/usePhrases';
import { usePhraseMetadata } from '@/hooks/usePhraseMetadata';
import { cn } from '@/lib/utils';

const ImprovedDashboard = () => {
  // Auth state
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [session, setSession] = useState(null);
  const [bulkImportVisible, setBulkImportVisible] = useState(false);
  const [filtersVisible, setFiltersVisible] = useState(false);
  const [topReviewers, setTopReviewers] = useState([]);
  const [greeting, setGreeting] = useState('');

  // Initialize hooks
  const { stats, loading: statsLoading } = useStats();
  const {
    phrases,
    loading: phrasesLoading,
    error,
    setError,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    editPhrase,
    deletePhrase,
    fetchPhrases,
    resetFilters,
  } = usePhrases();

  const { 
    categories, 
    difficulties, 
    partsOfSpeech
  } = usePhraseMetadata();

  // Set greeting based on time of day
  useEffect(() => {
    const hour = new Date().getHours();
    let newGreeting = '';
    
    if (hour < 12) {
      newGreeting = 'Good morning';
    } else if (hour < 18) {
      newGreeting = 'Good afternoon';
    } else {
      newGreeting = 'Good evening';
    }
    
    setGreeting(newGreeting);
  }, []);

  // Fetch top reviewers
  useEffect(() => {
    const fetchTopReviewers = async () => {
      try {
        const { data, error } = await supabase
          .from('reviewers')
          .select('*')
          .order('total_reviews', { ascending: false })
          .limit(3);
          
        if (error) throw error;
        setTopReviewers(data || []);
      } catch (err) {
        console.error('Error fetching top reviewers:', err);
      }
    };

    fetchTopReviewers();
  }, []);

  // Initialize Auth
  useEffect(() => {
    const initializeAuth = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setSession(session);
    };

    initializeAuth();

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        setSession(session);
        if (session) {
          setShowLoginModal(false);
        }
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  // Generate sample data for charts
  const generateActivityData = () => {
    const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    return daysOfWeek.map(day => ({
      name: day,
      reviews: Math.floor(Math.random() * 20) + 5,
      newPhrases: Math.floor(Math.random() * 10) + 1,
    }));
  };

  const activityData = generateActivityData();

  // Simple formatter for numbers
  const formatNumber = (num) => {
    return new Intl.NumberFormat().format(num);
  };

  const handleBulkImportSuccess = (importedIds = []) => {
    fetchPhrases();
    setBulkImportVisible(false);
    setError(null);
  };

  const handleBulkImportError = (errorMessage) => {
    setError(errorMessage);
  };

  const StatCard = ({ title, value, icon, colorClass, subtitle }) => (
    <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
      <div className="flex justify-between items-start">
        <div>
          <p className="text-sm font-medium text-gray-400">{title}</p>
          <div className="mt-2 flex items-baseline">
            <span className="text-2xl font-bold text-white">{formatNumber(value)}</span>
          </div>
          {subtitle && <p className="mt-1 text-sm text-gray-400">{subtitle}</p>}
        </div>
        <div className={cn("rounded-lg p-3", colorClass)}>
          {icon}
        </div>
      </div>
    </div>
  );

  const goToReviewPage = () => {
    window.location.href = '/review';
  };

  // Render dashboard
  return (
    <div className="min-h-screen bg-gray-900 text-white p-4 lg:p-8">
      {/* Login Modal */}
      {showLoginModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full">
            <Login onClose={() => setShowLoginModal(false)} />
          </div>
        </div>
      )}

      {/* Header */}
      <div className="max-w-[1920px] mx-auto">
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold">Admin Dashboard</h1>
            <p className="text-gray-400 mt-1">{greeting}, {session?.user?.email || 'welcome back'}</p>
          </div>
          <div className="flex gap-4">
            <Button 
              onClick={goToReviewPage}
              className="bg-purple-600 hover:bg-purple-700"
            >
              Review Words
            </Button>
            {!session ? (
              <Button
                onClick={() => setShowLoginModal(true)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                Login
              </Button>
            ) : (
              <Button
                onClick={() => supabase.auth.signOut()}
                variant="destructive"
                className="hover:bg-red-700"
              >
                Logout
              </Button>
            )}
          </div>
        </div>

        {/* Stats Section */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
          <StatCard 
            title="Total Phrases" 
            value={stats?.total || 0} 
            icon={<FileText className="h-6 w-6 text-blue-400" />}
            colorClass="bg-blue-500/10"
            subtitle="Catch phrases in database"
          />
          <StatCard 
            title="Categories" 
            value={stats?.uniqueCategories || 0} 
            icon={<ChevronDown className="h-6 w-6 text-green-400" />}
            colorClass="bg-green-500/10"
            subtitle="Different word categories"
          />
          <StatCard 
            title="Reviewers" 
            value={topReviewers.length || 0} 
            icon={<Users className="h-6 w-6 text-purple-400" />}
            colorClass="bg-purple-500/10"
            subtitle="Active content reviewers"
          />
          <StatCard 
            title="Top Contributor" 
            value={topReviewers[0]?.total_reviews || 0} 
            icon={<Award className="h-6 w-6 text-yellow-400" />}
            colorClass="bg-yellow-500/10"
            subtitle={topReviewers[0]?.name || 'No reviewers yet'}
          />
        </div>

        {/* Charts Section */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
          <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
            <h2 className="text-xl font-bold mb-4">Weekly Activity</h2>
            <ResponsiveContainer width="100%" height={250}>
              <BarChart data={activityData}>
                <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                <XAxis dataKey="name" stroke="#9CA3AF" />
                <YAxis stroke="#9CA3AF" />
                <Tooltip 
                  contentStyle={{ backgroundColor: '#1F2937', border: 'none', borderRadius: '0.5rem' }}
                  itemStyle={{ color: '#F3F4F6' }}
                />
                <Legend />
                <Bar dataKey="reviews" fill="#8884d8" name="Reviews" />
                <Bar dataKey="newPhrases" fill="#82ca9d" name="New Phrases" />
              </BarChart>
            </ResponsiveContainer>
          </div>

          <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
            <h2 className="text-xl font-bold mb-4">Difficulty Distribution</h2>
            <ResponsiveContainer width="100%" height={250}>
              <BarChart layout="vertical" data={[
                { name: 'Easy', value: stats?.difficultyBreakdown?.easy || 0 },
                { name: 'Medium', value: stats?.difficultyBreakdown?.medium || 0 },
                { name: 'Hard', value: stats?.difficultyBreakdown?.hard || 0 }
              ]}>
                <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                <XAxis type="number" stroke="#9CA3AF" />
                <YAxis dataKey="name" type="category" stroke="#9CA3AF" />
                <Tooltip 
                  contentStyle={{ backgroundColor: '#1F2937', border: 'none', borderRadius: '0.5rem' }}
                  itemStyle={{ color: '#F3F4F6' }}
                />
                <Bar dataKey="value" fill="#10B981" name="Percentage" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Top Contributors */}
        <div className="mb-8">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold">Top Contributors</h2>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            {topReviewers.map((reviewer, index) => (
              <div key={reviewer.id} className="bg-gray-800 p-6 rounded-lg shadow-lg">
                <div className="flex items-center gap-4">
                  <div className="text-4xl">
                    {['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][index]}
                  </div>
                  <div>
                    <h3 className="text-lg font-bold">{reviewer.name}</h3>
                    <p className="text-gray-400">{reviewer.total_reviews} reviews</p>
                    <div className="mt-2 flex items-center gap-2">
                      {reviewer.current_streak > 0 && (
                        <span className="bg-orange-900/30 text-orange-400 text-xs px-2 py-1 rounded-full">
                          ðŸ”¥ {reviewer.current_streak} day streak
                        </span>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-between items-center mb-4">
          <div className="flex gap-4">
            <Button
              onClick={() => setFiltersVisible(!filtersVisible)}
              variant="outline"
            >
              {filtersVisible ? 'Hide Filters' : 'Show Filters'}
            </Button>
            <Button
              onClick={() => setBulkImportVisible(!bulkImportVisible)}
              variant="outline"
            >
              {bulkImportVisible ? 'Hide Bulk Import' : 'Bulk Import'}
            </Button>
          </div>
        </div>

        {/* Filters Section (Conditionally Rendered) */}
        {filtersVisible && (
          <FilterControls
            filters={filters}
            onChange={handleFilterChange}
            onReset={resetFilters}
            categories={categories}
            difficulties={difficulties}
            partsOfSpeech={partsOfSpeech}
          />
        )}

        {/* Bulk Import Form (Conditionally Rendered) */}
        {bulkImportVisible && (
          <div className="mb-8">
            <BulkImportForm
              onSuccess={handleBulkImportSuccess}
              onError={handleBulkImportError}
            />
          </div>
        )}

        {/* Phrases Table */}
        <PhrasesTable
          phrases={phrases}
          loading={phrasesLoading}
          sortConfig={sortConfig}
          pagination={pagination}
          onSort={handleSort}
          onEdit={editPhrase}
          onDelete={deletePhrase}
          onPageChange={handlePageChange}
          onRowsPerPageChange={handleRowsPerPageChange}
          onShowCardView={() => {}}
          newIds={[]}
        />
      </div>
    </div>
  );
};

export default ImprovedDashboard;


============================================================

FILE: .\components\dashboard\PhraseSearch.tsx
SIZE: 0.56 KB
LAST MODIFIED: 03/09/2025 21:46:08

import React from 'react';
import { DataTableFilters } from '@/components/tables/data-table/filters';
import { TableState } from '@/components/tables/types';

interface PhraseSearchProps {
  tableState: TableState;
  onTableStateChange: (state: Partial<TableState>) => void;
}

export const PhraseSearch: React.FC<PhraseSearchProps> = ({ 
  tableState, onTableStateChange 
}) => {
  return (
    <div className="px-2">
      <DataTableFilters
        tableState={tableState}
        onTableStateChange={onTableStateChange}
      />
    </div>
  );
};


============================================================

FILE: .\components\dashboard\StatsCards.tsx
SIZE: 6.66 KB
LAST MODIFIED: 03/09/2025 21:52:34

// src/components/dashboard/StatsCards.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { LineChart, Line, PieChart, Pie, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell } from 'recharts';
import { TrendingUp } from "lucide-react";

interface StatsCardsProps {
  phrasesOverTime: any[];
  stats: any;
  reviewers: any[];
}

export const StatsCards: React.FC<StatsCardsProps> = ({ phrasesOverTime, stats, reviewers }) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      {/* Total Phrases Chart */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Total Phrases</CardTitle>
          <CardDescription>Growth trend over time</CardDescription>
        </CardHeader>
        <CardContent className="pb-0">
          <div className="h-[120px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={phrasesOverTime} margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
                <CartesianGrid stroke="#3F3F46" strokeDasharray="3 3" opacity={0.3} />
                <XAxis dataKey="month" tick={{ fill: 'white', fontSize: 10 }} axisLine={{ stroke: '#3F3F46' }} tickLine={{ stroke: '#3F3F46' }} />
                <YAxis tick={{ fill: 'white', fontSize: 10 }} axisLine={{ stroke: '#3F3F46' }} tickLine={{ stroke: '#3F3F46' }} />
                <Tooltip 
                  contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', fontSize: '12px' }} 
                  labelStyle={{ fontWeight: 'bold' }}
                  formatter={(value) => value === null ? 'N/A' : value} 
                />
                <Line 
                  type="monotone" 
                  dataKey="phrases" 
                  stroke="#8884d8" 
                  strokeWidth={2}
                  dot={{ fill: '#8884d8', r: 4 }}
                  activeDot={{ r: 6, fill: '#8884d8' }}
                  isAnimationActive={false}
                />
                
                {/* Add text overlay when data is null/error state */}
                {phrasesOverTime[0]?.phrases === null && (
                  <text
                    x="50%"
                    y="50%"
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fill="#FF6B6B"
                    fontSize="14px"
                    fontWeight="bold"
                  >
                    No Data Available
                  </text>
                )}
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
        <CardFooter>
          <div className="flex w-full items-start gap-2 text-sm">
            <div className="grid gap-0">
              <div className="flex items-center gap-1 font-medium text-lg">
                {stats?.total || 1392} total phrases <TrendingUp className="h-4 w-4 ml-1 text-green-500" />
              </div>
              <div className="flex items-center gap-2 text-xs text-muted-foreground">
                Last 6 months
              </div>
            </div>
          </div>
        </CardFooter>
      </Card>

      {/* Difficulty Radar Chart */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Difficulty Distribution</CardTitle>
          <CardDescription>Distribution by difficulty level</CardDescription>
        </CardHeader>
        <CardContent className="pb-0">
          <div className="h-[120px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={[
                    { name: 'Easy', value: stats?.difficultyBreakdown?.easy || 30 },
                    { name: 'Medium', value: stats?.difficultyBreakdown?.medium || 20 },
                    { name: 'Hard', value: stats?.difficultyBreakdown?.hard || 10 },
                  ]}
                  cx="50%"
                  cy="50%"
                  innerRadius={25}
                  outerRadius={45}
                  paddingAngle={2}
                  dataKey="value"
                  label={({ name }) => name}
                >
                  <Cell fill="#D4D4D8" />
                  <Cell fill="#A1A1AA" />
                  <Cell fill="#71717A" />
                </Pie>
                <Tooltip contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', borderRadius: '0.5rem', fontSize: '12px' }} />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
        <CardFooter className="pt-3">
          <div className="flex w-full items-center gap-4 text-sm justify-around">
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded-full" style={{ backgroundColor: "#D4D4D8" }}></div>
              <span className="text-xs">Easy</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded-full" style={{ backgroundColor: "#A1A1AA" }}></div>
              <span className="text-xs">Medium</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded-full" style={{ backgroundColor: "#71717A" }}></div>
              <span className="text-xs">Hard</span>
            </div>
          </div>
        </CardFooter>
      </Card>

      {/* Top Reviewers */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Top Reviewers</CardTitle>
          <CardDescription>Most active contributors</CardDescription>
        </CardHeader>
        <CardContent className="p-2 pb-4">
          <div className="space-y-2 mt-2">
            {reviewers?.slice(0, 3).map((reviewer, index) => (
              <div key={index} className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <div className="w-8 h-8 rounded-full bg-zinc-700 flex items-center justify-center text-xs">
                    {reviewer.name.charAt(0).toUpperCase()}
                  </div>
                  <span className="text-sm font-medium">{reviewer.name}</span>
                </div>
                <div className="flex items-center">
                  <span className="text-sm font-bold">{reviewer.total_reviews || index === 0 ? 4 : index === 1 ? 1 : 0}</span>
                  <span className="text-xs text-muted-foreground ml-1">reviews</span>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

============================================================

FILE: .\components\phrases\phrases-table\actions.tsx
SIZE: 1.99 KB
LAST MODIFIED: 03/09/2025 15:22:18

// src/components/phrases/phrases-table/actions.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { Trash2, Pencil, MoreHorizontal } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Phrase } from './columns';

interface RowActionsProps {
  phrase: Phrase;
  onEdit: (phrase: Phrase) => void;
  onDelete: (id: string | number) => void;
}

export function PhraseRowActions({ phrase, onEdit, onDelete }: RowActionsProps) {
  const handleDelete = () => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      onDelete(phrase.id);
    }
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="h-8 w-8 p-0">
          <span className="sr-only">Open menu</span>
          <MoreHorizontal className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuLabel>Actions</DropdownMenuLabel>
        <DropdownMenuItem onClick={() => onEdit(phrase)}>
          <Pencil className="mr-2 h-4 w-4" />
          Edit
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem 
          onClick={handleDelete}
          className="text-red-600"
        >
          <Trash2 className="mr-2 h-4 w-4" />
          Delete
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

interface BulkActionsProps {
  selectedCount: number;
  onDelete: () => void;
}

export function PhraseBulkActions({ selectedCount, onDelete }: BulkActionsProps) {
  return (
    <Button 
      variant="destructive" 
      size="sm" 
      onClick={onDelete}
      className="flex items-center gap-1"
    >
      <Trash2 className="h-4 w-4" />
      Delete {selectedCount} selected
    </Button>
  );
}

============================================================

FILE: .\components\phrases\phrases-table\columns.tsx
SIZE: 3.86 KB
LAST MODIFIED: 03/09/2025 15:21:54

// src/components/phrases/phrases-table/columns.tsx
import React from 'react';
import { cn } from '@/lib/utils';
import TagDisplay from '@/components/common/TagDisplay';
import { ColumnDef } from '@/components/tables/types';
import { ChevronUp, ChevronDown } from 'lucide-react';

// Define the Phrase type
export interface Phrase {
  id: number | string;
  phrase: string;
  category: string;
  difficulty: number;
  tags: string[];
  hint?: string;
  [key: string]: any;
}

// Difficulty label mapping
export const difficultyLabels: Record<number, string> = {
  1: 'Easy',
  2: 'Medium',
  3: 'Hard',
};

// Function to get the appropriate color for difficulty level
export const getDifficultyColor = (difficulty: number | null | undefined): string => {
  if (difficulty === null || difficulty === undefined) {
    return 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
  }

  switch (difficulty) {
    case 1: // Easy
      return 'bg-[#EEEEEE] text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    case 2: // Medium
      return 'bg-[#AAAAAA] text-white dark:bg-gray-600 dark:text-gray-200';
    case 3: // Hard
      return 'bg-[#666666] text-white dark:bg-gray-800 dark:text-gray-100';
    default:
      return 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
  }
};

// Define column configuration for phrases
export const getPhrasesColumns = (sortConfig: { key: string; direction: 'asc' | 'desc' }): ColumnDef<Phrase>[] => [
  { 
    key: 'id', 
    header: (
      <div className="flex items-center gap-2">
        ID
        {sortConfig.key === 'id' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cellClassName: 'text-muted-foreground'
  },
  { 
    key: 'phrase', 
    header: (
      <div className="flex items-center gap-2">
        Phrase
        {sortConfig.key === 'phrase' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
  },
  { 
    key: 'category', 
    header: (
      <div className="flex items-center gap-2">
        Category
        {sortConfig.key === 'category' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cellClassName: 'text-muted-foreground'
  },
  { 
    key: 'difficulty', 
    header: (
      <div className="flex items-center gap-2">
        Difficulty
        {sortConfig.key === 'difficulty' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cell: (row) => (
      <span className={cn(
        "px-2 py-1 rounded-full text-xs",
        getDifficultyColor(row.difficulty)
      )}>
        {difficultyLabels[row.difficulty] || '-'}
      </span>
    )
  },
  { 
    key: 'tags', 
    header: (
      <div className="flex items-center gap-2">
        Tags
        {sortConfig.key === 'tags' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cell: (row) => <TagDisplay tags={row.tags} />
  },
  { 
    key: 'hint', 
    header: (
      <div className="flex items-center gap-2">
        Hint
        {sortConfig.key === 'hint' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cellClassName: 'text-muted-foreground',
    cell: (row) => row.hint || '-'
  },
];

============================================================

FILE: .\components\phrases\phrases-table\index.tsx
SIZE: 17.89 KB
LAST MODIFIED: 03/11/2025 22:04:44

import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import { Search, Columns, Pencil, Trash, ChevronLeft, ChevronRight, MoreHorizontal, X } from 'lucide-react';
import { TableState } from '@/components/tables/types';
import TagDisplay from '@/components/common/TagDisplay';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuCheckboxItem,
} from "@/components/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Check } from 'lucide-react';
import { cn } from '@/lib/utils';
import { supabase } from '@/lib/services/supabase';

interface PhrasesTableProps {
  phrases: any[];
  loading?: boolean;
  tableState: TableState;
  onTableStateChange: (updates: Partial<TableState>) => void;
  onEdit?: (id: number) => void;
  onDelete?: (id: number) => void;
  newIds?: number[];
  onShowFilters?: () => void;
}

export function PhrasesTable({
  phrases,
  loading = false,
  tableState,
  onTableStateChange,
  onEdit,
  onDelete,
  newIds = [],
  onShowFilters
}: PhrasesTableProps) {
  const [selectedRows, setSelectedRows] = useState<number[]>([]);
  const [searchValue, setSearchValue] = useState(tableState.filters.search || '');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  // Columns configuration for dropdown
  const columns = [
    { key: 'phrase', label: 'Phrase' },
    { key: 'category', label: 'Category' },
    { key: 'hint', label: 'Hint' }, // Moved hint to be after category
    { key: 'tags', label: 'Tags' },
    { key: 'difficulty', label: 'Difficulty' },
    { key: 'reviewed', label: 'Reviewed' }
  ];

  // Current visible columns
  const [hiddenColumns, setHiddenColumns] = useState<string[]>([]);

  // Handle search input changes
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchValue(e.target.value);
  };

  // Global search across the entire database - Only search phrase column
  const performGlobalSearch = async () => {
    if (!searchValue.trim()) {
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: ''
        }
      });
      return;
    }

    setIsSearching(true);
    try {
      const searchTerm = searchValue.toLowerCase().trim();
      
      // Search only the phrase column
      const { data, error } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(name),
          subcategories:subcategory_id(name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `)
        .ilike('phrase', `%${searchTerm}%`); // Only search in phrase column

      if (error) throw error;

      const transformedData = (data || []).map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      // Update search results and pagination
      setSearchResults(transformedData);
      
      // Update filter state
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: searchValue
        },
        pagination: {
          ...tableState.pagination,
          currentPage: 1,
          totalItems: transformedData.length,
          totalPages: Math.ceil(transformedData.length / tableState.pagination.rowsPerPage)
        }
      });
    } catch (err) {
      console.error('Error searching phrases:', err);
    } finally {
      setIsSearching(false);
    }
  };

  // Handle enter key
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      performGlobalSearch();
    }
  };

  // Clear search
  const clearSearch = () => {
    setSearchValue('');
    setSearchResults([]);
    onTableStateChange({
      filters: {
        ...tableState.filters,
        search: ''
      }
    });
  };

  const handleRowsPerPageChange = (value: string) => {
    const newRowsPerPage = parseInt(value, 10);
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        rowsPerPage: newRowsPerPage,
        currentPage: 1
      }
    });
  };

  const handlePageChange = (newPage: number) => {
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        currentPage: newPage
      }
    });
  };

  const handleSort = (key: string) => {
    onTableStateChange({
      sortConfig: {
        key,
        direction: 
          tableState.sortConfig.key === key && 
          tableState.sortConfig.direction === 'asc' ? 'desc' : 'asc'
      }
    });
  };

  const toggleSelectAll = () => {
    if (selectedRows.length === phrases.length) {
      setSelectedRows([]);
    } else {
      setSelectedRows(phrases.map(phrase => phrase.id));
    }
  };

  const toggleRowSelection = (id: number) => {
    if (selectedRows.includes(id)) {
      setSelectedRows(prev => prev.filter(rowId => rowId !== id));
    } else {
      setSelectedRows(prev => [...prev, id]);
    }
  };

  const handleBulkDelete = async () => {
    if (selectedRows.length > 0 && window.confirm(`Are you sure you want to delete ${selectedRows.length} phrases?`)) {
      for (const id of selectedRows) {
        await onDelete?.(id);
      }
      setSelectedRows([]);
    }
  };

  // Helper function to get difficulty bar color and width
  const getDifficultyBar = (difficulty: number) => {
    const colorClass = 
      difficulty === 1 ? 'bg-green-500' : 
      difficulty === 2 ? 'bg-yellow-500' : 
      difficulty === 3 ? 'bg-red-500' : 'bg-gray-400';
    
    const width = 
      difficulty === 1 ? 'w-1/3' : 
      difficulty === 2 ? 'w-2/3' : 
      difficulty === 3 ? 'w-full' : 'w-0';
    
    return (
      <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-600">
        <div className={`${colorClass} ${width} h-2.5 rounded-full`}></div>
      </div>
    );
  };

  // Determine which data to show
  const displayData = searchValue && searchResults.length > 0 ? searchResults : phrases;

  // Apply pagination to the display data
  const startIndex = (tableState.pagination.currentPage - 1) * tableState.pagination.rowsPerPage;
  const endIndex = startIndex + tableState.pagination.rowsPerPage;
  const paginatedData = displayData.slice(startIndex, endIndex);

  return (
    <div className="space-y-2">
      {/* Top toolbar with pagination and search */}
      <div className="flex flex-wrap items-center justify-between pb-4">
        <div className="flex items-center gap-4">
          {/* Rows per page dropdown */}
          <Select
            value={tableState.pagination.rowsPerPage.toString()}
            onValueChange={handleRowsPerPageChange}
          >
            <SelectTrigger className="w-[120px]">
              <SelectValue placeholder={`${tableState.pagination.rowsPerPage} per page`} />
            </SelectTrigger>
            <SelectContent>
              {[10, 20, 25, 50, 100].map(value => (
                <SelectItem key={value} value={value.toString()}>
                  {value} per page
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          
          {/* Page info */}
          <span className="text-sm text-muted-foreground">
            {tableState.pagination.totalPages > 0
              ? `Page ${tableState.pagination.currentPage} of ${tableState.pagination.totalPages}`
              : 'No results'}
          </span>
        </div>

        <div className="flex items-center gap-2">
          {/* Search input */}
          <div className="relative w-full md:w-64">
            <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
              <Search className="h-4 w-4 text-muted-foreground" />
            </div>
            <Input
              placeholder="Search phrases..."
              value={searchValue}
              onChange={handleSearchChange}
              onKeyDown={handleKeyDown}
              onBlur={performGlobalSearch}
              className="pl-10 pr-10"
            />
            {searchValue && (
              <button
                onClick={clearSearch}
                className="absolute inset-y-0 right-0 flex items-center pr-3 text-muted-foreground hover:text-foreground"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
          
          {/* Column visibility */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-9">
                <Columns className="mr-2 h-4 w-4" />
                Columns
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {columns.map((column) => (
                <DropdownMenuCheckboxItem
                  key={column.key}
                  checked={!hiddenColumns.includes(column.key)}
                  onCheckedChange={(checked) => {
                    setHiddenColumns(prev => 
                      checked 
                        ? prev.filter(key => key !== column.key)
                        : [...prev, column.key]
                    );
                  }}
                >
                  {column.label}
                </DropdownMenuCheckboxItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
          
          {/* Pagination buttons */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(tableState.pagination.currentPage - 1)}
            disabled={tableState.pagination.currentPage <= 1}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(tableState.pagination.currentPage + 1)}
            disabled={tableState.pagination.currentPage >= tableState.pagination.totalPages}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Main table */}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              {/* Checkbox column */}
              <TableHead className="w-12">
                <Checkbox
                  checked={selectedRows.length > 0 && selectedRows.length === paginatedData.length}
                  indeterminate={selectedRows.length > 0 && selectedRows.length < paginatedData.length}
                  onCheckedChange={toggleSelectAll}
                />
              </TableHead>
              
              {/* Phrase column */}
              {!hiddenColumns.includes('phrase') && (
                <TableHead onClick={() => handleSort('phrase')} className="cursor-pointer">
                  Phrase
                </TableHead>
              )}
              
              {/* Category column */}
              {!hiddenColumns.includes('category') && (
                <TableHead onClick={() => handleSort('category')} className="cursor-pointer">
                  Category
                </TableHead>
              )}
              
              {/* Hint column - Moved here */}
              {!hiddenColumns.includes('hint') && (
                <TableHead onClick={() => handleSort('hint')} className="cursor-pointer">
                  Hint
                </TableHead>
              )}
              
              {/* Tags column */}
              {!hiddenColumns.includes('tags') && (
                <TableHead onClick={() => handleSort('tags')} className="cursor-pointer">
                  Tags
                </TableHead>
              )}
              
              {/* Difficulty column */}
              {!hiddenColumns.includes('difficulty') && (
                <TableHead onClick={() => handleSort('difficulty')} className="cursor-pointer">
                  Difficulty
                </TableHead>
              )}
              
              {/* Reviewed column */}
              {!hiddenColumns.includes('reviewed') && (
                <TableHead>Reviewed</TableHead>
              )}
              
              {/* Actions column */}
              <TableHead className="w-[80px]">
                {selectedRows.length > 0 ? (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={handleBulkDelete}
                    className="h-8"
                  >
                    <Trash className="h-4 w-4 mr-2" />
                    Delete
                  </Button>
                ) : null}
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading || isSearching ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  {isSearching ? 'Searching...' : 'Loading...'}
                </TableCell>
              </TableRow>
            ) : paginatedData.length === 0 ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  No phrases found.
                </TableCell>
              </TableRow>
            ) : (
              paginatedData.map((phrase) => (
                <TableRow 
                  key={phrase.id}
                  className={cn(
                    selectedRows.includes(phrase.id) && "bg-muted",
                    newIds.includes(phrase.id) && "animate-flash"
                  )}
                >
                  {/* Checkbox */}
                  <TableCell className="w-12">
                    <Checkbox
                      checked={selectedRows.includes(phrase.id)}
                      onCheckedChange={() => toggleRowSelection(phrase.id)}
                    />
                  </TableCell>
                  
                  {/* Phrase */}
                  {!hiddenColumns.includes('phrase') && (
                    <TableCell className="font-medium">{phrase.phrase}</TableCell>
                  )}
                  
                  {/* Category */}
                  {!hiddenColumns.includes('category') && (
                    <TableCell>{phrase.category}</TableCell>
                  )}
                  
                  {/* Hint - Moved here */}
                  {!hiddenColumns.includes('hint') && (
                    <TableCell>{phrase.hint || '-'}</TableCell>
                  )}
                  
                  {/* Tags */}
                  {!hiddenColumns.includes('tags') && (
                    <TableCell>
                      <TagDisplay tags={phrase.tags || ''} />
                    </TableCell>
                  )}
                  
                  {/* Difficulty - Bar Style */}
                  {!hiddenColumns.includes('difficulty') && (
                    <TableCell>
                      {getDifficultyBar(phrase.difficulty)}
                    </TableCell>
                  )}
                  
                  {/* Reviewed Status */}
                  {!hiddenColumns.includes('reviewed') && (
                    <TableCell>
                      <div className="flex justify-center">
                        {phrase.reviewed ? (
                          <Check className="h-5 w-5 text-green-500" />
                        ) : (
                          <Check className="h-5 w-5 text-gray-300" />
                        )}
                      </div>
                    </TableCell>
                  )}
                  
                  {/* Actions */}
                  <TableCell>
                    <div className="flex justify-end">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" className="h-8 w-8 p-0">
                            <span className="sr-only">Open menu</span>
                            <MoreHorizontal className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuLabel>Actions</DropdownMenuLabel>
                          <DropdownMenuItem onClick={() => onEdit?.(phrase.id)}>
                            <Pencil className="h-4 w-4 mr-2" />
                            Edit
                          </DropdownMenuItem>
                          <DropdownMenuSeparator />
                          <DropdownMenuItem 
                            onClick={() => {
                              if (window.confirm('Are you sure you want to delete this phrase?')) {
                                onDelete?.(phrase.id);
                              }
                            }}
                            className="text-red-600"
                          >
                            <Trash className="h-4 w-4 mr-2" />
                            Delete
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}

============================================================

FILE: .\components\review\CardSwiper.css
SIZE: 5.78 KB
LAST MODIFIED: 03/04/2025 09:36:22

/* components/reviewer/CardSwiper.css */

.demo {
    margin: auto;
    position: relative;
  }
  
  .demo__content {
    overflow: visible;
    position: relative;
    user-select: none;
  }
  
  .demo__card-cont {
    position: relative;
    width: 100%;
    height: 320px;
    margin: 0 auto 3rem; /* Increased bottom margin */
    perspective: 1000px;
  }
  
  .demo__card {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    transform-origin: 50% 100%;
    transition: transform 0.3s ease, opacity 0.2s ease;
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
    background-color: rgb(31, 41, 55);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    will-change: transform;
  }
  
  .demo__card.reset {
    transition: transform 0.3s;
  }
  
  .demo__card.reset .demo__card__choice {
    transition: opacity 0.3s;
    opacity: 0 !important;
  }
  
  .demo__card.inactive {
    transition: transform 0.3s;
  }
  
  .demo__card.to-left {
    transform: translateX(-150%) rotate(-30deg) !important;
  }
  
  .demo__card.to-right {
    transform: translateX(150%) rotate(30deg) !important;
  }
  
  .demo__card.below {
    z-index: 1;
  }
  
  .demo__card__top {
    height: 200px;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: linear-gradient(145deg, #2563eb, #1e40af);
  }
  
  .demo__card__top.blue {
    background: linear-gradient(145deg, #2563eb, #1e40af);
  }
  
  .demo__card__top.lime {
    background: linear-gradient(145deg, #65a30d, #4d7c0f);
  }
  
  .demo__card__top.purple {
    background: linear-gradient(145deg, #7c3aed, #6d28d9);
  }
  
  .demo__card__name {
    text-align: center;
    font-size: 2rem;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    word-wrap: break-word;
    hyphens: auto;
    padding: 0 1rem;
    max-height: 160px;
    overflow-y: auto;
  }
  
  .demo__card__btm {
    height: calc(100% - 200px);
    background: rgba(31, 41, 55, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 1rem;
  }
  
  .demo__card__choice {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    border-radius: 12px;
    overflow: hidden;
    transition: opacity 0.3s ease;
  }
  
  .demo__card__choice.m--reject {
    background: rgba(239, 68, 68, 0.7);
  }
  
  .demo__card__choice.m--like {
    background: rgba(34, 197, 94, 0.7);
  }
  
  .demo__card__choice:before {
    content: "";
    position: absolute;
    left: 50%;
    top: 50%;
    width: 2rem;
    height: 2rem;
    margin-left: -1rem;
    color: #fff;
    border-radius: 50%;
    box-shadow: -2rem -3rem #fff, 2rem -3rem #fff;
  }
  
  .demo__card__choice:after {
    content: "";
    position: absolute;
    left: 50%;
    top: 50%;
    width: 4rem;
    height: 1.5rem;
    margin-left: -2rem;
    border: 0.6rem solid #fff;
    border-bottom: none;
    border-top-left-radius: 1.5rem;
    border-top-right-radius: 1.5rem;
  }
  
  .demo__card__choice.m--like:after {
    transform: scaleY(-1);
  }
  
  .demo__card__drag {
    z-index: 5;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    cursor: grab;
  }
  
  /* Swipe hint text in bottom of card */
  .demo__card__swipe-hint {
    text-align: center;
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    font-style: italic;
    margin: 0.5rem 0;
    position: relative;
    padding-left: 20px;
    padding-right: 20px;
  }
  
  .demo__card__swipe-hint:before {
    content: "â†";
    position: absolute;
    left: 0;
    top: 0;
  }
  .demo__card__swipe-hint:after {
    content: "â†’";
    position: absolute;
    right:0;
    top: 0;
  }
  
  .demo__card-cont {
    perspective: 1200px;
    transform-style: preserve-3d;
  }
  
  .demo__card {
    backface-visibility: hidden;
    will-change: transform;
  }
  
  /* Ensure inactive cards aren't affecting layout */
  .demo__card.inactive {
    pointer-events: none;
    visibility: hidden;
    opacity: 0;
    transition: transform 0.3s, opacity 0.3s, visibility 0s 0.3s;
  }
  
  /* Card stacking for up to 15 cards with subtle differences */
  .demo__card:nth-child(1) { z-index: 15; }
  .demo__card:nth-child(2) { 
    z-index: 14; 
    transform: translateY(7px) scale(0.97);
  }
  .demo__card:nth-child(3) { 
    z-index: 13; 
    transform: translateY(14px) scale(0.94);
  }
  .demo__card:nth-child(4) { 
    z-index: 12; 
    transform: translateY(21px) scale(0.91);
  }
  .demo__card:nth-child(5) { 
    z-index: 11; 
    transform: translateY(28px) scale(0.88);
  }
  /* Cards beyond 5 will have decreasing opacity */
  .demo__card:nth-child(n+6) { 
    z-index: calc(10 - (var(--n) - 5)); 
    transform: translateY(calc(28px + ((var(--n) - 5) * 2px))) scale(calc(0.88 - ((var(--n) - 5) * 0.01)));
    opacity: calc(1 - ((var(--n) - 5) * 0.1));
  }
  
  /* Swipe indicators - subtle arrows on sides */
  .demo__swipe-indicator {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 2rem;
    color: rgba(255, 255, 255, 0.2);
    z-index: 10;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  
  .demo__swipe-indicator--left {
    left: 1rem;
  }
  
  .demo__swipe-indicator--right {
    right: 1rem;
  }
  
  .demo__card:hover .demo__swipe-indicator {
    opacity: 0.7;
  }
  
  @media (max-width: 640px) {
    .demo__card-cont {
      height: 300px;
    }
    
    .demo__card__name {
      font-size: 1.75rem;
    }
  }

============================================================

FILE: .\components\review\CategoryFilter.tsx
SIZE: 1.06 KB
LAST MODIFIED: 02/17/2025 11:03:54

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface CategoryFilterProps {
  categories: string[];
  selectedCategory: string | null;
  onSelect: (category: string | null) => void;
}

export const CategoryFilter: React.FC<CategoryFilterProps> = ({
  categories,
  selectedCategory,
  onSelect
}) => {
  return (
    <div className="w-1/2">
      <Select 
        value={selectedCategory || "all"} 
        onValueChange={(value) => onSelect(value === "all" ? null : value)}
      >
        <SelectTrigger className="w-full bg-gray-800 border-gray-700">
          <SelectValue placeholder="Choose a Category" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">Choose a Category</SelectItem>
          {categories.map(category => (
            <SelectItem key={category} value={category}>
              {category}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default CategoryFilter;

============================================================

FILE: .\components\review\Leaderboard.tsx
SIZE: 1.25 KB
LAST MODIFIED: 02/12/2025 10:08:18

// components/reviewer/Leaderboard.tsx
import React from 'react';
import { Award } from 'lucide-react';
import type { Reviewer } from '@/types/types';

interface LeaderboardProps {
  reviewers: Reviewer[];
}

const Leaderboard = ({ reviewers }: LeaderboardProps) => (
  <div className="bg-gray-800 p-4 rounded-lg mt-4">
    <div className="flex items-center gap-2 mb-4">
      <Award className="w-6 h-6 text-yellow-500" />
      <h3 className="text-lg font-bold text-white">Leaderboard</h3>
    </div>
    <div className="space-y-2">
      {reviewers
        .sort((a, b) => b.total_reviews - a.total_reviews)
        .slice(0, 5)
        .map((reviewer, index) => (
          <div
            key={reviewer.id}
            className="flex items-center justify-between p-2 rounded bg-gray-700"
          >
            <div className="flex items-center gap-2">
              <span className="text-xl">{['🥇', '🥈', '🥉', '4️⃣', '5️⃣'][index]}</span>
              <span className="text-white">{reviewer.name}</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="text-white">{reviewer.total_reviews}</span>
            </div>
          </div>
        ))}
    </div>
  </div>
);

export default Leaderboard;

============================================================

FILE: .\components\review\PinPad.tsx
SIZE: 1.98 KB
LAST MODIFIED: 02/12/2025 00:51:24

// components/reviewer/PinPad.tsx
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { X } from 'lucide-react';

interface PinPadProps {
  onSubmit: (pin: string) => void;
  onCancel: () => void;
}

const PinPad = ({ onSubmit, onCancel }: PinPadProps) => {
  const [pin, setPin] = useState<string>('');
  const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '', '0', 'âŒ«'];

  const handleClick = (value: string) => {
    if (value === 'âŒ«') {
      setPin(prev => prev.slice(0, -1));
    } else if (pin.length < 4) {
      setPin(prev => prev + value);
    }
  };

  useEffect(() => {
    if (pin.length === 4) {
      onSubmit(pin);
      setPin('');
    }
  }, [pin, onSubmit]);

  return (
  <div className="flex items-center justify-center min-h-screen">
    <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm items-center justify-center">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">Enter PIN</h3>
        <Button variant="ghost" size="icon" onClick={onCancel}>
          <X className="h-5 w-5 text-white" />
        </Button>
      </div>
      
      <div className="flex justify-center mb-6">
        {[...Array(4)].map((_, i) => (
          <div
            key={i}
            className={`w-4 h-4 mx-2 rounded-full ${
              pin.length > i ? 'bg-blue-500' : 'bg-gray-600'
            }`}
          />
        ))}
      </div>

      <div className="grid grid-cols-3 gap-4">
        {numbers.map((num, index) => (
          <Button
            key={index}
            onClick={() => num && handleClick(num)}
            className={`h-16 text-2xl rounded-full text-white ${
              !num ? 'invisible' : ''
            }`}
            variant="outline"
          >
            {num}
          </Button>
        ))}
      </div>
    </div>
	</div>
  );
};

export default PinPad;

============================================================

FILE: .\components\review\ReviewerCard.tsx
SIZE: 1.07 KB
LAST MODIFIED: 02/12/2025 10:06:04

// components/reviewer/ReviewerCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { Star } from 'lucide-react';
import type { Reviewer } from '@/types/types';

interface ReviewerCardProps {
  reviewer: Reviewer;
  avatar: string;
  onClick: () => void;
}

const ReviewerCard = ({ reviewer, avatar, onClick }: ReviewerCardProps) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    whileTap={{ scale: 0.95 }}
    className="bg-gray-800 p-4 rounded-lg cursor-pointer text-center w-full mb-8"
    onClick={onClick}
  >
    <div className="text-6xl mb-2">{avatar}</div>
    <h3 className="text-lg font-bold mb-1 text-white">{reviewer.name}</h3>
    <div className="flex items-center justify-center gap-2">
      <span className="text-sm text-gray-300">
        {reviewer.total_reviews} reviews
      </span>
      {reviewer.current_streak >= 3 && (
        <span className="text-lg">🔥</span>
      )}
      {reviewer.total_reviews >= 50 && (
        <Star className="w-4 h-4 text-yellow-500" />
      )}
    </div>
  </motion.div>
);

export default ReviewerCard;

============================================================

FILE: .\components\review\ReviewerSelection.tsx
SIZE: 4.07 KB
LAST MODIFIED: 03/05/2025 15:21:07

import React, { useState, useEffect } from 'react';
import { AnimatePresence } from 'framer-motion';
import { Award } from 'lucide-react';
import ReviewerCard from './ReviewerCard';
import Leaderboard from './Leaderboard';
import PinPad from './PinPad';
import { supabase } from '@/lib/services/supabase';
import type { Reviewer } from '@/types/types';


const AVATARS = ['ðŸ¦', 'ðŸ¯', 'ðŸ®', 'ðŸ·', 'ðŸ¸', 'ðŸ™', 'ðŸ¦Š', 'ðŸ¨', 'ðŸ°', 'ðŸ¼'];

interface ReviewerSelectionProps {
  onSelectReviewer: (reviewer: Reviewer) => void;
  onClose: () => void;
}

const ReviewerSelection: React.FC<ReviewerSelectionProps> = ({ 
  onSelectReviewer, 
  onClose 
}) => {
  const [selectedReviewer, setSelectedReviewer] = useState<Reviewer | null>(null);
  const [showPinPad, setShowPinPad] = useState<boolean>(false);
  const [reviewers, setReviewers] = useState<Reviewer[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchReviewers = async () => {
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });
      
      if (error) {
        console.error('Error fetching reviewers:', error);
        return;
      }
      
      if (data) {
        setReviewers(data);
      }
    };

    fetchReviewers();
  }, []);

  const handlePinSubmit = async (pin: string) => {
    if (!selectedReviewer) return;

    const { data, error } = await supabase
      .from('reviewers')
      .select('id')
      .match({ id: selectedReviewer.id, pin })
      .single();

    if (data) {
      // Handle successful login
      const now = new Date();
      const lastReview = selectedReviewer.last_review_at ? new Date(selectedReviewer.last_review_at) : null;
      
      // Calculate if streak should continue or reset
      const streakContinues = lastReview && 
        (now.getTime() - lastReview.getTime()) < (24 * 60 * 60 * 1000);
      
      const current_streak = streakContinues ? selectedReviewer.current_streak : 0;

      // Update reviewer stats
      const { error: updateError } = await supabase
        .from('reviewers')
        .update({ current_streak })
        .eq('id', selectedReviewer.id);

      if (updateError) {
        console.error('Error updating reviewer streak:', updateError);
      }

      onSelectReviewer({
        ...selectedReviewer,
        current_streak
      });
    } else {
      setError('Incorrect PIN');
      setShowPinPad(false);
      setSelectedReviewer(null);
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
      <div className="w-full max-w-4xl">
        <AnimatePresence>
          {showPinPad ? (
            <PinPad
              onSubmit={handlePinSubmit}
              onCancel={() => {
                setShowPinPad(false);
                setSelectedReviewer(null);
                setError(null);
              }}
            />
          ) : (
            <div className="text-center">
              <h2 className="text-2xl font-bold text-white mb-8">Who's reviewing?</h2>
              
              {error && (
                <div className="bg-red-900 text-red-100 p-4 rounded-lg mb-8">
                  {error}
                </div>
              )}

              <div
                className="grid gap-6 justify-items-center"
                style={{ gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))" }}
              >
                {reviewers.map((reviewer, index) => (
                  <ReviewerCard
                    key={reviewer.id}
                    reviewer={reviewer}
                    avatar={AVATARS[index % AVATARS.length]}
                    onClick={() => {
                      setSelectedReviewer(reviewer);
                      setShowPinPad(true);
                      setError(null);
                    }}
                  />
                ))}
              </div>
              
              <Leaderboard reviewers={reviewers} />
            </div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
};

export default ReviewerSelection;


============================================================

FILE: .\components\review\ReviewProgress.tsx
SIZE: 0.82 KB
LAST MODIFIED: 02/17/2025 11:07:30

import React from 'react';
import { Flame } from 'lucide-react';

interface ReviewProgressProps {
  streak: number;
}

const ReviewProgress: React.FC<ReviewProgressProps> = ({ streak }) => {
  const percentage = (streak % 10) * 10; // Calculate percentage based on streak mod 10

  return (
    <div className="flex items-center gap-2 px-4 py-2 bg-gray-800 rounded-lg hover:bg-gray-700">
      <div className="text-gray-300 flex items-center gap-2 ">
       
        Review Hot Streak: {streak}
      </div>
      <div className="w-24 bg-gray-700 rounded-full h-2">
        <div
          className="bg-orange-500 h-2 rounded-full transition-all duration-300"
          style={{ width: `${percentage}%` }}
        />
      </div>
       <Flame className="w-4 h-4 text-orange-500" />
    </div>
  );
};

export default ReviewProgress;

============================================================

FILE: .\components\review\WordCreator.tsx
SIZE: 21.29 KB
LAST MODIFIED: 03/05/2025 15:03:18

// components/reviewer/WordCreator.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';
import { generatePhrases, generateTags, generateHint, suggestCategory } from '@/lib/services/claudeService';
import type { Reviewer, Phrase } from '@/types/types';

// Safe storage utility
const safeStorage = {
  getItem: (key: string): string | null => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        return localStorage.getItem(key);
      }
      return null;
    } catch (error) {
      console.warn('Unable to access localStorage:', error);
      return null;
    }
  },
  
  setItem: (key: string, value: string): boolean => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        localStorage.setItem(key, value);
        return true;
      }
      return false;
    } catch (error) {
      console.warn('Unable to access localStorage:', error);
      return false;
    }
  },
  
  removeItem: (key: string): boolean => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        localStorage.removeItem(key);
        return true;
      }
      return false;
    } catch (error) {
      console.warn('Unable to access localStorage:', error);
      return false;
    }
  }
};

interface WordCreatorProps {
  reviewer: Reviewer;
  categories: string[];
  onSwitchMode: () => void;
}

interface GeneratedPhrase {
  id: string;
  phrase: string;
  hint?: string;
  category?: string;
  difficulty?: number;
  tags?: string;
  saved?: boolean;
}

enum CreationStep {
  GENERATE,
  SELECT,
  EDIT
}

const DIFFICULTY_OPTIONS = ['Easy', 'Medium', 'Hard'];

const WordCreator: React.FC<WordCreatorProps> = ({ reviewer, categories, onSwitchMode }) => {
  // State
  const [step, setStep] = useState(CreationStep.GENERATE);
  const [inspiration, setInspiration] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedPhrases, setGeneratedPhrases] = useState<GeneratedPhrase[]>([]);
  const [selectedPhrase, setSelectedPhrase] = useState<GeneratedPhrase | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [isSuggestingCategory, setIsSuggestingCategory] = useState(false);
  
  // Helper function to convert text to title case
  const toTitleCase = (text: string): string => {
    return text
      .toLowerCase()
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  };
  
  // Format tags to ensure comma-separated format
  const formatTags = (tagInput: string): string => {
    // First convert any whitespace to a single space
    const normalized = tagInput.replace(/\s+/g, ' ').trim();
    
    // Split by spaces or commas
    const tagArray = normalized.split(/[\s,]+/).filter(Boolean);
    
    // Join back with commas
    return tagArray.join(',');
  };
  
  // Load previous inspiration from storage if available
  useEffect(() => {
    const savedInspiration = safeStorage.getItem('lastInspiration');
    if (savedInspiration) {
      setInspiration(savedInspiration);
    }
  }, []);

  const handleInspirationChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInspiration(e.target.value);
    safeStorage.setItem('lastInspiration', e.target.value);
  };

  const handleGeneratePhrases = async () => {
    if (!inspiration || isGenerating) return;

    setIsGenerating(true);
    try {
      const result = await generatePhrases(inspiration, 10);
      
      // Transform the result into our format with title case
      const phrases: GeneratedPhrase[] = result.phrases.map((phrase: string, index: number) => ({
        id: `new-${Date.now()}-${index}`,
        phrase: toTitleCase(phrase),
        difficulty: 2, // Default to medium
        saved: false,
      }));
      
      setGeneratedPhrases(phrases);
      setStep(CreationStep.SELECT);
    } catch (error) {
      console.error('Error generating phrases:', error);
      alert('Failed to generate phrases. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSelectPhrase = (phrase: GeneratedPhrase) => {
    setSelectedPhrase(phrase);
    setStep(CreationStep.EDIT);
  };

  const handleStartOver = () => {
    setGeneratedPhrases([]);
    setSelectedPhrase(null);
    setStep(CreationStep.GENERATE);
  };

  const handleUpdateSelectedPhrase = (field: keyof GeneratedPhrase, value: string | number) => {
    if (!selectedPhrase) return;
    
    setSelectedPhrase(prev => {
      if (!prev) return null;
      return { ...prev, [field]: value };
    });
  };

  const handleGenerateHint = async () => {
    if (!selectedPhrase) return;
    
    try {
      const result = await generateHint(selectedPhrase.phrase);
      if (result.hint) {
        // Apply title case and enforce character limit
        const titleCasedHint = toTitleCase(result.hint);
        handleUpdateHint(titleCasedHint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
    }
  };
  const handleUpdateHint = (hintText: string) => {
    if (!selectedPhrase) return;
    
    // Only limit the length but don't trim during typing
    // This preserves spaces while typing
    const limitedHint = hintText.length > 20 ? hintText.substring(0, 20) : hintText;
    
    setSelectedPhrase(prev => {
      if (!prev) return null;
      return { ...prev, hint: limitedHint };
    });
  };
    const handleGenerateTags = async () => {
    if (!selectedPhrase) return;
    
    try {
      const result = await generateTags(selectedPhrase.phrase);
      if (result.tags.length > 0) {
        handleUpdateSelectedPhrase('tags', result.tags.join(','));
      }
    } catch (error) {
      console.error('Error generating tags:', error);
    }
  };

  const handleSuggestCategory = async () => {
    if (!selectedPhrase) return;
    
    try {
      // Show loading state
      setIsSuggestingCategory(true);
      
      // Call the suggestCategory function
      const result = await suggestCategory(selectedPhrase.phrase, categories);
      
      if (result.category && !result.error) {
        handleUpdateSelectedPhrase('category', result.category);
      } else if (result.error) {
        console.error('Error suggesting category:', result.error);
        alert('Failed to suggest a category. Please try again or select manually.');
      }
    } catch (error) {
      console.error('Error suggesting category:', error);
      alert('Failed to suggest category. Please try again.');
    } finally {
      setIsSuggestingCategory(false);
    }
  };

  const handleSavePhrase = async () => {
    if (!selectedPhrase || !reviewer) return;
    
    setIsSaving(true);
    
    try {
      // Log what we're trying to save
      console.log("Saving phrase:", selectedPhrase);
      
      // Get category ID
      let categoryId = null;
      
      if (selectedPhrase.category) {
        const { data: catData, error: catError } = await supabase
          .from('categories')
          .select('id')
          .eq('name', selectedPhrase.category)
          .single();
        
        if (catError) {
          console.error('Error fetching category:', catError);
          throw new Error(`Category error: ${catError.message}`);
        }
          
        if (catData) {
          categoryId = catData.id;
        }
      }
      
      // Create a phrase object with only the fields that exist in your database schema
      const phraseData = {
        phrase: selectedPhrase.phrase,
        hint: selectedPhrase.hint || null,
        difficulty: selectedPhrase.difficulty || 2,
        category_id: categoryId,
        // No created_by field in your schema
        // No created_at field in your schema
      };

      
      
      console.log("Inserting phrase with data:", phraseData);
      
      // Insert the phrase
      const { data, error: phraseError } = await supabase
        .from('phrases')
        .insert(phraseData)
        .select('id')
        .single();
        
      if (phraseError) {
        console.error('Phrase insert error details:', phraseError);
        throw phraseError;
      }
      
      if (!data || !data.id) {
        throw new Error('No data returned from phrase insert');
      }
      
      // Handle tags if any
      if (selectedPhrase.tags && data) {
        const tagList = selectedPhrase.tags.split(',').map(tag => tag.trim()).filter(Boolean);
        
        for (const tagName of tagList) {
          // Check if tag exists
          let tagId;
          
          try {
            const { data: existingTag, error: tagFetchError } = await supabase
              .from('tags')
              .select('id')
              .eq('tag', tagName)
              .single();
            
            if (tagFetchError) {
              if (tagFetchError.code === 'PGRST116') { // Not found
                // Create new tag
                const { data: newTag, error: tagInsertError } = await supabase
                  .from('tags')
                  .insert({ tag: tagName })
                  .select('id')
                  .single();
                
                if (tagInsertError) {
                  console.error('Error creating tag:', tagInsertError);
                  continue;
                }
                  
                if (!newTag) continue;
                tagId = newTag.id;
              } else {
                console.error('Error fetching tag:', tagFetchError);
                continue;
              }
            } else if (existingTag) {
              tagId = existingTag.id;
            }
            
            // Link tag to phrase
            const { error: linkError } = await supabase
              .from('phrase_tags')
              .insert({
                phrase_id: data.id,
                tag_id: tagId
              });
            
            if (linkError) {
              console.error('Error linking tag to phrase:', linkError);
            }
          } catch (tagError) {
            console.error('Error processing tag:', tagError);
            // Continue with next tag even if this one fails
          }
        }
      }
      
      // Mark as saved in our local state
      setGeneratedPhrases(prev => 
        prev.map(p => p.id === selectedPhrase.id ? { ...p, saved: true } : p)
      );
      
      // Return to selection screen
      setStep(CreationStep.SELECT);
      setSelectedPhrase(null);
      
      // Show success message
      alert('Word saved successfully!');
      
    } catch (error) {
      console.error('Error saving phrase (full details):', error);
      alert(`Failed to save phrase: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsSaving(false);
    }
  };

  // Render the phrase generation form
  const renderGenerationForm = () => (
    <div className="bg-gray-800 rounded-lg p-6 mb-6">
      <h2 className="text-xl font-bold mb-4">Create New Words</h2>
      <div className="mb-6">
        <label className="block text-gray-400 text-sm mb-2">Provide Inspiration</label>
        <input
          type="text"
          value={inspiration}
          onChange={handleInspirationChange}
          className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
          placeholder="Enter a topic, theme, or idea..."
        />
      </div>
      <button
        onClick={handleGeneratePhrases}
        disabled={!inspiration || isGenerating}
        className="w-full p-3 rounded bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed"
      >
        {isGenerating ? 
          <div className="flex items-center justify-center">
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Generating...
          </div>
          : 'ðŸ¤– Generate Words'
        }
      </button>
    </div>
  );

  // Render the phrase selection grid
  const renderPhraseSelection = () => {
    const savedCount = generatedPhrases.filter(p => p.saved).length;
    
    return (
      <div className="mb-6">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-bold">Select Word to Add</h2>
          <div className="flex items-center gap-3">
            <div className="text-sm text-gray-300">
              <span className="text-green-500 font-medium">{savedCount}</span> of {generatedPhrases.length} saved
            </div>
            <button
              onClick={handleStartOver}
              className="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm"
            >
              Start Over
            </button>
          </div>
        </div>
        
        <div 
          className="grid gap-4"
          style={{ gridTemplateColumns: "repeat(auto-fill, minmax(180px, 1fr))" }}
        >
          {generatedPhrases.map((phrase) => (
            <div 
              key={phrase.id}
              onClick={() => handleSelectPhrase(phrase)}
              className={`${phrase.saved ? 'bg-gray-700 text-gray-400' : 'bg-gray-800 text-white'} 
                p-4 rounded-lg cursor-pointer text-center transition-colors duration-200 min-h-40
                flex flex-col justify-center hover:scale-105 transform`}
            >
              <h3 className="text-lg font-bold mb-2">{phrase.phrase}</h3>
              
              {phrase.saved && (
                <div className="flex justify-center items-center mt-2">
                  <span className="text-xs px-2 py-1 bg-green-600 rounded-full text-white">
                    Saved
                  </span>
                </div>
              )}
            </div>
          ))}
        </div>
      </div>
    );
  };

  // Render the edit form for a selected phrase
  const renderEditForm = () => {
    if (!selectedPhrase) return null;
    
    return (
      <div className="bg-gray-800 rounded-lg p-6 mb-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">Edit Word</h2>
          <button
            onClick={() => {
              setStep(CreationStep.SELECT);
              setSelectedPhrase(null);
            }}
            className="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm"
          >
            Back to Selection
          </button>
        </div>
        
        <div className="mb-4">
          <label className="block text-gray-400 text-sm mb-1">Word</label>
          <div className="p-3 rounded bg-gray-700 text-white">
            {selectedPhrase.phrase}
          </div>
        </div>
        
        <div className="mb-4">
          <label className="block text-gray-400 text-sm mb-1">Difficulty</label>
          <select
            value={selectedPhrase.difficulty || 2}
            onChange={(e) => handleUpdateSelectedPhrase('difficulty', parseInt(e.target.value, 10))}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
          >
            {[1, 2, 3].map((value, index) => (
              <option key={value} value={value}>
                {DIFFICULTY_OPTIONS[index]}
              </option>
            ))}
          </select>
        </div>
        
        <div className="mb-4">
          <label className="block text-gray-400 text-sm mb-1">Category</label>
          <div className="flex gap-2">
            <select
              value={selectedPhrase.category || ''}
              onChange={(e) => handleUpdateSelectedPhrase('category', e.target.value)}
              className="flex-1 p-3 rounded bg-gray-700 text-white border border-gray-600"
            >
              <option value="">Select Category</option>
              {categories.map((category) => (
                <option key={category} value={category}>
                  {category}
                </option>
              ))}
            </select>
            <button
              onClick={handleSuggestCategory}
              className="px-3 py-1 bg-purple-600 rounded hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed"
              title="Get AI suggestion for best category"
              disabled={isSuggestingCategory}
            >
              {isSuggestingCategory ? (
                <div className="flex items-center justify-center">
                  <svg className="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                </div>
              ) : (
                "ðŸ¤– AI"
              )}
            </button>
          </div>
        </div>
        
        {/* Subcategory field removed */}
        
        <div className="mb-4">
          <label className="block text-gray-400 text-sm mb-1">Tags</label>
          <div className="flex gap-2">
            <input
              type="text"
              value={selectedPhrase.tags || ''}
              onChange={(e) => handleUpdateSelectedPhrase('tags', formatTags(e.target.value))}
              onBlur={(e) => {
                // Format on blur to ensure comma-separation
                const formattedValue = formatTags(e.target.value);
                if (formattedValue !== e.target.value) {
                  handleUpdateSelectedPhrase('tags', formattedValue);
                }
              }}
              className="flex-1 p-3 rounded bg-gray-700 text-white border border-gray-600"
              placeholder="Comma-separated tags"
            />
            <button
              onClick={handleGenerateTags}
              className="px-3 py-1 bg-purple-600 rounded hover:bg-purple-700"
            >
              ðŸ¤– AI
            </button>
          </div>
          <p className="text-xs text-gray-400 mt-1">Enter up to 3 tags separated by commas</p>
        </div>
        
        <div className="mb-6">
  <label className="block text-gray-400 text-sm mb-1">Hint</label>
  <div className="flex gap-2">
    <div className="flex-1 relative">
      <input
        type="text"
        value={selectedPhrase.hint || ''}
        onChange={(e) => handleUpdateHint(e.target.value)}
        maxLength={20}
        className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
        placeholder="Enter a hint"
      />
      <div className="absolute bottom-1 right-2 text-xs text-gray-400">
        {selectedPhrase.hint ? selectedPhrase.hint.length : 0}/20
      </div>
    </div>
    <button
      onClick={handleGenerateHint}
      className="px-3 py-1 bg-purple-600 rounded hover:bg-purple-700"
    >
      ðŸ¤– AI
    </button>
  </div>
  <p className="text-xs text-gray-400 mt-1">Maximum 20 characters</p>
</div>
        
        <button
          onClick={handleSavePhrase}
          disabled={isSaving}
          className="w-full p-3 rounded bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed"
        >
          {isSaving ? 
            <div className="flex items-center justify-center">
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Saving...
            </div>
            : selectedPhrase.saved ? 'Update Word' : 'Save Word'
          }
        </button>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4">
      <div className="max-w-2xl mx-auto">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-2xl font-bold">Word Creator</h1>
            <p className="text-gray-400 mt-1">
              Reviewer: {reviewer.name}
            </p>
          </div>
          <button
            onClick={onSwitchMode}
            className="px-4 py-2 bg-purple-600 rounded hover:bg-purple-700"
          >
            Back to Review
          </button>
        </div>

        {step === CreationStep.GENERATE && renderGenerationForm()}
        {step === CreationStep.SELECT && renderPhraseSelection()}
        {step === CreationStep.EDIT && renderEditForm()}
      </div>
    </div>
  );
};

export default WordCreator;


============================================================

FILE: .\components\shared\BulkImportForm.tsx
SIZE: 3.89 KB
LAST MODIFIED: 03/06/2025 22:11:26

import React, { useState, useRef } from 'react';
import { Upload } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import type { BulkImportFormProps, NewPhrase } from '@/types/types';
import { supabase } from '@/lib/services/supabase';
import Papa from 'papaparse';

const BulkImportForm: React.FC<BulkImportFormProps> = ({
  onSuccess,
  onError
}) => {
  const [bulkImportText, setBulkImportText] = useState('');
  const [loading, setLoading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Existing handleBulkImport code and other processing functions

  const handleFileSelect = async (file: File) => {
    try {
      const text = await file.text();
      setBulkImportText(text);
    } catch (err) {
      console.error('File reading error:', err);
      onError('Failed to read file');
    }
  };

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(e.type === 'dragenter' || e.type === 'dragover');
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    const file = e.dataTransfer.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Bulk Import</CardTitle>
      </CardHeader>
      <CardContent>
        <div
          className={`relative border-2 border-dashed rounded-lg p-6 mb-4
            ${dragActive 
              ? 'border-blue-500 bg-blue-500/10' 
              : 'border-gray-600'
            }`}
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          <input
            ref={fileInputRef}
            type="file"
            onChange={handleFileInput}
            accept=".csv"
            className="hidden"
          />
          
          <div className="text-center">
            <Upload className="mx-auto h-12 w-12 text-gray-400" />
            <p className="mt-2 text-sm text-gray-400">
              Drag and drop a CSV file, or{' '}
              <button
                type="button"
                onClick={() => fileInputRef.current?.click()}
                className="text-blue-500 hover:text-blue-400"
              >
                browse
              </button>
            </p>
          </div>
        </div>

        <textarea
          value={bulkImportText}
          onChange={(e) => setBulkImportText(e.target.value)}
          className="w-full h-32 p-2 mb-4 border rounded bg-background focus:ring-2 focus:ring-blue-500"
          placeholder="phrase,category,difficulty,subcategory,tags,hint,part_of_speech"
        />

        <p className="text-sm text-muted-foreground mb-4">
          Format: phrase,category,difficulty,subcategory,tags,hint,part_of_speech
        </p>

        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => setBulkImportText('')}
            disabled={loading || !bulkImportText.trim()}
          >
            Clear
          </Button>
          <Button
            onClick={() => handleBulkImport(bulkImportText)}
            disabled={loading || !bulkImportText.trim()}
            className="bg-white text-black hover:bg-gray-100"
          >
            {loading ? 'Importing...' : 'Import Phrases'}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default BulkImportForm;

============================================================

FILE: .\components\shared\CardViewModal.tsx
SIZE: 10.29 KB
LAST MODIFIED: 03/05/2025 15:03:18

import React, { useState } from 'react';
import { ChevronLeft, ChevronRight, X, Pencil, Save } from 'lucide-react';
import { Button } from '@/components/ui/button';
import TagDisplay from '@/components/common/TagDisplay';
import { supabase } from '@/lib/services/supabase';
import type { CardViewModalProps, Phrase, VoteCategory } from '@/types/types';

interface FieldProps extends React.ComponentProps<'div'> {
  label: string;
  value: any;
  onChange?: (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => void;
  type?: string;
  options?: string[];
  isEditing: boolean;
  onTagClick?: (tag: string) => void;
  onVote?: (isLike: boolean) => void;
  rating?: boolean;
  showVoting?: boolean;
}

const Field: React.FC<FieldProps> = ({ 
  label, 
  value, 
  onChange, 
  type = "text", 
  options = [], 
  isEditing,
  onTagClick,
  onVote,
  rating,
  showVoting = false
}) => {
  const baseFieldClass = `mb-4 rounded-lg p-3 ${
    rating === true ? 'bg-green-900' :
    rating === false ? 'bg-red-900' :
    'bg-gray-700'
  }`;

  if (isEditing) {
    if (type === "select") {
      return (
        <div className={baseFieldClass}>
          <label className="block text-gray-400 text-sm mb-1">{label}</label>
          <select
            value={value || ""}
            onChange={onChange}
            className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 
                     focus:ring-2 focus:ring-blue-500"
          >
            <option value="">Select {label}</option>
            {options.map(opt => (
              <option key={opt} value={opt}>{opt}</option>
            ))}
          </select>
        </div>
      );
    }

    return (
      <div className={baseFieldClass}>
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <input
          type={type}
          value={value || ""}
          onChange={onChange}
          className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 
                   focus:ring-2 focus:ring-blue-500"
        />
      </div>
    );
  }

  return (
    <div className={baseFieldClass}>
      <div className="grid grid-cols-[100px_1fr_auto] gap-3 items-center">
        <div className="text-gray-300 px-3 py-1 text-sm">
          {label}
        </div>
        <div className="px-3 py-2">
          {type === "tags" ? (
            <TagDisplay tags={value || ''} onClick={onTagClick} />
          ) : (
            <span className="text-lg text-white">{value || '-'}</span>
          )}
        </div>
        {showVoting && onVote && (
          <div className="flex gap-2 justify-end">
            <button
              onClick={() => onVote(true)}
              className={`w-8 h-8 rounded-full flex items-center justify-center ${
                rating === true ? 'bg-green-600' : 'hover:bg-gray-500'
              }`}
            >
              ðŸ‘
            </button>
            <button
              onClick={() => onVote(false)}
              className={`w-8 h-8 rounded-full flex items-center justify-center ${
                rating === false ? 'bg-red-600' : 'hover:bg-gray-500'
              }`}
            >
              ðŸ‘Ž
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

const CardViewModal: React.FC<CardViewModalProps> = ({
  isOpen,
  onClose,
  phrases,
  currentIndex,
  onNavigate,
  isEditing,
  editedPhrase,
  onEdit,
  onSave,
  onCancel,
  onEditChange,
  categories,
  difficulties,
  partsOfSpeech,
  reviewer,
  onTagClick
}) => {
  const [ratings, setRatings] = useState<Record<VoteCategory, boolean>>({});
  const [reviewCount, setReviewCount] = useState(0);

  if (!isOpen) return null;

  const displayPhrase = isEditing ? editedPhrase : phrases[currentIndex];
  if (!displayPhrase) return null;

  const handleVote = async (field: VoteCategory, isLike: boolean) => {
    if (!reviewer || !displayPhrase) return;

    try {
      const { error } = await supabase
        .from('votes')
        .insert({
          reviewer_id: reviewer.id,
          phrase_id: displayPhrase.id,
          category: field,
          vote: isLike,
          created_at: new Date().toISOString()
        });

      if (!error) {
        setRatings(prev => ({ ...prev, [field]: isLike }));
        
        // Update reviewer stats
        const { error: reviewerError } = await supabase
          .from('reviewers')
          .update({
            total_reviews: reviewer.total_reviews + 1,
            last_review_at: new Date().toISOString(),
            current_streak: reviewer.current_streak + 1
          })
          .eq('id', reviewer.id);

        if (reviewerError) {
          console.error('Error updating reviewer stats:', reviewerError);
        }
      }
    } catch (err) {
      console.error('Error recording vote:', err);
    }
  };

  const handleEditChange = (field: keyof Phrase) => (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    onEditChange(field, e.target.value);
  };

  const fieldsToRate: VoteCategory[] = ['phrase', 'hint', 'tags', 'difficulty'];
  const isFullyRated = fieldsToRate.every(field => ratings[field] !== undefined);

  const handleNext = () => {
    if (isFullyRated) {
      onNavigate(currentIndex + 1);
      setRatings({});
      setReviewCount(prev => prev + 1);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full max-h-[90vh] overflow-y-auto">
        {/* Modal Header */}
        <div className="flex justify-between items-center mb-4">
          <div>
            <h2 className="text-xl font-bold text-white">Phrase Card Review</h2>
            <span className="text-sm text-gray-400">Reviewed: {reviewCount}</span>
          </div>
          <Button variant="ghost" size="icon" onClick={onClose}>
            <X className="h-5 w-5" />
          </Button>
        </div>

        {/* Navigation */}
        <div className="flex justify-between items-center mb-4">
          <span className="text-sm text-gray-400">
            Phrase {currentIndex + 1} of {phrases.length}
          </span>
          <div className="flex gap-4">
            <Button
              onClick={() => onNavigate(Math.max(0, currentIndex - 1))}
              disabled={currentIndex === 0}
              variant="ghost"
              size="icon"
            >
              <ChevronLeft className="h-5 w-5" />
            </Button>
            <Button
              onClick={() => onNavigate(Math.min(phrases.length - 1, currentIndex + 1))}
              disabled={currentIndex === phrases.length - 1}
              variant="ghost"
              size="icon"
            >
              <ChevronRight className="h-5 w-5" />
            </Button>
          </div>
        </div>

        {/* Fields */}
        <div className="space-y-4">
          <Field
            label="Phrase"
            value={displayPhrase.phrase}
            onChange={handleEditChange('phrase')}
            isEditing={isEditing}
            onVote={!isEditing ? (isLike) => handleVote('phrase', isLike) : undefined}
            rating={ratings['phrase']}
            showVoting={!isEditing}
          />

          <Field
            label="Category"
            value={displayPhrase.category}
            onChange={handleEditChange('category')}
            type="select"
            options={categories}
            isEditing={isEditing}
          />

          <Field
            label="Difficulty"
            value={displayPhrase.difficulty}
            onChange={handleEditChange('difficulty')}
            type="select"
            options={difficulties}
            isEditing={isEditing}
            onVote={!isEditing ? (isLike) => handleVote('difficulty', isLike) : undefined}
            rating={ratings['difficulty']}
            showVoting={!isEditing}
          />

          <Field
            label="Tags"
            value={displayPhrase.tags}
            onChange={handleEditChange('tags')}
            type="tags"
            isEditing={isEditing}
            onTagClick={onTagClick}
            onVote={!isEditing ? (isLike) => handleVote('tags', isLike) : undefined}
            rating={ratings['tags']}
            showVoting={!isEditing}
          />

          <Field
            label="Hint"
            value={displayPhrase.hint}
            onChange={handleEditChange('hint')}
            isEditing={isEditing}
            onVote={!isEditing ? (isLike) => handleVote('hint', isLike) : undefined}
            rating={ratings['hint']}
            showVoting={!isEditing}
          />

          <Field
            label="Part of Speech"
            value={displayPhrase.part_of_speech}
            onChange={handleEditChange('part_of_speech')}
            type="select"
            options={partsOfSpeech}
            isEditing={isEditing}
          />
        </div>

        {/* Action Buttons */}
        {isEditing ? (
          <div className="flex justify-end gap-2 mt-6">
            <Button variant="outline" onClick={onCancel}>
              Cancel
            </Button>
            <Button onClick={onSave}>
              Save Changes
            </Button>
          </div>
        ) : (
          <div className="flex justify-between items-center mt-6">
            <Button variant="outline" onClick={onEdit}>
              <Pencil className="h-4 w-4 mr-2" />
              Edit
            </Button>
            {reviewer && (
              <div className="flex items-center gap-4">
                <span className="text-sm text-gray-400">
                  {isFullyRated ? 'All fields rated!' : 'Please rate all fields to continue'}
                </span>
                <Button
                  onClick={handleNext}
                  disabled={!isFullyRated}
                  className={!isFullyRated ? 'bg-gray-600 cursor-not-allowed' : ''}
                >
                  Next
                  <ChevronRight className="h-4 w-4 ml-2" />
                </Button>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default CardViewModal;


============================================================

FILE: .\components\shared\EditPhraseModal.tsx
SIZE: 10.4 KB
LAST MODIFIED: 03/05/2025 15:03:18

import React, { useState, useEffect } from 'react';
import { X, Save } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { supabase } from '@/lib/services/supabase';
import type { Phrase } from '@/types/types';

interface EditPhraseModalProps {
  phrase: Phrase;
  onChange: (updatedPhrase: Phrase) => void;
  onSave: (phrase: Phrase) => Promise<void>;
  onClose: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
}


interface FormErrors {
  [key: string]: string;
}

export const EditPhraseModal: React.FC<EditPhraseModalProps> = ({
  phrase,
  onChange,
  onSave,
  onClose,
  categories,
  difficulties,
  partsOfSpeech
}) => {
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<FormErrors>({});

  // Fetch subcategories when category changes
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!phrase.category) {
        setSubcategories([]);
        return;
      }

      try {
        // Get category_id first
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', phrase.category)
          .single();

        if (categoryData) {
          // Then get subcategories for this category
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');

          if (subcategoryData) {
            setSubcategories(subcategoryData.map(sub => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      }
    };

    fetchSubcategories();
  }, [phrase.category]);

  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};

    if (!phrase.phrase.trim()) {
      newErrors.phrase = 'Phrase is required';
    }

    if (!phrase.category) {
      newErrors.category = 'Category is required';
    }

    if (!phrase.difficulty) {
      newErrors.difficulty = 'Difficulty is required';
    }

    if (!phrase.part_of_speech) {
      newErrors.part_of_speech = 'Part of speech is required';
    }

    if (phrase.tags && !/^[a-zA-Z0-9\s,]+$/.test(phrase.tags)) {
      newErrors.tags = 'Tags can only contain letters, numbers, spaces, and commas';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    // Clear any existing error for this field
    setErrors(prev => ({ ...prev, [name]: '' }));

    // Reset subcategory when category changes
    if (name === 'category') {
      onChange({
        ...phrase,
        [name]: value,
        subcategory: ''
      });
    } else {
      onChange({
        ...phrase,
        [name]: value
      });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setLoading(true);
    try {
      await onSave(phrase);
      onClose();
    } catch (err) {
      console.error('Error saving phrase:', err);
      setErrors(prev => ({
        ...prev,
        submit: 'Failed to save changes. Please try again.'
      }));
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-gray-800 rounded-lg p-6 max-w-2xl w-full">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Edit Phrase</h2>
          <button 
            onClick={onClose}
            className="text-gray-400 hover:text-white transition-colors"
          >
            <X className="h-6 w-6" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Phrase Input */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Phrase
            </label>
            <input
              type="text"
              name="phrase"
              value={phrase.phrase}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.phrase ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            />
            {errors.phrase && (
              <p className="mt-1 text-sm text-red-500">{errors.phrase}</p>
            )}
          </div>

          {/* Category Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Category
            </label>
            <select
              name="category"
              value={phrase.category}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.category ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            >
              <option value="">Select Category</option>
              {categories.map(category => (
                <option key={category} value={category}>{category}</option>
              ))}
            </select>
            {errors.category && (
              <p className="mt-1 text-sm text-red-500">{errors.category}</p>
            )}
          </div>

          {/* Subcategory Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Subcategory
            </label>
            <select
              name="subcategory"
              value={phrase.subcategory || ''}
              onChange={handleChange}
              className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                     text-white focus:ring-2 focus:ring-blue-500"
              disabled={!phrase.category || loading}
            >
              <option value="">Select Subcategory</option>
              {subcategories.map(subcategory => (
                <option key={subcategory} value={subcategory}>{subcategory}</option>
              ))}
            </select>
          </div>

          {/* Difficulty Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Difficulty
            </label>
            <select
              name="difficulty"
              value={phrase.difficulty}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.difficulty ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            >
              <option value="">Select Difficulty</option>
              {difficulties.map(difficulty => (
                <option key={difficulty} value={difficulty}>{difficulty}</option>
              ))}
            </select>
            {errors.difficulty && (
              <p className="mt-1 text-sm text-red-500">{errors.difficulty}</p>
            )}
          </div>

          {/* Tags Input */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Tags (comma separated)
            </label>
            <input
              type="text"
              name="tags"
              value={phrase.tags}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.tags ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            />
            {errors.tags && (
              <p className="mt-1 text-sm text-red-500">{errors.tags}</p>
            )}
          </div>

          {/* Hint Input */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Hint
            </label>
            <input
              type="text"
              name="hint"
              value={phrase.hint || ''}
              onChange={handleChange}
              className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                     text-white focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            />
          </div>

          {/* Part of Speech Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Part of Speech
            </label>
            <select
              name="part_of_speech"
              value={phrase.part_of_speech}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.part_of_speech ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            >
              <option value="">Select Part of Speech</option>
              {partsOfSpeech.map(pos => (
                <option key={pos} value={pos}>{pos}</option>
              ))}
            </select>
            {errors.part_of_speech && (
              <p className="mt-1 text-sm text-red-500">{errors.part_of_speech}</p>
            )}
          </div>

          {errors.submit && (
            <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded">
              {errors.submit}
            </div>
          )}

          <div className="flex justify-end gap-4 mt-6">
            <Button
              type="button"
              variant="outline"
              onClick={onClose}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              disabled={loading}
              className="flex items-center gap-2"
            >
              <Save className="h-4 w-4" />
              {loading ? 'Saving...' : 'Save Changes'}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default EditPhraseModal;


============================================================

FILE: .\components\tables\type.ts
SIZE: 1.19 KB
LAST MODIFIED: 03/10/2025 08:46:50

// src/components/tables/types.ts
export interface SortConfig {
  key: string;
  direction: 'asc' | 'desc';
}

export interface PaginationState {
  currentPage: number;
  totalPages: number;
  rowsPerPage: number;
  totalItems: number;
}

export interface FiltersState {
  search?: string;
  category?: string;
  subcategory?: string;
  difficulty?: number | null;
  tags?: string[];
  [key: string]: any; // Allow for additional filter properties
}

export interface TableState {
  sortConfig: {
    key: string;
    direction: 'asc' | 'desc';
  };
  pagination: {
    currentPage: number;
    rowsPerPage: number;
    totalItems?: number;
    totalPages?: number;
  };
  filters: {
    search?: string;
    [key: string]: any;
  };
  hiddenColumns?: string[]; // Add this for column visibility
}

export interface ColumnDef<T> {
  key: string;
  header: React.ReactNode;
  cell?: (row: T) => React.ReactNode;
  sortable?: boolean;
  className?: string;
  cellClassName?: string;
}

export interface BulkAction {
  label: string;
  icon?: React.ReactNode;
  onClick: () => void;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
}

============================================================

FILE: .\components\tables\data-table\columns.tsx
SIZE: 3.86 KB
LAST MODIFIED: 03/09/2025 15:23:01

// src/components/phrases/phrases-table/columns.tsx
import React from 'react';
import { cn } from '@/lib/utils';
import TagDisplay from '@/components/common/TagDisplay';
import { ColumnDef } from '@/components/tables/types';
import { ChevronUp, ChevronDown } from 'lucide-react';

// Define the Phrase type
export interface Phrase {
  id: number | string;
  phrase: string;
  category: string;
  difficulty: number;
  tags: string[];
  hint?: string;
  [key: string]: any;
}

// Difficulty label mapping
export const difficultyLabels: Record<number, string> = {
  1: 'Easy',
  2: 'Medium',
  3: 'Hard',
};

// Function to get the appropriate color for difficulty level
export const getDifficultyColor = (difficulty: number | null | undefined): string => {
  if (difficulty === null || difficulty === undefined) {
    return 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
  }

  switch (difficulty) {
    case 1: // Easy
      return 'bg-[#EEEEEE] text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    case 2: // Medium
      return 'bg-[#AAAAAA] text-white dark:bg-gray-600 dark:text-gray-200';
    case 3: // Hard
      return 'bg-[#666666] text-white dark:bg-gray-800 dark:text-gray-100';
    default:
      return 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
  }
};

// Define column configuration for phrases
export const getPhrasesColumns = (sortConfig: { key: string; direction: 'asc' | 'desc' }): ColumnDef<Phrase>[] => [
  { 
    key: 'id', 
    header: (
      <div className="flex items-center gap-2">
        ID
        {sortConfig.key === 'id' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cellClassName: 'text-muted-foreground'
  },
  { 
    key: 'phrase', 
    header: (
      <div className="flex items-center gap-2">
        Phrase
        {sortConfig.key === 'phrase' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
  },
  { 
    key: 'category', 
    header: (
      <div className="flex items-center gap-2">
        Category
        {sortConfig.key === 'category' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cellClassName: 'text-muted-foreground'
  },
  { 
    key: 'difficulty', 
    header: (
      <div className="flex items-center gap-2">
        Difficulty
        {sortConfig.key === 'difficulty' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cell: (row) => (
      <span className={cn(
        "px-2 py-1 rounded-full text-xs",
        getDifficultyColor(row.difficulty)
      )}>
        {difficultyLabels[row.difficulty] || '-'}
      </span>
    )
  },
  { 
    key: 'tags', 
    header: (
      <div className="flex items-center gap-2">
        Tags
        {sortConfig.key === 'tags' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cell: (row) => <TagDisplay tags={row.tags} />
  },
  { 
    key: 'hint', 
    header: (
      <div className="flex items-center gap-2">
        Hint
        {sortConfig.key === 'hint' && (
          sortConfig.direction === 'asc' 
            ? <ChevronUp className="w-4 h-4" />
            : <ChevronDown className="w-4 h-4" />
        )}
      </div>
    ),
    cellClassName: 'text-muted-foreground',
    cell: (row) => row.hint || '-'
  },
];

============================================================

FILE: .\components\tables\data-table\filters.tsx
SIZE: 0 KB
LAST MODIFIED: 03/11/2025 21:31:33


============================================================

FILE: .\components\tables\data-table\header.tsx
SIZE: 0.3 KB
LAST MODIFIED: 03/10/2025 08:37:13

// src/components/tables/data-table/header.tsx
import React from 'react';

interface DataTableHeaderProps {
  children: React.ReactNode;
}

export function DataTableHeader({ children }: DataTableHeaderProps) {
  return (
    <div className="data-table-header">
      {children}
    </div>
  );
}

============================================================

FILE: .\components\tables\data-table\index.tsx
SIZE: 6.91 KB
LAST MODIFIED: 03/11/2025 21:31:25

// src/components/tables/data-table/index.tsx
import React, { useState, useEffect } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Checkbox } from "@/components/ui/checkbox";
import { DataTablePagination } from "./pagination";
import { DataTableToolbar } from "./toolbar";
import { cn } from "@/lib/utils";
import { ColumnDef, TableState } from "../types";

interface DataTableProps<T> {
  data: T[];
  columns: ColumnDef<T>[];
  tableState?: TableState;
  sortConfig?: { key: string; direction: 'asc' | 'desc' };
  onSortChange?: (key: string) => void;
  onRowSelect?: (rowId: string | number) => void;
  onSelectAll?: () => void;
  selectedRows?: (string | number)[];
  bulkActions?: React.ReactNode;
  rowActions?: (row: T) => React.ReactNode;
  highlightedRows?: (string | number)[];
  getRowId: (row: T) => string | number;
  isLoading?: boolean;
  onShowAdvancedFilters?: () => void;
  hiddenColumns?: string[];
  children?: React.ReactNode;
}

export function DataTable<T>({
  data,
  columns,
  tableState,
  sortConfig,
  onSortChange,
  onRowSelect,
  onSelectAll,
  selectedRows = [],
  bulkActions,
  rowActions,
  highlightedRows = [],
  getRowId,
  isLoading = false,
  onShowAdvancedFilters,
  hiddenColumns = [],
  children
}: DataTableProps<T>) {
  const [showSelection, setShowSelection] = useState(!!onRowSelect);

  // Use sortConfig from props if provided, otherwise from tableState
  const effectiveSortConfig = sortConfig || tableState?.sortConfig;

  // Log state changes for debugging
  useEffect(() => {
    console.log('TableState updated:', tableState);
  }, [tableState]);

  // Ensure totalItems and totalPages are properly set
  useEffect(() => {
    if (!isLoading && tableState && data.length > 0) {
      if (!tableState.pagination.totalItems) {
        console.log('Setting totalItems from data length:', data.length);
        onSortChange && onSortChange(effectiveSortConfig?.key || '');
      }
    }
  }, [data, isLoading]);

  const handleSort = (key: string) => {
    onSortChange && onSortChange(key);
  };

  // Filter visible columns
  const visibleColumns = columns.filter(column => 
    !hiddenColumns.includes(column.key)
  );

  // For debugging
  const debugInfo = {
    dataLength: data.length,
    isLoading,
    rowsPerPage: tableState?.pagination?.rowsPerPage || 10,
    currentPage: tableState?.pagination?.currentPage || 1,
    totalItems: tableState?.pagination?.totalItems || data.length,
    totalPages: tableState?.pagination?.totalPages || Math.ceil(data.length / 10),
    selectedRows: selectedRows.length
  };

  return (
    <div className="rounded-lg border">
      {/* Add debugging info - remove in production */}
      {process.env.NODE_ENV === 'development' && false && (
        <div className="p-2 text-xs bg-amber-100 text-amber-900">
          <pre>{JSON.stringify(debugInfo, null, 2)}</pre>
        </div>
      )}
      
      {/* Custom header/toolbar area */}
      {children}

      {/* Table */}
      <div className="overflow-x-auto">
        <Table>
          <TableHeader>
            <TableRow>
              {/* Select All Checkbox */}
              {onRowSelect && onSelectAll && (
                <TableHead className="w-12">
                  <Checkbox 
                    checked={data.length > 0 && selectedRows.length === data.length}
                    indeterminate={selectedRows.length > 0 && selectedRows.length < data.length}
                    onCheckedChange={onSelectAll}
                    aria-label="Select all"
                  />
                </TableHead>
              )}
              
              {/* Only render visible columns */}
              {visibleColumns.map((column) => (
                <TableHead 
                  key={column.key}
                  onClick={() => column.sortable !== false && handleSort(column.key)}
                  className={cn(
                    column.sortable !== false && "cursor-pointer",
                    column.className
                  )}
                >
                  <div className="flex items-center gap-2">
                    {column.header}
                  </div>
                </TableHead>
              ))}
              
              {/* Actions column */}
              {rowActions && <TableHead className="w-10"></TableHead>}
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell 
                  colSpan={visibleColumns.length + (onRowSelect ? 1 : 0) + (rowActions ? 1 : 0)} 
                  className="text-center h-24"
                >
                  Loading...
                </TableCell>
              </TableRow>
            ) : data.length === 0 ? (
              <TableRow>
                <TableCell 
                  colSpan={visibleColumns.length + (onRowSelect ? 1 : 0) + (rowActions ? 1 : 0)} 
                  className="text-center h-24"
                >
                  No data found
                </TableCell>
              </TableRow>
            ) : (
              data.map((row) => {
                const rowId = getRowId(row);
                return (
                  <TableRow 
                    key={rowId}
                    className={cn(
                      highlightedRows.includes(rowId) ? 'animate-flash' : '',
                      selectedRows.includes(rowId) ? 'bg-muted' : ''
                    )}
                    data-state={selectedRows.includes(rowId) ? 'selected' : undefined}
                  >
                    {/* Row Selection Checkbox */}
                    {onRowSelect && (
                      <TableCell className="w-12">
                        <Checkbox 
                          checked={selectedRows.includes(rowId)}
                          onCheckedChange={() => onRowSelect(rowId)}
                          aria-label={`Select row ${rowId}`}
                        />
                      </TableCell>
                    )}
                    
                    {/* Data cells - only render visible columns */}
                    {visibleColumns.map((column) => (
                      <TableCell key={column.key} className={column.cellClassName}>
                        {column.cell ? column.cell(row) : row[column.key as keyof T]}
                      </TableCell>
                    ))}
                    
                    {/* Row actions */}
                    {rowActions && (
                      <TableCell className="text-right">
                        {rowActions(row)}
                      </TableCell>
                    )}
                  </TableRow>
                );
              })
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}

============================================================

FILE: .\components\tables\data-table\pagination.tsx
SIZE: 2.22 KB
LAST MODIFIED: 03/11/2025 21:31:41

// src/components/tables/data-table/pagination.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { TableState } from '../types';

interface DataTablePaginationProps {
  tableState: TableState;
  onTableStateChange: (state: Partial<TableState>) => void;
  selectedCount?: number;
  itemCount?: number;
}

export function DataTablePagination({
  tableState,
  onTableStateChange,
  selectedCount = 0,
  itemCount
}: DataTablePaginationProps) {
  const { pagination } = tableState;
  
  // For calculating what we're showing
  const totalItems = pagination.totalItems || 0;
  const currentPage = pagination.currentPage || 1;
  const rowsPerPage = pagination.rowsPerPage || 10;
  
  // Use the actual data count for accuracy
  const actualCount = itemCount !== undefined ? itemCount : 0;
  
  // Calculate display values
  const start = totalItems === 0 ? 0 : (currentPage - 1) * rowsPerPage + 1;
  const end = Math.min(totalItems, currentPage * rowsPerPage);
  
  const handlePageChange = (newPage: number) => {
    // Log for debugging
    console.log('Changing page (bottom pagination) to:', newPage);
    
    onTableStateChange({
      pagination: {
        ...pagination,
        currentPage: newPage
      }
    });
  };

  return (
    <div className="p-4 border-t flex justify-between items-center">
      <span className="text-sm text-muted-foreground">
        {totalItems === 0 
          ? 'No results' 
          : `Showing ${start}-${end} of ${totalItems}`}
        {selectedCount > 0 && ` â€¢ ${selectedCount} selected`}
      </span>
      
      <div className="flex gap-2">
        <Button
          onClick={() => handlePageChange(pagination.currentPage - 1)}
          disabled={pagination.currentPage <= 1}
          variant="outline"
          size="sm"
          className="rounded-md"
        >
          Previous
        </Button>
        <Button
          onClick={() => handlePageChange(pagination.currentPage + 1)}
          disabled={pagination.currentPage >= pagination.totalPages}
          variant="outline"
          size="sm"
          className="rounded-md"
        >
          Next
        </Button>
      </div>
    </div>
  );
}

============================================================

FILE: .\components\tables\data-table\row-actions.tsx
SIZE: 1.99 KB
LAST MODIFIED: 03/09/2025 15:23:08

// src/components/phrases/phrases-table/actions.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { Trash2, Pencil, MoreHorizontal } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Phrase } from './columns';

interface RowActionsProps {
  phrase: Phrase;
  onEdit: (phrase: Phrase) => void;
  onDelete: (id: string | number) => void;
}

export function PhraseRowActions({ phrase, onEdit, onDelete }: RowActionsProps) {
  const handleDelete = () => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      onDelete(phrase.id);
    }
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="h-8 w-8 p-0">
          <span className="sr-only">Open menu</span>
          <MoreHorizontal className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuLabel>Actions</DropdownMenuLabel>
        <DropdownMenuItem onClick={() => onEdit(phrase)}>
          <Pencil className="mr-2 h-4 w-4" />
          Edit
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem 
          onClick={handleDelete}
          className="text-red-600"
        >
          <Trash2 className="mr-2 h-4 w-4" />
          Delete
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

interface BulkActionsProps {
  selectedCount: number;
  onDelete: () => void;
}

export function PhraseBulkActions({ selectedCount, onDelete }: BulkActionsProps) {
  return (
    <Button 
      variant="destructive" 
      size="sm" 
      onClick={onDelete}
      className="flex items-center gap-1"
    >
      <Trash2 className="h-4 w-4" />
      Delete {selectedCount} selected
    </Button>
  );
}

============================================================

FILE: .\components\tables\data-table\toolbar.tsx
SIZE: 7.51 KB
LAST MODIFIED: 03/11/2025 21:31:38

import React from 'react';
import { Button } from '@/components/ui/button';
import { Filter, Columns } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { X } from 'lucide-react';
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { TableState } from '../types';

interface DataTableToolbarProps {
  tableState: TableState;
  onTableStateChange: (state: Partial<TableState>) => void;
  selectedRows: (string | number)[];
  bulkActions?: React.ReactNode;
  showSelection?: boolean;
  onShowAdvancedFilters?: () => void;
  columns?: any[]; // Add column definition props for column visibility
}

export function DataTableToolbar({
  tableState,
  onTableStateChange,
  selectedRows,
  bulkActions,
  showSelection = false,
  onShowAdvancedFilters,
  columns
}: DataTableToolbarProps) {
  const { pagination, filters } = tableState;

  // Handle search input changes
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    
    // Apply filter immediately
    onTableStateChange({
      filters: {
        ...tableState.filters,
        search: value
      },
      pagination: {
        ...tableState.pagination,
        currentPage: 1 // Reset to first page when filtering
      }
    });
  };

  // Clear search
  const clearSearch = () => {
    onTableStateChange({
      filters: {
        ...tableState.filters,
        search: ''
      }
    });
  };

  const handleRowsPerPageChange = (value: string) => {
    // Convert value to number
    const newRowsPerPage = parseInt(value, 10);
    
    // Log for debugging
    console.log('Changing rows per page to:', newRowsPerPage);
    
    // Update page state
    onTableStateChange({
      pagination: {
        ...pagination,
        rowsPerPage: newRowsPerPage,
        currentPage: 1 // Reset to first page when changing rows per page
      }
    });
  };

  const handlePageChange = (newPage: number) => {
    // Log for debugging
    console.log('Changing page to:', newPage);
    
    onTableStateChange({
      pagination: {
        ...pagination,
        currentPage: newPage
      }
    });
  };

  return (
    <div className="p-4 border-b">
      {/* Top row with search and column visibility */}
      <div className="flex flex-wrap justify-between items-center gap-4 mb-4">
        {/* Search input */}
        <div className="relative w-full md:w-80">
          <Input
            placeholder="Search phrases..."
            value={filters.search || ''}
            onChange={handleSearchChange}
            className="w-full"
          />
          {filters.search && (
            <Button
              variant="ghost"
              onClick={clearSearch}
              className="absolute right-0 top-0 h-full px-3"
              type="button"
            >
              <X className="h-4 w-4" />
              <span className="sr-only">Clear</span>
            </Button>
          )}
        </div>

        <div className="flex gap-2 items-center">
          {/* Column visibility dropdown */}
          {columns && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="sm" className="ml-auto">
                  <Columns className="h-4 w-4 mr-2" />
                  Columns
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {columns.map((column) => {
                  // Skip action columns or any column you don't want to hide
                  if (column.key === 'actions') return null;
                  
                  return (
                    <DropdownMenuCheckboxItem
                      key={column.key}
                      className="capitalize"
                      checked={!tableState.hiddenColumns?.includes(column.key)}
                      onCheckedChange={(value) => {
                        // Update hidden columns list
                        let newHiddenColumns = [...(tableState.hiddenColumns || [])];
                        if (value) {
                          // Remove from hidden list
                          newHiddenColumns = newHiddenColumns.filter(key => key !== column.key);
                        } else {
                          // Add to hidden list
                          newHiddenColumns.push(column.key);
                        }
                        
                        onTableStateChange({
                          hiddenColumns: newHiddenColumns
                        });
                      }}
                    >
                      {column.header}
                    </DropdownMenuCheckboxItem>
                  );
                })}
              </DropdownMenuContent>
            </DropdownMenu>
          )}
          
          {/* Advanced filters button */}
          {!showSelection && onShowAdvancedFilters && (
            <Button 
              variant="outline" 
              size="sm" 
              className="flex items-center gap-1"
              onClick={onShowAdvancedFilters}
            >
              <Filter className="h-4 w-4" />
              Filters
            </Button>
          )}
        </div>
      </div>

      {/* Bottom row with pagination controls */}
      <div className="flex flex-wrap justify-between items-center gap-4">
        <div className="flex items-center gap-4">
          {/* Show bulk actions when rows are selected */}
          {showSelection ? (
            <div className="flex gap-2">
              {bulkActions}
            </div>
          ) : (
            <>
              {/* Rows per page selector */}
              <Select
                value={pagination.rowsPerPage.toString()}
                onValueChange={handleRowsPerPageChange}
              >
                <SelectTrigger className="w-[120px]">
                  <SelectValue placeholder={`${pagination.rowsPerPage} per page`} />
                </SelectTrigger>
                <SelectContent>
                  {[10, 25, 50, 100].map(value => (
                    <SelectItem key={value} value={value.toString()}>
                      {value} per page
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              
              <span className="text-sm text-muted-foreground">
                {pagination.totalPages > 0
                  ? `Page ${pagination.currentPage} of ${pagination.totalPages}`
                  : 'No results'
                }
              </span>
            </>
          )}
        </div>
        
        {/* Pagination Controls */}
        <div className="flex gap-2">
          <Button
            onClick={() => handlePageChange(pagination.currentPage - 1)}
            disabled={pagination.currentPage <= 1}
            variant="outline"
            size="sm"
          >
            Previous
          </Button>
          <Button
            onClick={() => handlePageChange(pagination.currentPage + 1)}
            disabled={pagination.currentPage >= pagination.totalPages}
            variant="outline"
            size="sm"
          >
            Next
          </Button>
        </div>
      </div>
    </div>
  );
}

============================================================

FILE: .\components\ui\alert.tsx
SIZE: 2.23 KB
LAST MODIFIED: 02/09/2025 10:34:20

import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-gray-800 border-gray-700 text-white",
        destructive: "border-red-700 bg-red-900/50 text-red-100 [&>svg]:text-red-100",
        success: "border-green-700 bg-green-900/50 text-green-100 [&>svg]:text-green-100",
        warning: "border-yellow-700 bg-yellow-900/50 text-yellow-100 [&>svg]:text-yellow-100",
        info: "border-blue-700 bg-blue-900/50 text-blue-100 [&>svg]:text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> &
    VariantProps<typeof alertVariants> & {
      onClose?: () => void;
    }
>(({ className, variant, children, onClose, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  >
    {children}
    {onClose && (
      <button
        onClick={onClose}
        className="absolute top-4 right-4 p-1 rounded-full hover:bg-gray-700/50 transition-colors"
        aria-label="Close alert"
      >
        <X className="h-4 w-4" />
      </button>
    )}
  </div>
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

============================================================

FILE: .\components\ui\button.tsx
SIZE: 1.69 KB
LAST MODIFIED: 02/09/2025 10:32:42

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-blue-500 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-blue-600 text-white hover:bg-blue-700",
        destructive: "bg-red-600 text-white hover:bg-red-700",
        outline: "border border-gray-600 bg-transparent hover:bg-gray-700 hover:text-white",
        secondary: "bg-gray-600 text-white hover:bg-gray-700",
        ghost: "hover:bg-gray-700 hover:text-white",
        link: "text-blue-500 underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };

============================================================

FILE: .\components\ui\card.tsx
SIZE: 1.79 KB
LAST MODIFIED: 03/04/2025 21:20:49

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


============================================================

FILE: .\components\ui\chart.tsx
SIZE: 2.92 KB
LAST MODIFIED: 03/07/2025 09:03:03

// components/ui/chart.tsx

"use client"

import * as React from "react"
import { Line, LineChart, ResponsiveContainer, Tooltip } from "recharts"

export type ChartConfig = {
  [key: string]: {
    label: string
    color: string
  }
}

export function ChartContainer({
  config,
  children,
  className,
  ...props
}: React.PropsWithChildren & {
  config: ChartConfig
  className?: string
  [key: string]: any
}) {
  const createCSSVariable = (obj: Record<string, string>) => {
    return Object.entries(obj).reduce((vars, [key, value]) => {
      return {
        ...vars,
        [`--color-${key}`]: value,
      }
    }, {})
  }

  const colors = Object.entries(config).reduce((colors, [key, item]) => {
    return {
      ...colors,
      [key]: item.color,
    }
  }, {})

  const cssVars = createCSSVariable(colors)

  return (
    <div style={cssVars} className={className} {...props}>
      {children}
    </div>
  )
}

export function ChartTooltipContent({
  active,
  payload,
  label,
  config,
  indicator = "circle",
}: {
  active?: boolean
  payload?: any[]
  label?: string
  config?: ChartConfig
  indicator?: "circle" | "line"
}) {
  const TypeIndicator = ({ name }: { name: string }) =>
    indicator === "circle" ? (
      <circle
        cx="6.5"
        cy="6.5"
        r="3.5"
        fill={`var(--color-${name})`}
      />
    ) : (
      <line
        x1="1"
        y1="6.5"
        x2="9"
        y2="6.5"
        stroke={`var(--color-${name})`}
        strokeWidth={2}
        strokeLinecap="round"
      />
    )

  if (!active || !payload) return null

  return (
    <div className="rounded-lg border bg-background p-2 shadow-sm">
      <div className="grid grid-cols-2 gap-2">
        <div className="flex flex-col">
          <span className="text-[0.70rem] uppercase text-muted-foreground">
            {label}
          </span>
        </div>
        <div className="flex flex-col gap-1">
          {payload.map(({ value, name }) => (
            <div key={name} className="flex items-center justify-end gap-1">
              <span className="text-[0.70rem] text-muted-foreground">
                {config?.[name]?.label ?? name}
              </span>
              <span className="font-bold tabular-nums">{value}</span>
              {config?.[name] && (
                <svg
                  width="13"
                  height="13"
                  viewBox="0 0 13 13"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <TypeIndicator name={name} />
                </svg>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

export function ChartTooltip({
  content,
  ...props
}: {
  content?: React.JSXElementConstructor<any>
  [key: string]: any
}) {
  return <Tooltip {...props} content={content} />
}

============================================================

FILE: .\components\ui\checkbox.tsx
SIZE: 1.07 KB
LAST MODIFIED: 03/07/2025 17:11:30

"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

============================================================

FILE: .\components\ui\dialog.tsx
SIZE: 4.78 KB
LAST MODIFIED: 02/09/2025 15:31:45

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-700 bg-gray-800 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-gray-800 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-gray-700 data-[state=open]:text-gray-400">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-400", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

/* Example usage:
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function DialogDemo() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="outline">Edit Profile</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit profile</DialogTitle>
          <DialogDescription>
            Make changes to your profile here.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          Form content here
        </div>
        <DialogFooter>
          <Button type="submit">Save changes</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
*/

============================================================

FILE: .\components\ui\dropdown-menu.tsx
SIZE: 7.37 KB
LAST MODIFIED: 03/07/2025 08:43:08

// components/ui/dropdown-menu.tsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

============================================================

FILE: .\components\ui\input.tsx
SIZE: 0.75 KB
LAST MODIFIED: 03/04/2025 21:21:03

import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


============================================================

FILE: .\components\ui\label.tsx
SIZE: 0.71 KB
LAST MODIFIED: 03/04/2025 21:21:19

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


============================================================

FILE: .\components\ui\modal.tsx
SIZE: 3.93 KB
LAST MODIFIED: 02/09/2025 10:34:53

import * as React from "react";
import { X } from "lucide-react";
import { Button } from "./button";
import { cn } from "@/lib/utils";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: React.ReactNode;
  children: React.ReactNode;
  footer?: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  className?: string;
  showClose?: boolean;
  closeOnOverlayClick?: boolean;
}

const sizeClasses = {
  sm: 'max-w-sm',
  md: 'max-w-md',
  lg: 'max-w-lg',
  xl: 'max-w-xl',
  full: 'max-w-full mx-4'
};

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  size = 'md',
  className,
  showClose = true,
  closeOnOverlayClick = true,
}) => {
  // Handle ESC key
  React.useEffect(() => {
    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener('keydown', handleEsc);
    }
    return () => {
      document.removeEventListener('keydown', handleEsc);
    };
  }, [isOpen, onClose]);

  // Prevent body scroll when modal is open
  React.useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50"
      onClick={closeOnOverlayClick ? onClose : undefined}
    >
      <div
        className={cn(
          "relative bg-gray-800 rounded-lg shadow-xl w-full",
          sizeClasses[size],
          className
        )}
        onClick={e => e.stopPropagation()}
      >
        {/* Header */}
        {(title || showClose) && (
          <div className="flex items-center justify-between p-4 border-b border-gray-700">
            {title && (
              <h2 className="text-lg font-semibold text-white">
                {title}
              </h2>
            )}
            {showClose && (
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 rounded-full"
                onClick={onClose}
                aria-label="Close modal"
              >
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
        )}

        {/* Content */}
        <div className="p-4">
          {children}
        </div>

        {/* Footer */}
        {footer && (
          <div className="flex justify-end gap-2 p-4 border-t border-gray-700">
            {footer}
          </div>
        )}
      </div>
    </div>
  );
};

// Utility components for Modal
export const ModalTitle: React.FC<React.HTMLAttributes<HTMLHeadingElement>> = ({
  children,
  className,
  ...props
}) => (
  <h2
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  >
    {children}
  </h2>
);

export const ModalDescription: React.FC<React.HTMLAttributes<HTMLParagraphElement>> = ({
  children,
  className,
  ...props
}) => (
  <p
    className={cn("text-sm text-gray-400", className)}
    {...props}
  >
    {children}
  </p>
);

export const ModalFooter: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({
  children,
  className,
  ...props
}) => (
  <div
    className={cn(
      "flex justify-end gap-2",
      className
    )}
    {...props}
  >
    {children}
  </div>
);

// Example usage:
/*
<Modal
  isOpen={isOpen}
  onClose={onClose}
  title="Modal Title"
  footer={
    <>
      <Button variant="outline" onClick={onClose}>
        Cancel
      </Button>
      <Button onClick={handleConfirm}>
        Confirm
      </Button>
    </>
  }
>
  <p>Modal content goes here</p>
</Modal>
*/

============================================================

FILE: .\components\ui\select.tsx
SIZE: 5.51 KB
LAST MODIFIED: 03/04/2025 21:25:38

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


============================================================

FILE: .\components\ui\stat-card.tsx
SIZE: 1.61 KB
LAST MODIFIED: 03/04/2025 21:07:38

// components/ui/stat-card.tsx
import React from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { cn } from "@/lib/utils"

interface StatCardProps extends React.HTMLAttributes<HTMLDivElement> {
  title: string
  value: string | number
  description?: string
  icon?: React.ReactNode
  trend?: {
    value: number
    label: string
    direction: "up" | "down" | "neutral"
  }
}

export function StatCard({
  title,
  value,
  description,
  icon,
  trend,
  className,
  ...props
}: StatCardProps) {
  const trendColors = {
    up: "text-green-500",
    down: "text-red-500",
    neutral: "text-gray-500",
  }

  return (
    <Card className={cn("overflow-hidden", className)} {...props}>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        {icon && <div className="h-4 w-4 text-muted-foreground">{icon}</div>}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground">{description}</p>
        )}
        {trend && (
          <div className={cn("flex items-center text-xs mt-1", trendColors[trend.direction])}>
            {trend.direction === "up" ? "â†‘" : trend.direction === "down" ? "â†“" : "â†’"}
            <span className="ml-1">{trend.value}%</span>
            <span className="ml-1 text-muted-foreground">{trend.label}</span>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

============================================================

FILE: .\components\ui\table.tsx
SIZE: 2.79 KB
LAST MODIFIED: 03/04/2025 21:21:35

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


============================================================

FILE: .\components\ui\tabs.tsx
SIZE: 1.88 KB
LAST MODIFIED: 03/12/2025 09:01:44

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

============================================================

FILE: .\components\ui\toast.tsx
SIZE: 4.88 KB
LAST MODIFIED: 02/09/2025 10:39:17

import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border-gray-700 bg-gray-800 text-white",
        destructive: "destructive group border-red-700 bg-red-900 text-red-100",
        success: "border-green-700 bg-green-900 text-green-100",
        warning: "border-yellow-700 bg-yellow-900 text-yellow-100",
        info: "border-blue-700 bg-blue-900 text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-gray-700 bg-transparent px-3 text-sm font-medium transition-colors hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-red-700 group-[.destructive]:hover:border-red-600 group-[.destructive]:hover:bg-red-600 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-white/50 opacity-0 transition-opacity hover:text-white focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

============================================================

FILE: .\components\ui\toaster.tsx
SIZE: 1.3 KB
LAST MODIFIED: 02/09/2025 10:39:36

import {
    Toast,
    ToastClose,
    ToastDescription,
    ToastProvider,
    ToastTitle,
    ToastViewport,
  } from "@/components/ui/toast";
  import { useToast } from "@/hooks/useToast";
  
  export function Toaster() {
    const { toasts } = useToast();
  
    return (
      <ToastProvider>
        {toasts.map(function ({ id, title, description, action, ...props }) {
          return (
            <Toast key={id} {...props}>
              <div className="grid gap-1">
                {title && <ToastTitle>{title}</ToastTitle>}
                {description && (
                  <ToastDescription>{description}</ToastDescription>
                )}
              </div>
              {action}
              <ToastClose />
            </Toast>
          );
        })}
        <ToastViewport />
      </ToastProvider>
    );
  }
  
  // Example usage:
  /*
  import { useToast } from '@/hooks/useToast';
  
  function MyComponent() {
    const { toast } = useToast();
    
    const showToast = () => {
      toast({
        title: "Success!",
        description: "Your action was completed successfully.",
        variant: "success", // or "default", "destructive", "warning", "info"
      });
    };
  
    return <button onClick={showToast}>Show Toast</button>;
  }
  */

============================================================

FILE: .\features\all-files-root-subs.ps1
SIZE: 1.8 KB
LAST MODIFIED: 03/15/2025 17:12:05

# PowerShell script to combine all files into a single text document
# This script will scan the current directory and all subdirectories

# Define the output file path
$outputFile = ".\CombinedFiles.txt"

# Clear the output file if it already exists
if (Test-Path $outputFile) {
    Remove-Item $outputFile -Force
}

# Get all files recursively from the current directory
$files = Get-ChildItem -Path .\ -Recurse -File

# Initialize counter for processed files
$processedCount = 0
$totalFiles = $files.Count

Write-Host "Found $totalFiles files to process..."

# Process each file
foreach ($file in $files) {
    try {
        # Add file header to the combined file
        $separator = "=" * 80
        $fileHeader = "`n$separator`nFILE: $($file.FullName)`n$separator`n"
        Add-Content -Path $outputFile -Value $fileHeader

        # Try to read the file as text and add its content
        $content = Get-Content -Path $file.FullName -Raw -ErrorAction SilentlyContinue
        if ($null -ne $content) {
            Add-Content -Path $outputFile -Value $content -ErrorAction SilentlyContinue
        }
        else {
            Add-Content -Path $outputFile -Value "[Binary file or empty file]"
        }
        
        # Update counter and show progress
        $processedCount++
        if ($processedCount % 10 -eq 0) {
            Write-Host "Processed $processedCount of $totalFiles files..."
        }
    }
    catch {
        # Log errors for problematic files
        Add-Content -Path $outputFile -Value "[Error reading file: $($_.Exception.Message)]"
        Write-Host "Error processing $($file.FullName): $($_.Exception.Message)" -ForegroundColor Red
    }
}

Write-Host "Completed! All $processedCount files have been combined into $outputFile" -ForegroundColor Green

============================================================

FILE: .\features\dashboard\Dashboard.tsx
SIZE: 32.4 KB
LAST MODIFIED: 03/15/2025 17:14:24

'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useTheme } from 'next-themes';
import { saveAs } from 'file-saver';
import styles from '@/features/dashboard/styles/Dashboard.module.css';
import { cn } from "@/lib/utils";

// Services
import { supabase } from '@/lib/services/supabase';

// Feature Components - These should be moved to the features directory
import { DashboardHeader } from '@/features/dashboard/components/DashboardHeader';
import { StatsCards } from '@/features/dashboard/components/StatsCards';
import { AnalyticsCharts } from '@/features/dashboard/components/AnalyticsCharts';
import { PhraseSearch } from '@/features/dashboard/components/PhraseSearch';

// Components from other features - Consider moving these
import { PhrasesTable } from '@/features/phrases/components/PhrasesTable'; // Move from @/components/phrases/phrases-table
import { BulkImportForm } from '@/features/phrases/components/BulkImportForm'; // Move from @/components/shared/BulkImportForm
import { FilterModal } from '@/features/phrases/components/FilterModal'; // Move from @/components/common/FilterModal
import { ExportModal } from '@/features/dashboard/components/ExportModal'; // Move from @/components/common/ExportModal

// UI Components - These can stay in @/components/ui
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from '@/components/ui/input';

// Data Table Components - These should be moved to @/components/ui/data-table
import { DataTableFilters } from '@/components/ui/data-table/filters'; // Move from @/components/tables/data-table/filters

// External Libraries - These are fine as is
import {
  RadialBarChart, RadialBar, BarChart, Bar, PieChart, Pie, LineChart, Line,
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell,
  RadarChart, Radar, PolarGrid, PolarAngleAxis, PolarRadiusAxis
} from 'recharts';

// Icons - These are fine as is
import {
  FileText, Users, Award, Moon, Sun, Filter, TrendingUp,
  BarChart2, PieChartIcon, FileDownIcon, X
} from "lucide-react";

// Hooks - Move these to appropriate locations
import { useStats } from '@/hooks/dashboard/useStats'; // Update from @/hooks/use-data/useStats
import { usePhrases } from '@/hooks/phrases/usePhrases'; // Update from @/hooks/use-data/usePhrases
import { usePhraseMetadata } from '@/hooks/phrases/usePhraseMetadata'; // Update from @/hooks/use-data/usePhraseMetadata
import { useReviewers } from '@/hooks/reviewers/useReviewers'; // Update from @/hooks/use-data/useReviewers

const CleanDashboard = () => {
  const router = useRouter();
  const { theme, setTheme } = useTheme();

  // State
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [activeTab, setActiveTab] = useState('phrases');
  const [showFilterModal, setShowFilterModal] = useState(false);
  const [subcategories, setSubcategories] = useState([]);
  const [phrasesOverTime, setPhrasesOverTime] = useState([]);
  const [showExportModal, setShowExportModal] = useState(false);
  const [isExporting, setIsExporting] = useState(false);

  // Hooks
  const { stats, loading: statsLoading } = useStats();
  const { reviewers } = useReviewers();
  const {
    phrases,
    loading: phrasesLoading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    editPhrase,
    deletePhrase,
    resetFilters,
  } = usePhrases();
  const { categories, difficulties, partsOfSpeech } = usePhraseMetadata();

  // Table State
  const [tableState, setTableState] = useState({
    sortConfig,
    pagination: {
      ...pagination,
      rowsPerPage: 10,
      totalItems: phrases?.length || 0,
      totalPages: Math.ceil((phrases?.length || 0) / 10),
    },
    filters,
  });

  // Words Added Data for the radial chart
  const wordsAddedData = [
    { name: "Words Added", value: 45, fill: "hsl(var(--primary))" },
    { name: "Goal", value: 100, fill: "hsl(var(--muted))" },
  ];

  // Effect to hide any debug JSON output
  useEffect(() => {
    // Find and hide pre tags with JSON state data
    const preElements = document.querySelectorAll('pre');
    preElements.forEach(el => {
      if (el.textContent && 
          el.textContent.includes('"dataLength":') && 
          el.textContent.includes('"totalItems":')) {
        el.style.display = 'none';
      }
    });
  }, []);

  // Sync Table State with Hook State
  useEffect(() => {
    if (phrases && pagination) {
      setTableState((prev) => ({
        sortConfig,
        pagination: {
          ...pagination,
          totalItems: pagination.totalItems || phrases.length || 0,
          totalPages: pagination.totalPages || Math.ceil((phrases.length || 0) / pagination.rowsPerPage),
        },
        filters,
      }));
    }
  }, [sortConfig, pagination, filters, phrases]);

  // Force rows per page to be 10
  useEffect(() => {
    if (pagination && pagination.rowsPerPage !== 10) {
      console.log('Forcing rows per page to 10');
      handleRowsPerPageChange(10);
    }
  }, [pagination, handleRowsPerPageChange]);

  // Fetch Subcategories
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!filters.category) {
        setSubcategories([]);
        return;
      }

      try {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');

          if (subcategoryData) {
            setSubcategories(subcategoryData.map((sub) => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      }
    };

    fetchSubcategories();
  }, [filters.category]);

  // Fetch phrases over time data
  useEffect(() => {
    fetchPhrasesOverTime();
  }, []);

  // Main function to fetch phrase timestamps
  const fetchPhrasesOverTime = async () => {
    try {
      // Now using the created_at column we added to the phrases table
      const { data, error } = await supabase
        .from('phrases')
        .select('created_at')
        .order('created_at');

      if (error) {
        console.error('Error fetching phrase timestamps:', error);
        setPhrasesOverTime(getErrorStateData());
        return;
      }

      if (data && data.length > 0) {
        const monthlyData = processTimestampData(data);
        setPhrasesOverTime(monthlyData);
      } else {
        setPhrasesOverTime(getErrorStateData());
      }
    } catch (err) {
      console.error('Error fetching phrase timestamps:', err);
      setPhrasesOverTime(getErrorStateData());
    }
  };

  // Process timestamp data into monthly buckets
  const processTimestampData = (data) => {
    const monthCounts = {};

    data.forEach((item) => {
      if (!item.created_at) return;

      const date = new Date(item.created_at);
      const month = date.toLocaleString('default', { month: 'short' });
      const year = date.getFullYear();
      const key = `${month} ${year}`;

      if (!monthCounts[key]) {
        monthCounts[key] = { month, year, count: 0, fullDate: date };
      }
      monthCounts[key].count++;
    });

    // Convert to array, sort by date, and take the most recent 6 months
    return Object.values(monthCounts)
      .sort((a, b) => a.fullDate - b.fullDate)
      .map((item) => ({
        month: item.month,
        year: item.year,
        phrases: item.count,
      }))
      .slice(-6);
  };

  // Generate error state data when no data is available
  const getErrorStateData = () => {
    // Return a special data format that indicates an error condition
    return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'].map((month) => ({
      month,
      year: new Date().getFullYear(),
      phrases: null // Use null to indicate missing/error data
    }));
  };

  // Handle table state changes
  const handleTableStateChange = (updates) => {
    console.log('Table state change requested:', updates);
    
    // Update local state first
    setTableState(prev => ({
      ...prev,
      ...updates
    }));
    
    // Handle filter changes
    if (updates.filters && JSON.stringify(updates.filters) !== JSON.stringify(filters)) {
      console.log('Applying filters:', updates.filters);
      handleFilterChange(updates.filters);
      
      // Reset to page 1 when filtering
      if (pagination.currentPage !== 1) {
        handlePageChange(1);
      }
    }
    
    // Handle sort changes
    if (updates.sortConfig && 
      (updates.sortConfig.key !== sortConfig.key || 
       updates.sortConfig.direction !== sortConfig.direction)) {
      console.log('Updating sort:', updates.sortConfig);
      handleSort(updates.sortConfig.key);
    }
    
    // Handle pagination changes
    if (updates.pagination) {
      // Handle page changes
      if (updates.pagination.currentPage !== undefined && 
          updates.pagination.currentPage !== pagination.currentPage) {
        console.log('Changing page to:', updates.pagination.currentPage);
        handlePageChange(updates.pagination.currentPage);
      }
      
      // Handle rows per page changes
      if (updates.pagination.rowsPerPage !== undefined && 
          updates.pagination.rowsPerPage !== pagination.rowsPerPage) {
        console.log('Changing rows per page to:', updates.pagination.rowsPerPage);
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
    }
  };

  // Generate monthly activity data
  const generateMonthlyActivityData = () => {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
    return months.map(month => ({
      name: month,
      reviews: Math.floor(Math.random() * 100) + 50,
      additions: Math.floor(Math.random() * 40) + 10,
      edits: Math.floor(Math.random() * 30) + 5,
    }));
  };

  const monthlyActivityData = generateMonthlyActivityData();

  // Generate category distribution data
  const generateCategoryData = () => {
    if (categories && categories.length > 0) {
      return [
        { name: 'Animals & Plants', value: 30 },
        { name: 'Art & Design', value: 22 },
        { name: 'Education & Learning', value: 13 },
        { name: 'Celebrations & Traditions', value: 16 },
        { name: 'Business & Careers', value: 19 },
      ];
    }
    
    return [
      { name: 'Animals & Plants', value: 30 },
      { name: 'Art & Design', value: 22 },
      { name: 'Education & Learning', value: 13 },
      { name: 'Celebrations & Traditions', value: 16 },
      { name: 'Business & Careers', value: 19 },
    ];
  };

  const categoryData = generateCategoryData();

  const handleExport = async (options) => {
    try {
      setIsExporting(true);

      const { data: phrases, error: phrasesError } = await supabase
        .from('phrases')
        .select(`
          id,
          phrase,
          part_of_speech,
          hint,
          category_id,
          subcategory_id,
          difficulty,
          categories:category_id(name),
          subcategories:subcategory_id(name)
        `);

      if (phrasesError) throw phrasesError;

      const { data: phraseTags, error: tagsError } = await supabase
        .from('phrase_tags')
        .select(`
          phrase_id,
          tags:tag_id(tag)
        `);

      if (tagsError) throw tagsError;

      const tagsByPhraseId = {};
      phraseTags.forEach((item) => {
        if (!tagsByPhraseId[item.phrase_id]) {
          tagsByPhraseId[item.phrase_id] = [];
        }
        tagsByPhraseId[item.phrase_id].push(item.tags.tag);
      });

      const categorizedPhrases = {};
      phrases.forEach((phrase) => {
        const categoryName = phrase.categories ? phrase.categories.name : 'Uncategorized';

        if (!categorizedPhrases[categoryName]) {
          categorizedPhrases[categoryName] = [];
        }

        categorizedPhrases[categoryName].push({
          text: phrase.phrase,
          pos: phrase.part_of_speech,
          hint: phrase.hint || '',
          difficulty: phrase.difficulty || 1,
          subcategory: phrase.subcategories ? phrase.subcategories.name : null,
          tags: tagsByPhraseId[phrase.id] || [],
        });
      });

      const esp32Data = {};
      Object.keys(categorizedPhrases).forEach((cat) => {
        if (options.optimizeForESP32) {
          // Optimized format for ESP32
          esp32Data[cat] = categorizedPhrases[cat].map(p => ({
            t: p.text,                    // text (shortened property name)
            h: p.hint || '',              // hint (shortened property name)
            d: p.difficulty || 1          // difficulty (shortened property name)
          }));
        } else {
          // Full format
          esp32Data[cat] = categorizedPhrases[cat];
        }
      });

      const headerContent = options.exportHeader ? generateArduinoHeader(esp32Data) : '';

      setIsExporting(false);
      return {
        jsonData: esp32Data,
        headerContent,
      };
    } catch (error) {
      console.error('Export error:', error);
      setIsExporting(false);
      return null;
    }
  };

  const generateArduinoHeader = (data) => {
    let headerContent = `// Auto-generated phrases header file
#ifndef PHRASES_H
#define PHRASES_H

#include <Arduino.h>

struct Phrase {
  const char* text;
  const char* hint;
  uint8_t difficulty;
};

`;

    Object.keys(data).forEach((category) => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      const phrases = data[category];

      headerContent += `// ${category} phrases\n`;
      headerContent += `constexpr Phrase ${categoryVar}_phrases[] PROGMEM = {\n`;

      phrases.forEach((phrase) => {
        const text = phrase.t || phrase.text;
        const hint = phrase.h || phrase.hint || '';
        const difficulty = phrase.d || phrase.difficulty || 1;

        headerContent += `  {"${escapeString(text)}", "${escapeString(hint)}", ${difficulty}},\n`;
      });

      headerContent += `};\n\n`;
      headerContent += `constexpr size_t ${categoryVar}_count = ${phrases.length};\n\n`;
    });

    headerContent += `// Category index\n`;
    headerContent += `struct PhraseCategory {\n`;
    headerContent += `  const char* name;\n`;
    headerContent += `  const Phrase* phrases;\n`;
    headerContent += `  size_t count;\n`;
    headerContent += `};\n\n`;

    headerContent += `constexpr PhraseCategory phrase_categories[] PROGMEM = {\n`;
    Object.keys(data).forEach((category) => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      headerContent += `  {"${escapeString(category)}", ${categoryVar}_phrases, ${categoryVar}_count},\n`;
    });
    headerContent += `};\n\n`;

    headerContent += `constexpr size_t category_count = ${Object.keys(data).length};\n\n`;
    headerContent += `#endif // PHRASES_H\n`;

    return headerContent;
  };

  const escapeString = (str) => {
    if (!str) return "";
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n');
  };

  // Render
  return (
    <div className={cn(styles.container, "mx-auto py-6 space-y-6")}>
      {/* Header */}
      <DashboardHeader 
  theme={theme}
  setTheme={setTheme}
  onReviewClick={() => router.push('/review')}
  onExportClick={() => setShowExportModal(true)}
  onLoginClick={() => setShowLoginModal(true)}
/>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {/* Total Phrases Chart */}
        <Card className="border rounded-md">
          <CardHeader className="pb-2">
            <CardTitle className="text-lg">Total Phrases</CardTitle>
            <CardDescription>Growth trend over time</CardDescription>
          </CardHeader>
          <CardContent className="pb-0">
            <div className="h-[120px]">
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={phrasesOverTime} margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
                  <CartesianGrid stroke="#3F3F46" strokeDasharray="3 3" opacity={0.3} />
                  <XAxis dataKey="month" tick={{ fill: 'white', fontSize: 10 }} axisLine={{ stroke: '#3F3F46' }} tickLine={{ stroke: '#3F3F46' }} />
                  <YAxis tick={{ fill: 'white', fontSize: 10 }} axisLine={{ stroke: '#3F3F46' }} tickLine={{ stroke: '#3F3F46' }} />
                  <Tooltip 
                    contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', fontSize: '12px' }} 
                    labelStyle={{ fontWeight: 'bold' }}
                    formatter={(value) => value === null ? 'N/A' : value} 
                  />
                  <Line 
                    type="monotone" 
                    dataKey="phrases" 
                    stroke="#8884d8" 
                    strokeWidth={2}
                    dot={{ fill: '#8884d8', r: 4 }}
                    activeDot={{ r: 6, fill: '#8884d8' }}
                    isAnimationActive={false}
                  />
                  
                  {/* Add text overlay when data is null/error state */}
                  {phrasesOverTime[0]?.phrases === null && (
                    <text
                      x="50%"
                      y="50%"
                      textAnchor="middle"
                      dominantBaseline="middle"
                      fill="#FF6B6B"
                      fontSize="14px"
                      fontWeight="bold"
                    >
                      No Data Available
                    </text>
                  )}
                </LineChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
          <CardFooter>
            <div className="flex w-full items-start gap-2 text-sm">
              <div className="grid gap-0">
                <div className="flex items-center gap-1 font-medium text-lg">
                  {stats?.total || 1392} total phrases <TrendingUp className="h-4 w-4 ml-1 text-green-500" />
                </div>
                <div className="flex items-center gap-2 text-xs text-muted-foreground">
                  Last 6 months
                </div>
              </div>
            </div>
          </CardFooter>
        </Card>

        {/* Difficulty Radar Chart */}
        <Card className="border rounded-md">
          <CardHeader className="pb-2">
            <CardTitle className="text-lg">Difficulty Distribution</CardTitle>
            <CardDescription>Distribution by difficulty level</CardDescription>
          </CardHeader>
          <CardContent className="pb-0">
            <div className="h-[120px]">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={[
                      { name: 'Easy', value: stats?.difficultyBreakdown?.easy || 30 },
                      { name: 'Medium', value: stats?.difficultyBreakdown?.medium || 20 },
                      { name: 'Hard', value: stats?.difficultyBreakdown?.hard || 10 },
                    ]}
                    cx="50%"
                    cy="50%"
                    innerRadius={25}
                    outerRadius={45}
                    paddingAngle={2}
                    dataKey="value"
                    label={({ name }) => name}
                  >
                    <Cell fill="#D4D4D8" />
                    <Cell fill="#A1A1AA" />
                    <Cell fill="#71717A" />
                  </Pie>
                  <Tooltip contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', borderRadius: '0.5rem', fontSize: '12px' }} />
                </PieChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
          <CardFooter className="pt-3">
            <div className="flex w-full items-center gap-4 text-sm justify-around">
              <div className="flex items-center gap-1">
                <div className="w-3 h-3 rounded-full" style={{ backgroundColor: "#D4D4D8" }}></div>
                <span className="text-xs">Easy</span>
              </div>
              <div className="flex items-center gap-1">
                <div className="w-3 h-3 rounded-full" style={{ backgroundColor: "#A1A1AA" }}></div>
                <span className="text-xs">Medium</span>
              </div>
              <div className="flex items-center gap-1">
                <div className="w-3 h-3 rounded-full" style={{ backgroundColor: "#71717A" }}></div>
                <span className="text-xs">Hard</span>
              </div>
            </div>
          </CardFooter>
        </Card>

        {/* Top Reviewers */}
        <Card className="border rounded-md">
          <CardHeader className="pb-2">
            <CardTitle className="text-lg">Top Reviewers</CardTitle>
            <CardDescription>Most active contributors</CardDescription>
          </CardHeader>
          <CardContent className="p-2 pb-4">
            <div className="space-y-2 mt-2">
              {reviewers?.slice(0, 3).map((reviewer, index) => (
                <div key={index} className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <div className="w-8 h-8 rounded-full bg-zinc-700 flex items-center justify-center text-xs">
                      {reviewer.name.charAt(0).toUpperCase()}
                    </div>
                    <span className="text-sm font-medium">{reviewer.name}</span>
                  </div>
                  <div className="flex items-center">
                    <span className="text-sm font-bold">{reviewer.total_reviews || index === 0 ? 4 : index === 1 ? 1 : 0}</span>
                    <span className="text-xs text-muted-foreground ml-1">reviews</span>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Tabs */}
      <Tabs defaultValue="phrases" value={activeTab} onValueChange={setActiveTab} className="space-y-4">
        <div className="border-b">
          <div className="flex">
            <TabsList className="bg-transparent">
              <TabsTrigger value="phrases" className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent">
                Phrases
              </TabsTrigger>
              <TabsTrigger value="analytics" className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent">
                Analytics
              </TabsTrigger>
              <TabsTrigger value="import" className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent">
                Import
              </TabsTrigger>
            </TabsList>
          </div>
        </div>

        {/* Phrases Tab */}
<TabsContent value="phrases" className="m-0">
  <div className="flex flex-col space-y-4">
    {/* PhrasesTable - No separate search input above the table */}
    <PhrasesTable
  phrases={phrases}
  loading={phrasesLoading}
  tableState={tableState}
  onTableStateChange={handleTableStateChange}
  onEdit={editPhrase}
  onDelete={deletePhrase}
  newIds={[]}
  onShowFilters={() => setShowFilterModal(true)}
  animateFlashClass={styles.animateFlash} // Pass the CSS module class
/>
  </div>
</TabsContent>

        {/* Analytics Tab */}
        <TabsContent value="analytics" className="m-0">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Monthly Activity */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Monthly Activity</CardTitle>
                <CardDescription>Reviews, additions and edits over time</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={monthlyActivityData} margin={{ top: 10, right: 10, left: 0, bottom: 20 }}>
                      <CartesianGrid vertical={false} stroke="#3F3F46" strokeDasharray="3 3" />
                      <XAxis dataKey="name" tick={{ fill: "white" }} tickLine={{ stroke: "#3F3F46" }} axisLine={{ stroke: "#3F3F46" }} />
                      <YAxis tick={{ fill: "white" }} tickLine={{ stroke: "#3F3F46" }} axisLine={{ stroke: "#3F3F46" }} />
                      <Tooltip contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', borderRadius: '0.5rem' }} />
                      <Legend wrapperStyle={{ paddingTop: 20 }} />
                      <Bar dataKey="reviews" fill="#71717A" />
                      <Bar dataKey="additions" fill="#3F3F46" />
                      <Bar dataKey="edits" fill="#18181B" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>

            {/* Category Distribution */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Category Distribution</CardTitle>
                <CardDescription>Phrases by category</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <PieChart>
                      <Pie
                        data={categoryData}
                        cx="50%"
                        cy="50%"
                        innerRadius={60}
                        outerRadius={90}
                        paddingAngle={2}
                        dataKey="value"
                        label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                      >
                        <Cell fill="#D4D4D8" />
                        <Cell fill="#A1A1AA" />
                        <Cell fill="#71717A" />
                        <Cell fill="#3F3F46" />
                        <Cell fill="#18181B" />
                      </Pie>
                      <Tooltip contentStyle={{ backgroundColor: '#27272A', borderColor: '#3F3F46', color: 'white', borderRadius: '0.5rem' }} />
                    </PieChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>
            
            {/* Top Reviewers Performance */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Top Reviewers Performance</CardTitle>
                <CardDescription>Reviews and streaks by contributor</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      layout="vertical"
                      data={[
                        { name: "Kari", reviews: 120, streak: 14 },
                        { name: "Sarah", reviews: 85, streak: 7 },
                        { name: "Justin", reviews: 65, streak: 5 },
                        { name: "Alex", reviews: 45, streak: 3 },
                        { name: "Morgan", reviews: 30, streak: 2 }
                      ]}
                      margin={{ top: 20, right: 30, left: 60, bottom: 5 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke="#3F3F46" />
                      <XAxis 
                        type="number"
                        tick={{ fill: "white" }}
                        tickLine={{ stroke: "#3F3F46" }}
                        axisLine={{ stroke: "#3F3F46" }}
                      />
                      <YAxis 
                        dataKey="name" 
                        type="category"
                        tick={{ fill: "white" }}
                        tickLine={{ stroke: "#3F3F46" }}
                        axisLine={{ stroke: "#3F3F46" }}
                      />
                      <Tooltip
                        contentStyle={{ 
                          backgroundColor: '#27272A', 
                          borderColor: '#3F3F46',
                          color: 'white',
                          borderRadius: '0.5rem' 
                        }}
                      />
                      <Legend />
                      <Bar dataKey="reviews" fill="#71717A" />
                      <Bar dataKey="streak" fill="#18181B" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>

            {/* Words Added This Month */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Words Added This Month</CardTitle>
                <CardDescription>Progress towards the goal of 100 words</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <RadialBarChart
                      data={wordsAddedData}
                      innerRadius="80%"
                      outerRadius="100%"
                      startAngle={180}
                      endAngle={0}
                    >
                      <PolarGrid stroke="hsl(var(--muted))" />
                      <PolarRadiusAxis angle={30} domain={[0, 100]} tick={false} />
                      <RadialBar
                        dataKey="value"
                        cornerRadius={10}
                        background
                        fill="hsl(var(--primary))"
                      />
                      <text
                        x="50%"
                        y="50%"
                        textAnchor="middle"
                        dominantBaseline="middle"
                        className="fill-foreground text-2xl font-bold"
                      >
                        {wordsAddedData[0].value} / 100
                      </text>
                    </RadialBarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
              <CardFooter>
                <div className="w-full flex justify-between items-center">
                  <div className="text-sm text-muted-foreground">
                    Goal: <span className="font-bold text-white">100 words</span>
                  </div>
                  <div className="text-sm text-muted-foreground">
                    Remaining: <span className="font-bold text-white">{100 - wordsAddedData[0].value}</span>
                  </div>
                </div>
              </CardFooter>
            </Card>
          </div>
        </TabsContent>

        {/* Import Tab */}
        <TabsContent value="import" className="m-0">
          <BulkImportForm
            onSuccess={() => setActiveTab('phrases')}
            onError={() => {}}
          />
        </TabsContent>
      </Tabs>

      {/* Modals */}
      <FilterModal
        isOpen={showFilterModal}
        onClose={() => setShowFilterModal(false)}
        filters={filters}
        onChange={handleFilterChange}
        onReset={resetFilters}
        categories={categories}
        difficulties={difficulties}
        partsOfSpeech={partsOfSpeech}
        subcategories={subcategories}
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        onExport={handleExport}
        isLoading={isExporting}
      />
    </div>
  );
};

export default CleanDashboard;

============================================================

FILE: .\features\dashboard\components\DashboardHeader.tsx
SIZE: 1.63 KB
LAST MODIFIED: 03/15/2025 17:10:57

import React from 'react';
import { Button } from "@/components/ui/button";
import { Moon, Sun, FileDownIcon } from "lucide-react";

interface DashboardHeaderProps {
  theme: string;
  setTheme: (theme: string) => void;
  onReviewClick: () => void;
  onExportClick: () => void;
  onLoginClick: () => void;
}

export function DashboardHeader({ 
  theme, 
  setTheme, 
  onReviewClick, 
  onExportClick, 
  onLoginClick 
}: DashboardHeaderProps) {
  return (
    <div className="flex justify-between items-center">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground">Manage your catch phrases</p>
      </div>

      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="icon"
          onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
          className="h-9 w-9 rounded-md"
        >
          {theme === 'dark' ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />}
        </Button>

        <Button 
          variant="outline" 
          className="rounded-md"
          onClick={onReviewClick}
        >
          Review Words
        </Button>

        <Button 
          variant="outline" 
          className="rounded-md"
          onClick={onExportClick}
        >
          <FileDownIcon className="mr-2 h-4 w-4" />
          Export
        </Button>

        <Button 
          variant="outline" 
          className="rounded-md bg-white text-black"
          onClick={onLoginClick}
        >
          Login
        </Button>
      </div>
    </div>
  );
}

============================================================

FILE: .\features\dashboard\styles\Dashboard.module.css
SIZE: 1.56 KB
LAST MODIFIED: 03/15/2025 17:09:38

.container {
  /* Add any container-specific styles here */
}

@keyframes flash {
  0%, 100% {
    background-color: transparent;
  }
  50% {
    background-color: var(--accent);
  }
}

.animateFlash {
  animation: flash 1.5s ease-in-out;
}

/* Table row hover effect */
.tableRowHover {
  transition: background-color 0.15s ease;
}

.tableRowHover:hover {
  background-color: var(--muted);
}

/* Ensure top margin for pie labels */
.rechartsPieLabelText {
  margin-top: 5px; /* Fix for cut-off text */
}

/* Chart hover effects */
.rechartsWrapper {
  margin-top: 5px;
}

/* Chart style updates */
.rechartsBarRectangle:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

.rechartsPieSector:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

/* Custom grayscale palette for charts */
.chartGray100 {
  fill: #f5f5f5;
}

.chartGray200 {
  fill: #e0e0e0;
}

.chartGray300 {
  fill: #cccccc;
}

.chartGray400 {
  fill: #bbbbbb;
}

.chartGray500 {
  fill: #999999;
}

.chartGray600 {
  fill: #777777;
}

.chartGray700 {
  fill: #555555;
}

.chartGray800 {
  fill: #333333;
}

/* Tooltip styling */
.customTooltip {
  background-color: var(--background);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  padding: 0.5rem;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Login button styling */
.loginButton {
  background-color: white;
  color: black;
  border: 1px solid var(--border);
}

.loginButton:hover {
  background-color: #f0f0f0;
}

============================================================

FILE: .\hooks\use-table-state.ts
SIZE: 3.45 KB
LAST MODIFIED: 03/09/2025 15:24:47

// src/hooks/use-table-state.ts
import { useState, useCallback } from 'react';
import { TableState, FiltersState, SortConfig, PaginationState } from '@/components/tables/types';

interface UseTableStateOptions {
  initialSortConfig?: SortConfig;
  initialPagination?: Partial<PaginationState>;
  initialFilters?: FiltersState;
}

export function useTableState({
  initialSortConfig = { key: 'id', direction: 'asc' },
  initialPagination = {},
  initialFilters = {}
}: UseTableStateOptions = {}) {
  // Default pagination state
  const defaultPagination: PaginationState = {
    currentPage: 1,
    totalPages: 1,
    rowsPerPage: 10,
    totalItems: 0,
    ...initialPagination
  };

  // State for table configuration
  const [tableState, setTableState] = useState<TableState>({
    sortConfig: initialSortConfig,
    pagination: defaultPagination,
    filters: initialFilters
  });

  // Update table state with partial updates
  const updateTableState = useCallback((updates: Partial<TableState>) => {
    setTableState(prev => {
      const newState = { ...prev };
      
      // Update sort config if provided
      if (updates.sortConfig) {
        newState.sortConfig = {
          ...prev.sortConfig,
          ...updates.sortConfig
        };
      }
      
      // Update pagination if provided
      if (updates.pagination) {
        newState.pagination = {
          ...prev.pagination,
          ...updates.pagination
        };
      }
      
      // Update filters if provided
      if (updates.filters) {
        newState.filters = {
          ...prev.filters,
          ...updates.filters
        };
      }
      
      return newState;
    });
  }, []);
  
  // Convenience handlers for common operations
  const handleSort = useCallback((key: string) => {
    let direction = 'asc';
    if (tableState.sortConfig.key === key) {
      direction = tableState.sortConfig.direction === 'asc' ? 'desc' : 'asc';
    }
    updateTableState({ sortConfig: { key, direction: direction as 'asc' | 'desc' } });
  }, [tableState.sortConfig, updateTableState]);
  
  const handlePageChange = useCallback((newPage: number) => {
    updateTableState({
      pagination: { currentPage: newPage }
    });
  }, [updateTableState]);
  
  const handleRowsPerPageChange = useCallback((newRowsPerPage: number) => {
    updateTableState({
      pagination: {
        rowsPerPage: newRowsPerPage,
        currentPage: 1 // Reset to first page when changing rows per page
      }
    });
  }, [updateTableState]);
  
  const handleFilterChange = useCallback((newFilters: FiltersState) => {
    updateTableState({
      filters: newFilters,
      pagination: { currentPage: 1 } // Reset to first page when changing filters
    });
  }, [updateTableState]);
  
  const resetFilters = useCallback(() => {
    updateTableState({
      filters: {},
      pagination: { currentPage: 1 }
    });
  }, [updateTableState]);
  
  const updateTotalItems = useCallback((totalItems: number) => {
    const totalPages = Math.ceil(totalItems / tableState.pagination.rowsPerPage);
    updateTableState({
      pagination: {
        totalItems,
        totalPages
      }
    });
  }, [tableState.pagination.rowsPerPage, updateTableState]);

  return {
    tableState,
    updateTableState,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    resetFilters,
    updateTotalItems
  };
}

============================================================

FILE: .\hooks\useReviewProgress.ts
SIZE: 1.18 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect } from "react";
import { supabase } from '@/lib/services/supabase';
import type { Reviewer } from "@/types/types";

interface ReviewProgress {
  reviewed: number;
  remaining: number;
  streak: number;
}

export const useReviewProgress = (
  reviewer: Reviewer | null,
  totalPhrases: number
): ReviewProgress => {
  const [progress, setProgress] = useState<ReviewProgress>({
    reviewed: 0,
    remaining: 0,
    streak: 0,
  });

  useEffect(() => {
    if (!reviewer) return;

    const fetchProgress = async () => {
      try {
        // Get count of reviewed phrases
        const { count: reviewedCount } = await supabase
          .from("votes")
          .select("phrase_id", { count: "exact", distinct: true })
          .eq("reviewer_id", reviewer.id);

        setProgress({
          reviewed: reviewedCount || 0,
          remaining: totalPhrases - (reviewedCount || 0),
          streak: reviewer.current_streak || 0,
        });
      } catch (error) {
        console.error("Error fetching review progress:", error);
        // Keep the current progress state on error
      }
    };

    fetchProgress();
  }, [reviewer, totalPhrases]);

  return progress;
};



============================================================

FILE: .\hooks\dashboard\usePhraseTimeline.ts
SIZE: 0.87 KB
LAST MODIFIED: 03/09/2025 21:46:08

import { useState, useEffect } from 'react';
import { DashboardDataService } from '@/services/dashboard-data-service';

export const usePhraseTimeline = () => {
  const [phrasesOverTime, setPhrasesOverTime] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      const { data, error } = await DashboardDataService.fetchPhrasesOverTime();
      
      if (error || !data) {
        setPhrasesOverTime(DashboardDataService.getErrorStateData());
        setError(error);
      } else {
        const monthlyData = DashboardDataService.processTimestampData(data);
        setPhrasesOverTime(monthlyData);
      }
      setLoading(false);
    };
    
    fetchData();
  }, []);

  return { phrasesOverTime, loading, error };
};


============================================================

FILE: .\hooks\use-data\usePhraseMetadata.ts
SIZE: 2.39 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';

interface PhraseMetadata {
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
  error: string | null;
}

interface CategoryRecord {
  name: string;
}

interface PartOfSpeechRecord {
  part_of_speech: string;
}

export const usePhraseMetadata = (): PhraseMetadata => {
  const [categories, setCategories] = useState<string[]>([]);
  const [difficulties, setDifficulties] = useState<string[]>([]);
  const [partsOfSpeech, setPartsOfSpeech] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchMetadata = async () => {
      setLoading(true);
      setError(null);
      
      try {
        // Fetch categories
        const { data: categoryData, error: categoryError } = await supabase
          .from('categories')
          .select('name')
          .order('name');

        if (categoryError) throw categoryError;

        // Fetch parts of speech from phrases
        const { data: posData, error: posError } = await supabase
          .from('phrases')
          .select('part_of_speech')
          .not('part_of_speech', 'is', null);

        if (posError) throw posError;

        // Process categories
        const uniqueCategories = Array.from(
          new Set((categoryData as CategoryRecord[]).map(record => record.name))
        );

        // Process parts of speech
        const uniquePartsOfSpeech = Array.from(
          new Set((posData as PartOfSpeechRecord[])
            .map(record => record.part_of_speech)
            .filter(Boolean))
        ).sort();

        // Set predefined difficulties
        const difficultyLevels = ['Easy', 'Medium', 'Hard'];

        setCategories(uniqueCategories);
        setDifficulties(difficultyLevels);
        setPartsOfSpeech(uniquePartsOfSpeech);
      } catch (err) {
        console.error('Error fetching metadata:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch metadata');
      } finally {
        setLoading(false);
      }
    };

    fetchMetadata();
  }, []);

  return {
    categories,
    difficulties,
    partsOfSpeech,
    loading,
    error
  };
};

export default usePhraseMetadata;


============================================================

FILE: .\hooks\use-data\usePhrases.ts
SIZE: 5.42 KB
LAST MODIFIED: 03/05/2025 15:15:36

// hooks/usePhrases.ts

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase'
import type { Phrase, PaginationState, SortConfig, Filters } from '@/types/types';

export const usePhrases = () => {
  const [phrases, setPhrases] = useState<Phrase[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    rowsPerPage: 20,
    totalPages: 1
  });

  const [sortConfig, setSortConfig] = useState<SortConfig>({
    key: '',
    direction: 'asc'
  });

  const [filters, setFilters] = useState<Filters>({
    searchTerm: '',
    category: '',
    difficulty: '',
    subcategory: '',
    part_of_speech: ''
  });

  const fetchPhrases = useCallback(async () => {
    try {
      setLoading(true);
      let query = supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(id, name),
          subcategories:subcategory_id(id, name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `, { count: 'exact' });

      // Apply filters
      if (filters.category) {
        // First get the category id
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          query = query.eq('category_id', categoryData.id);
        }
      }

      if (filters.difficulty) {
        query = query.eq('difficulty', filters.difficulty);
      }

      if (filters.subcategory) {
        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('id')
          .eq('name', filters.subcategory)
          .single();

        if (subcategoryData) {
          query = query.eq('subcategory_id', subcategoryData.id);
        }
      }

      if (filters.part_of_speech) {
        query = query.eq('part_of_speech', filters.part_of_speech);
      }

      if (filters.searchTerm) {
        query = query.or(`phrase.ilike.%${filters.searchTerm}%`);
      }

      // Apply sorting
      if (sortConfig.key) {
        query = query.order(sortConfig.key, {
          ascending: sortConfig.direction === 'asc',
          nullsFirst: false
        });
      } else {
        // Default sort
        query = query.order('id', { ascending: false });
      }

      // Apply pagination
      const start = (pagination.currentPage - 1) * pagination.rowsPerPage;
      const end = start + pagination.rowsPerPage - 1;
      query = query.range(start, end);

      const { data, error: supabaseError, count } = await query as SupabaseQueryResponse<PhraseWithRelations>;

      if (supabaseError) throw supabaseError;

      // Transform the data
      const transformedData = data?.map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      setPhrases(transformedData || []);
      
      if (count !== null) {
        setPagination(prev => ({
          ...prev,
          totalPages: Math.ceil(count / prev.rowsPerPage)
        }));
      }
    } catch (err) {
      console.error('Error fetching phrases:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch phrases');
    } finally {
      setLoading(false);
    }
  }, [filters, sortConfig, pagination.currentPage, pagination.rowsPerPage]);

  // Fetch categories for the filter
  const fetchCategories = async () => {
    try {
      const { data, error } = await supabase
        .from('categories')
        .select('name')
        .order('name');
        
      if (error) {
        console.error('Supabase error fetching categories:', error);
        return [];
      }
      
      return data.map(category => category.name);
    } catch (error) {
      console.error('Error fetching categories:', error);
      return [];
    }
  };

  const handleFilterChange = (name: string, value: string) => {
    setFilters(prev => ({ ...prev, [name]: value }));
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const resetFilters = () => {
    setFilters({
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    });
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const handleSort = (key: keyof Phrase) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };

  const handlePageChange = (page: number) => {
    setPagination(prev => ({ ...prev, currentPage: page }));
  };

  const handleRowsPerPageChange = (rowsPerPage: number) => {
    setPagination(prev => ({
      ...prev,
      rowsPerPage,
      currentPage: 1
    }));
  };

  useEffect(() => {
    fetchPhrases();
  }, [fetchPhrases]);

  return {
    phrases,
    loading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    resetFilters,
    fetchCategories,
    fetchPhrases,
    setError
  };
};

============================================================

FILE: .\hooks\use-data\useReviewers.ts
SIZE: 0.95 KB
LAST MODIFIED: 03/05/2025 15:03:18

// hooks/useReviewers.ts
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Reviewer } from '@/types/types';

export const useReviewers = () => {
  const [reviewers, setReviewers] = useState<Reviewer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchReviewers = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });

      if (error) throw error;
      setReviewers(data || []);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to fetch reviewers'));
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchReviewers();
  }, []);

  return { reviewers, loading, error, refetch: fetchReviewers };
};


============================================================

FILE: .\hooks\use-data\useStats.ts
SIZE: 2.84 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Stats, Phrase } from '@/types/types';

interface UseStatsReturn {
  stats: Stats;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const useStats = (): UseStatsReturn => {
  const [stats, setStats] = useState<Stats>({
    total: 0,
    uniqueCategories: 0,
    difficultyBreakdown: {
      easy: 0,
      medium: 0,
      hard: 0,
    },
  });

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const calculateStats = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const { data: phrases, error: fetchError, count } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id (name)
        `, { count: 'exact' });

      if (fetchError) throw fetchError;
      if (!phrases) throw new Error('No data received');

      // Calculate unique categories
      const uniqueCategories = new Set(phrases.map((p) => p.categories?.name)).size;

      // Map difficulty numbers to labels
      const difficultyLabels = {
        1: 'easy',
        2: 'medium',
        3: 'hard',
      };

      // Calculate difficulty breakdown
      const difficultyCount = phrases.reduce((acc: Record<string, number>, phrase) => {
        const difficultyLabel = difficultyLabels[phrase.difficulty] || 'unknown';
        acc[difficultyLabel] = (acc[difficultyLabel] || 0) + 1;
        return acc;
      }, {});

      const total = count || phrases.length;

      // Calculate percentages
      let easy = Math.round(((difficultyCount['easy'] || 0) / total) * 100);
      let medium = Math.round(((difficultyCount['medium'] || 0) / total) * 100);
      let hard = Math.round(((difficultyCount['hard'] || 0) / total) * 100);

      // Adjust for rounding errors
      const sum = easy + medium + hard;
      if (sum !== 100) {
        const diff = 100 - sum;
        if (easy >= medium && easy >= hard) {
          easy += diff;
        } else if (medium >= easy && medium >= hard) {
          medium += diff;
        } else {
          hard += diff;
        }
      }

      setStats({
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard,
        },
      });
    } catch (err) {
      console.error('Error calculating stats:', err);
      setError(err instanceof Error ? err.message : 'Failed to calculate stats');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    calculateStats();
  }, [calculateStats]);

  return {
    stats,
    loading,
    error,
    refetch: calculateStats,
  };
};

export default useStats;


============================================================

FILE: .\hooks\use-ui\useDebounce.ts
SIZE: 4.11 KB
LAST MODIFIED: 02/09/2025 15:42:39

import { useState, useEffect, useRef } from 'react';

interface DebouncedState<T> {
  debouncedValue: T;
  isDebouncing: boolean;
  flush: () => void;
  cancel: () => void;
}

/**
 * Custom hook for debouncing values
 */
export function useDebounce<T>(
  value: T,
  delay: number = 500,
  options: {
    leading?: boolean;
    maxWait?: number;
  } = {}
): DebouncedState<T> {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  const [isDebouncing, setIsDebouncing] = useState<boolean>(false);
  
  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const maxWaitTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const valueRef = useRef<T>(value);
  const maxWaitStartTimeRef = useRef<number | undefined>(undefined);

  // Update the latest value
  useEffect(() => {
    valueRef.current = value;
  }, [value]);

  // Cleanup function
  const cleanup = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    if (maxWaitTimeoutRef.current) {
      clearTimeout(maxWaitTimeoutRef.current);
    }
  };

  // Handle the debounced update
  const update = () => {
    setDebouncedValue(valueRef.current);
    setIsDebouncing(false);
    maxWaitStartTimeRef.current = undefined;
    cleanup();
  };

  // Reset effects on delay change
  useEffect(() => {
    cleanup();
    setIsDebouncing(false);
  }, [delay]);

  // Main debounce effect
  useEffect(() => {
    if (delay <= 0) {
      setDebouncedValue(value);
      return;
    }

    setIsDebouncing(true);

    // Handle leading edge
    if (options.leading && !timeoutRef.current) {
      setDebouncedValue(value);
      setIsDebouncing(false);
      return;
    }

    // Set up max wait timeout if specified
    if (options.maxWait && !maxWaitStartTimeRef.current) {
      maxWaitStartTimeRef.current = Date.now();
      maxWaitTimeoutRef.current = setTimeout(() => {
        if (maxWaitStartTimeRef.current) {
          update();
        }
      }, options.maxWait);
    }

    // Set up main timeout
    timeoutRef.current = setTimeout(update, delay);

    return cleanup;
  }, [value, delay, options.leading, options.maxWait]);

  // Flush function to immediately update value
  const flush = () => {
    if (timeoutRef.current) {
      update();
    }
  };

  // Cancel function to stop debouncing
  const cancel = () => {
    if (timeoutRef.current) {
      cleanup();
      setIsDebouncing(false);
    }
  };

  // Cleanup on unmount
  useEffect(() => cleanup, []);

  return {
    debouncedValue,
    isDebouncing,
    flush,
    cancel
  };
}

/**
 * Simplified version that only returns the debounced value
 */
export function useSimpleDebounce<T>(value: T, delay: number = 500): T {
  const { debouncedValue } = useDebounce(value, delay);
  return debouncedValue;
}

/**
 * Version specifically for debouncing callbacks
 */
export function useDebouncedCallback<T extends (...args: any[]) => any>(
  callback: T,
  delay: number = 500,
  deps: any[] = []
): [(...args: Parameters<T>) => void, boolean, () => void] {
  const [isDebouncing, setIsDebouncing] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const callbackRef = useRef(callback);

  // Update callback ref when it changes
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Cleanup on unmount or deps change
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, deps);

  const debouncedCallback = (...args: Parameters<T>) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    setIsDebouncing(true);

    timeoutRef.current = setTimeout(() => {
      callbackRef.current(...args);
      setIsDebouncing(false);
    }, delay);
  };

  const cancel = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      setIsDebouncing(false);
    }
  };

  return [debouncedCallback, isDebouncing, cancel];
}

export default useDebounce;

============================================================

FILE: .\hooks\use-ui\usePagination.ts
SIZE: 2.35 KB
LAST MODIFIED: 02/09/2025 10:17:17

import { UsePaginationProps } from '@/types/types';

interface PaginationResult {
  totalPages: number;
  startIndex: number;
  endIndex: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  pageRange: number[];
  currentPageItems: number;
}

/**
 * Custom hook for handling pagination logic
 */
export const usePagination = ({
  totalItems,
  itemsPerPage,
  currentPage,
  siblingCount = 1,
  boundaryCount = 1
}: UsePaginationProps & {
  siblingCount?: number;
  boundaryCount?: number;
}): PaginationResult => {
  const totalPages = Math.max(1, Math.ceil(totalItems / itemsPerPage));
  const currentPageSafe = Math.min(Math.max(1, currentPage), totalPages);
  
  const startIndex = (currentPageSafe - 1) * itemsPerPage;
  const endIndex = Math.min(startIndex + itemsPerPage - 1, totalItems - 1);
  
  // Calculate the range of page numbers to show
  const range = (start: number, end: number): number[] => {
    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  };

  const startPages = range(1, Math.min(boundaryCount, totalPages));
  const endPages = range(
    Math.max(totalPages - boundaryCount + 1, boundaryCount + 1),
    totalPages
  );

  const siblingsStart = Math.max(
    Math.min(
      currentPageSafe - siblingCount,
      totalPages - boundaryCount - siblingCount * 2 - 1
    ),
    boundaryCount + 2
  );

  const siblingsEnd = Math.min(
    Math.max(currentPageSafe + siblingCount, boundaryCount + siblingCount * 2 + 2),
    endPages.length > 0 ? endPages[0] - 2 : totalPages - 1
  );

  // Combine the ranges with ellipses
  const pageRange = [
    ...startPages,
    ...(siblingsStart > boundaryCount + 2
      ? ['ellipsis']
      : boundaryCount + 1 < totalPages - boundaryCount
      ? [boundaryCount + 1]
      : []),
    ...range(siblingsStart, siblingsEnd),
    ...(siblingsEnd < totalPages - boundaryCount - 1
      ? ['ellipsis']
      : totalPages - boundaryCount > boundaryCount
      ? [totalPages - boundaryCount]
      : []),
    ...endPages
  ].filter((page): page is number => typeof page === 'number');

  return {
    totalPages,
    startIndex,
    endIndex,
    hasNextPage: currentPageSafe < totalPages,
    hasPreviousPage: currentPageSafe > 1,
    pageRange,
    currentPageItems: endIndex - startIndex + 1
  };
};

export default usePagination;

============================================================

FILE: .\hooks\use-ui\useToast.ts
SIZE: 3.94 KB
LAST MODIFIED: 02/09/2025 10:40:35

import * as React from "react";
import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_VALUE;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }

    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
    
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

export const useToast = () => {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
};

export { toast };
export type { Toast };

============================================================

FILE: .\lib\theme.ts
SIZE: 0.78 KB
LAST MODIFIED: 03/04/2025 21:09:37

// lib/theme.ts

export const theme = {
  colors: {
    primary: {
      50: 'var(--primary-50)',
      100: 'var(--primary-100)',
      // ... other shades
      500: 'var(--primary-500)',
      600: 'var(--primary-600)',
      700: 'var(--primary-700)',
    },
    gray: {
      50: 'var(--gray-50)',
      100: 'var(--gray-100)',
      // ... other shades
      800: 'var(--gray-800)',
      900: 'var(--gray-900)',
    },
    // Add other color palettes (error, warning, etc.)
  },
  spacing: {
    1: '0.25rem',
    2: '0.5rem',
    3: '0.75rem',
    4: '1rem',
    // ... other spacing values
  },
  borderRadius: {
    sm: '0.125rem',
    md: '0.25rem',
    lg: '0.5rem',
    xl: '1rem',
  },
  // ... other design tokens
}

export type Theme = typeof theme;

============================================================

FILE: .\lib\utils.ts
SIZE: 0.16 KB
LAST MODIFIED: 03/04/2025 21:05:08

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


============================================================

FILE: .\lib\services\claudeService.ts
SIZE: 5.79 KB
LAST MODIFIED: 03/04/2025 11:02:57

'use client';

export interface GenerateTagsResponse {
  tags: string[];
  error?: string;
}

export interface GenerateHintResponse {
  hint: string;
  error?: string;
}

export interface GeneratePhrasesResponse {
  phrases: string[];
  error?: string;
}

export interface SuggestCategoryResponse {
  category: string;
  error?: string;
}

const makeClaudeRequest = async (messages: Array<{ role: string; content: string }>) => {
  const response = await fetch('/api/claude', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ messages })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('API error response:', errorText);
    throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
  }

  return await response.json();
};

export const generateTags = async (phrase: string): Promise<GenerateTagsResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate exactly 3 descriptive tags for this catch phrase: "${phrase}".
                Rules for tags:
                1. Must be single words, no spaces or hyphens
                2. All lowercase
                3. Maximum 15 characters per tag
                4. No special characters or numbers
                5. No generic words like "fun" or "game"
                6. Focus on theme, subject matter, or skill required
                7. Avoid duplicate meaning tags
                
                Return only the 3 tags separated by commas, nothing else.
                Example format: strategy,teamwork,creativity`
    }]);

    const tags = data.content[0].text
      .split(',')
      .map((tag: string) => tag.trim())
      .filter((tag: string) => 
        tag.length <= 15 && 
        /^[a-z]+$/.test(tag) &&
        !['fun', 'game', 'play'].includes(tag)
      );

    if (tags.length !== 3) {
      throw new Error('Invalid tag generation result');
    }

    return { tags };
  } catch (error) {
    console.error('Error generating tags:', error);
    return {
      tags: [],
      error: error instanceof Error ? error.message : 'Failed to generate tags'
    };
  }
};

export const generateHint = async (phrase: string): Promise<GenerateHintResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Create a VERY SHORT helpful hint for the catch phrase: "${phrase}".
                Rules for hints:
                1. MUST BE 20 CHARACTERS OR LESS - THIS IS CRITICAL
                2. Don't reveal the exact answer
                3. Focus on context or category
                4. No direct synonyms
                5. Can be a clever riddle or wordplay
                6. Should help players think in right direction
                7. No explicit "This is..." or "Think about..." phrases
                
                Return only the hint text, nothing else.
                Example: For "BOOKWORM" -> "Reads a lot"`
    }]);

    const hint = data.content[0].text.trim();

    if (hint.length > 20) {
      // Truncate if still over limit, keeping it to 20 characters
      return { hint: hint.substring(0, 20) };
    }

    return { hint };
  } catch (error) {
    console.error('Error generating hint:', error);
    return {
      hint: '',
      error: error instanceof Error ? error.message : 'Failed to generate hint'
    };
  }
};

export const generatePhrases = async (inspiration: string, count: number = 5): Promise<GeneratePhrasesResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate ${count} unique and interesting catch phrases or words based on this inspiration: "${inspiration}".
                Rules for generated words/phrases:
                1. Mix of single words and short phrases (2-3 words)
                2. Suitable for a word game
                3. Each entry should be distinct and creative
                4. No extremely obscure terms
                5. Family-friendly content only
                6. No proper nouns unless very well known
                7. Varying difficulty levels
                
                Return only the list of words/phrases separated by commas, nothing else.
                Example format: Slumber party, DÃ©jÃ  vu, Photograph, Brain teaser, Pumpkin spice`
    }]);

    const phrases = data.content[0].text
      .split(',')
      .map((phrase: string) => phrase.trim())
      .filter((phrase: string) => phrase.length > 0);

    if (phrases.length === 0) {
      throw new Error('No phrases were generated');
    }

    return { phrases };
  } catch (error) {
    console.error('Error generating phrases:', error);
    return {
      phrases: [],
      error: error instanceof Error ? error.message : 'Failed to generate phrases'
    };
  }
};

export const suggestCategory = async (phrase: string, categories: string[]): Promise<SuggestCategoryResponse> => {
  try {
    const response = await fetch('/api/claude/suggest-category', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        phrase,
        categories
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('API error response:', errorText);
      throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
    }

    const data = await response.json();
    return { category: data.category };
  } catch (error) {
    console.error('Error suggesting category:', error);
    return {
      category: '',
      error: error instanceof Error ? error.message : 'Failed to suggest category'
    };
  }
};

============================================================

FILE: .\lib\services\supabase.ts
SIZE: 0.55 KB
LAST MODIFIED: 02/18/2025 10:42:19

import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/supabase'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  }
})

export const checkAuth = async () => {
  if (typeof window === 'undefined') {
    return null
  }
  const { data: { session } } = await supabase.auth.getSession()
  return session
}

============================================================

FILE: .\lib\utils\bulkImport.ts
SIZE: 5.11 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { supabase } from '@/lib/services/supabase';
import { validateBulkImport, sanitizePhrase } from './Validators';
import type { NewPhrase, Phrase } from '@/types/types';

interface BulkImportResult {
  success: boolean;
  message: string;
  newIds?: number[];
}

interface ImportedPhrase extends NewPhrase {
  id: number;
}

/**
 * Handles bulk import of phrases
 */
export const handleBulkImport = async (text: string): Promise<BulkImportResult> => {
  try {
    // Validate the input format
    const validation = validateBulkImport(text);
    if (!validation.isValid) {
      return {
        success: false,
        message: validation.errors.join('\n')
      };
    }

    // Parse and process the data
    const rows = text.trim().split('\n').map((row, index) => {
      const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = 
        row.split(',').map(field => field.trim());

      const newPhrase: NewPhrase = {
        phrase,
        category,
        difficulty,
        subcategory,
        tags,
        hint,
        part_of_speech
      };

      return sanitizePhrase(newPhrase) as NewPhrase;
    });

    // Insert the data
    const { data, error } = await supabase
      .from('phrases')
      .insert(rows)
      .select('id');

    if (error) {
      throw new Error(error.message);
    }

    const newIds = (data as ImportedPhrase[]).map(phrase => phrase.id);

    return {
      success: true,
      message: `Successfully imported ${rows.length} phrases.`,
      newIds
    };
  } catch (err) {
    console.error('Bulk import error:', err);
    return {
      success: false,
      message: err instanceof Error 
        ? err.message 
        : 'An error occurred during import'
    };
  }
};

/**
 * Validates a CSV file before import
 */
export const validateCSVFile = (file: File): Promise<{ isValid: boolean; message: string }> => {
  return new Promise((resolve, reject) => {
    // Check file type
    if (!file.name.endsWith('.csv')) {
      resolve({ 
        isValid: false, 
        message: 'File must be a CSV document' 
      });
      return;
    }

    // Check file size (e.g., 5MB limit)
    const maxSize = 5 * 1024 * 1024; // 5MB in bytes
    if (file.size > maxSize) {
      resolve({ 
        isValid: false, 
        message: 'File size must be less than 5MB' 
      });
      return;
    }

    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const validation = validateBulkImport(text);
        
        resolve({
          isValid: validation.isValid,
          message: validation.isValid 
            ? 'File is valid' 
            : validation.errors.join('\n')
        });
      } catch (err) {
        resolve({
          isValid: false,
          message: 'Error reading file content'
        });
      }
    };

    reader.onerror = () => {
      resolve({
        isValid: false,
        message: 'Error reading file'
      });
    };

    reader.readAsText(file);
  });
};

/**
 * Processes a CSV file and returns structured data
 */
export const processCSVFile = async (file: File): Promise<NewPhrase[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const phrases = text
          .trim()
          .split('\n')
          .map((row) => {
            const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = 
              row.split(',').map(field => field.trim());

            return sanitizePhrase({
              phrase,
              category,
              difficulty,
              subcategory,
              tags,
              hint,
              part_of_speech
            }) as NewPhrase;
          });

        resolve(phrases);
      } catch (err) {
        reject(new Error('Error processing CSV file'));
      }
    };

    reader.onerror = () => {
      reject(new Error('Error reading CSV file'));
    };

    reader.readAsText(file);
  });
};

/**
 * Downloads current phrases as CSV
 */
export const exportToCSV = async (): Promise<string> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*')
      .order('id');

    if (error) throw error;
    if (!data || data.length === 0) {
      throw new Error('No data to export');
    }

    // Create CSV header
    const headers = ['phrase', 'category', 'difficulty', 'subcategory', 'tags', 'hint', 'part_of_speech'];
    
    // Convert data to CSV rows
    const rows = data.map((phrase: Phrase) =>
      headers
        .map(header => phrase[header as keyof Phrase] || '')
        .map(field => `"${String(field).replace(/"/g, '""')}"`) // Escape quotes
        .join(',')
    );

    // Combine header and rows
    const csv = [headers.join(','), ...rows].join('\n');
    
    return csv;
  } catch (err) {
    console.error('Export error:', err);
    throw err;
  }
};


============================================================

FILE: .\lib\utils\databaseMaintenance.ts
SIZE: 5.37 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { supabase } from '@/lib/services/supabase';
import type { Phrase } from '@/types/types';

interface MaintenanceResult {
  success: boolean;
  message: string;
  details?: Record<string, any>;
}

interface PhraseTag {
  id: number;
  tags: string;
}

interface PhraseCategory {
  category: string;
}

/**
 * Updates existing tags format
 */
export const updateExistingTags = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('id, tags');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const updates = data.map((phrase: PhraseTag) => ({
      id: phrase.id,
      tags: phrase.tags
        .split(/[,\s]+/) // Split by comma or whitespace
        .map((tag: string) => tag.trim())
        .filter(Boolean)
        .join(',')
    }));

    const { error: updateError } = await supabase
      .from('phrases')
      .upsert(updates);

    if (updateError) throw updateError;

    return {
      success: true,
      message: `Successfully updated tags for ${updates.length} phrases.`,
      details: { updatedCount: updates.length }
    };
  } catch (err) {
    console.error('Error updating tags:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while updating tags'
    };
  }
};

/**
 * Cleans up unused categories
 */
export const cleanupCategories = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('category');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const categories = new Set(data.map((p: PhraseCategory) => p.category).filter(Boolean));
    const unusedCategories = Array.from(categories).filter(category => 
      !data.some((p: PhraseCategory) => p.category === category)
    );

    if (unusedCategories.length === 0) {
      return {
        success: true,
        message: 'No unused categories found.',
        details: { unusedCount: 0 }
      };
    }

    const { error: deleteError } = await supabase
      .from('phrases')
      .update({ category: 'Uncategorized' })
      .in('category', unusedCategories);

    if (deleteError) throw deleteError;

    return {
      success: true,
      message: `Cleaned up ${unusedCategories.length} unused categories.`,
      details: {
        unusedCount: unusedCategories.length,
        categories: unusedCategories
      }
    };
  } catch (err) {
    console.error('Error cleaning categories:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while cleaning categories'
    };
  }
};

/**
 * Validates all phrases in the database
 */
export const validateDatabase = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const issues: Array<{ id: number; issues: string[] }> = [];

    data.forEach((phrase: Phrase) => {
      const phraseIssues: string[] = [];

      if (!phrase.phrase?.trim()) {
        phraseIssues.push('Missing phrase text');
      }
      if (!phrase.category?.trim()) {
        phraseIssues.push('Missing category');
      }
      if (!['Easy', 'Medium', 'Hard'].includes(phrase.difficulty)) {
        phraseIssues.push('Invalid difficulty level');
      }
      if (!phrase.tags?.trim()) {
        phraseIssues.push('Missing tags');
      }

      if (phraseIssues.length > 0) {
        issues.push({ id: phrase.id, issues: phraseIssues });
      }
    });

    return {
      success: true,
      message: `Validation complete. Found ${issues.length} phrases with issues.`,
      details: { issues }
    };
  } catch (err) {
    console.error('Error validating database:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while validating the database'
    };
  }
};

/**
 * Performs database backup
 */
export const backupDatabase = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    // Convert to CSV
    const headers = Object.keys(data[0]);
    const csv = [
      headers.join(','),
      ...data.map((row: Record<string, any>) =>
        headers
          .map(header => {
            const cell = row[header]?.toString() ?? '';
            return `"${cell.replace(/"/g, '""')}"`;
          })
          .join(',')
      )
    ].join('\n');

    // Create backup timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `phrases-backup-${timestamp}.csv`;

    return {
      success: true,
      message: 'Backup created successfully.',
      details: {
        filename,
        content: csv,
        timestamp,
        recordCount: data.length
      }
    };
  } catch (err) {
    console.error('Error creating backup:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while creating backup'
    };
  }
};


============================================================

FILE: .\lib\utils\formatters.ts
SIZE: 4.56 KB
LAST MODIFIED: 02/09/2025 10:16:11

/**
 * Formats a number with commas for thousands
 */
export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('en-US').format(num);
};

/**
 * Formats a number as a percentage
 */
export const formatPercent = (num: number, decimals: number = 0): string => {
  return `${num.toFixed(decimals)}%`;
};

/**
 * Formats a date in a localized format
 */
export const formatDate = (date: Date | string | null): string => {
  if (!date) return 'Never';
  
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

/**
 * Formats a date relative to now (e.g., "2 days ago")
 */
export const formatRelativeDate = (date: Date | string | null): string => {
  if (!date) return 'Never';

  const now = new Date();
  const then = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - then.getTime()) / 1000);
  
  if (diffInSeconds < 60) {
    return 'just now';
  }
  
  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes} minute${diffInMinutes === 1 ? '' : 's'} ago`;
  }
  
  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours} hour${diffInHours === 1 ? '' : 's'} ago`;
  }
  
  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 30) {
    return `${diffInDays} day${diffInDays === 1 ? '' : 's'} ago`;
  }
  
  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) {
    return `${diffInMonths} month${diffInMonths === 1 ? '' : 's'} ago`;
  }
  
  const diffInYears = Math.floor(diffInMonths / 12);
  return `${diffInYears} year${diffInYears === 1 ? '' : 's'} ago`;
};

/**
 * Formats difficulty level with color class
 */
export const formatDifficulty = (difficulty: string): { text: string; colorClass: string } => {
  const normalized = difficulty.toLowerCase();
  switch (normalized) {
    case 'easy':
      return { text: 'Easy', colorClass: 'text-green-400' };
    case 'medium':
      return { text: 'Medium', colorClass: 'text-yellow-400' };
    case 'hard':
      return { text: 'Hard', colorClass: 'text-red-400' };
    default:
      return { text: difficulty, colorClass: 'text-gray-400' };
  }
};

/**
 * Formats tags as an array with optional truncation
 */
export const formatTags = (tags: string, maxTags?: number): string[] => {
  const tagArray = tags.split(',').map(tag => tag.trim()).filter(Boolean);
  if (maxTags && tagArray.length > maxTags) {
    return [...tagArray.slice(0, maxTags), `+${tagArray.length - maxTags} more`];
  }
  return tagArray;
};

/**
 * Formats file size in bytes to human readable format
 */
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
};

/**
 * Formats a string to title case
 */
export const formatTitleCase = (str: string): string => {
  return str
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

/**
 * Formats text with ellipsis if it exceeds max length
 */
export const formatTruncate = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength)}...`;
};

/**
 * Formats category for display
 */
export const formatCategory = (category: string): { text: string; icon: string } => {
  const normalized = category.toLowerCase();
  switch (normalized) {
    case 'movies':
      return { text: 'Movies', icon: 'ðŸŽ¬' };
    case 'tv':
      return { text: 'TV Shows', icon: 'ðŸ“º' };
    case 'books':
      return { text: 'Books', icon: 'ðŸ“š' };
    case 'music':
      return { text: 'Music', icon: 'ðŸŽµ' };
    case 'games':
      return { text: 'Games', icon: 'ðŸŽ®' };
    default:
      return { text: formatTitleCase(category), icon: 'ðŸ“' };
  }
};

/**
 * Formats CSV data into a downloadable string
 */
export const formatCSV = (data: Record<string, any>[]): string => {
  if (data.length === 0) return '';

  const headers = Object.keys(data[0]);
  const rows = data.map(row => 
    headers
      .map(header => {
        const cell = row[header]?.toString() ?? '';
        return `"${cell.replace(/"/g, '""')}"`;
      })
      .join(',')
  );

  return [headers.join(','), ...rows].join('\n');
};

============================================================

FILE: .\lib\utils\phraseUtils.ts
SIZE: 6.53 KB
LAST MODIFIED: 02/09/2025 10:18:26

import type { Phrase, NewPhrase, TagValidationResult } from '@/types/types';

/**
 * Validates and formats tags
 */
export const validateTags = (tags: string): TagValidationResult => {
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  const errors: string[] = [];
  
  if (tagArray.length === 0) {
    errors.push('At least one tag is required');
  }
  
  if (tagArray.some(tag => tag.length < 2)) {
    errors.push('Tags must be at least 2 characters long');
  }
  
  if (tagArray.some(tag => !/^[a-zA-Z0-9\s]+$/.test(tag))) {
    errors.push('Tags can only contain letters, numbers, and spaces');
  }

  const formattedTags = tagArray.join(',');

  return {
    isValid: errors.length === 0,
    formattedTags,
    errors
  };
};

/**
 * Formats and sanitizes a phrase object
 */
export const sanitizePhrase = (phrase: Partial<Phrase | NewPhrase>): Partial<Phrase | NewPhrase> => {
  return {
    ...phrase,
    phrase: phrase.phrase?.trim(),
    category: phrase.category?.trim(),
    difficulty: phrase.difficulty?.trim(),
    subcategory: phrase.subcategory?.trim(),
    tags: phrase.tags?.split(',').map(t => t.trim()).filter(Boolean).join(','),
    hint: phrase.hint?.trim(),
    part_of_speech: phrase.part_of_speech?.trim()
  };
};

/**
 * Groups phrases by category
 */
export const groupPhrasesByCategory = (phrases: Phrase[]): Record<string, Phrase[]> => {
  return phrases.reduce((acc, phrase) => {
    const category = phrase.category || 'Uncategorized';
    acc[category] = acc[category] || [];
    acc[category].push(phrase);
    return acc;
  }, {} as Record<string, Phrase[]>);
};

/**
 * Filters phrases based on search criteria
 */
export const filterPhrases = (
  phrases: Phrase[],
  filters: {
    searchTerm?: string;
    category?: string;
    difficulty?: string;
    subcategory?: string;
    part_of_speech?: string;
  }
): Phrase[] => {
  return phrases.filter(phrase => {
    const searchTermMatch = !filters.searchTerm || 
      phrase.phrase.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
      phrase.tags.toLowerCase().includes(filters.searchTerm.toLowerCase());

    const categoryMatch = !filters.category || 
      phrase.category.toLowerCase() === filters.category.toLowerCase();

    const difficultyMatch = !filters.difficulty || 
      phrase.difficulty.toLowerCase() === filters.difficulty.toLowerCase();

    const subcategoryMatch = !filters.subcategory || 
      phrase.subcategory.toLowerCase() === filters.subcategory.toLowerCase();

    const partOfSpeechMatch = !filters.part_of_speech || 
      phrase.part_of_speech.toLowerCase() === filters.part_of_speech.toLowerCase();

    return searchTermMatch && categoryMatch && difficultyMatch && 
           subcategoryMatch && partOfSpeechMatch;
  });
};

/**
 * Sorts phrases by specified criteria
 */
export const sortPhrases = (
  phrases: Phrase[],
  sortKey: keyof Phrase,
  sortDirection: 'asc' | 'desc'
): Phrase[] => {
  return [...phrases].sort((a, b) => {
    const aVal = a[sortKey];
    const bVal = b[sortKey];

    if (aVal === bVal) return 0;
    
    if (aVal === null || aVal === undefined) return 1;
    if (bVal === null || bVal === undefined) return -1;

    const comparison = aVal < bVal ? -1 : 1;
    return sortDirection === 'asc' ? comparison : -comparison;
  });
};

/**
 * Checks if a phrase needs review (hasn't been used in a while)
 */
export const needsReview = (phrase: Phrase, daysThreshold: number = 30): boolean => {
  if (!phrase.last_used) return true;
  
  const lastUsed = new Date(phrase.last_used);
  const now = new Date();
  const diffTime = Math.abs(now.getTime() - lastUsed.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  return diffDays > daysThreshold;
};

/**
 * Gets phrases that haven't been used in a while
 */
export const getPhrasesNeedingReview = (
  phrases: Phrase[],
  daysThreshold: number = 30
): Phrase[] => {
  return phrases.filter(phrase => needsReview(phrase, daysThreshold));
};

/**
 * Gets phrases by difficulty level
 */
export const getPhrasesByDifficulty = (
  phrases: Phrase[],
  difficulty: string
): Phrase[] => {
  return phrases.filter(
    phrase => phrase.difficulty.toLowerCase() === difficulty.toLowerCase()
  );
};

/**
 * Gets related phrases based on tags
 */
export const getRelatedPhrases = (
  phrases: Phrase[],
  currentPhrase: Phrase,
  maxResults: number = 5
): Phrase[] => {
  const currentTags = new Set(currentPhrase.tags.split(',').map(t => t.trim()));
  
  return phrases
    .filter(phrase => phrase.id !== currentPhrase.id)
    .map(phrase => {
      const phraseTags = new Set(phrase.tags.split(',').map(t => t.trim()));
      const commonTags = new Set(
        [...currentTags].filter(tag => phraseTags.has(tag))
      );
      return {
        phrase,
        commonTagCount: commonTags.size
      };
    })
    .filter(({ commonTagCount }) => commonTagCount > 0)
    .sort((a, b) => b.commonTagCount - a.commonTagCount)
    .slice(0, maxResults)
    .map(({ phrase }) => phrase);
};

/**
 * Gets phrase usage statistics
 */
export const getPhraseUsageStats = (phrases: Phrase[]) => {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.setDate(now.getDate() - 30));
  
  return phrases.reduce((stats, phrase) => {
    if (!phrase.last_used) {
      stats.neverUsed++;
    } else {
      const lastUsed = new Date(phrase.last_used);
      if (lastUsed < thirtyDaysAgo) {
        stats.notRecentlyUsed++;
      } else {
        stats.recentlyUsed++;
      }
    }
    return stats;
  }, {
    neverUsed: 0,
    notRecentlyUsed: 0,
    recentlyUsed: 0
  });
};

/**
 * Gets the most used tags across all phrases
 */
export const getMostUsedTags = (
  phrases: Phrase[],
  limit: number = 10
): Array<{ tag: string; count: number }> => {
  const tagCounts = phrases.reduce((acc, phrase) => {
    phrase.tags.split(',').forEach(tag => {
      const trimmedTag = tag.trim();
      acc[trimmedTag] = (acc[trimmedTag] || 0) + 1;
    });
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(tagCounts)
    .map(([tag, count]) => ({ tag, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, limit);
};

export default {
  validateTags,
  sanitizePhrase,
  groupPhrasesByCategory,
  filterPhrases,
  sortPhrases,
  needsReview,
  getPhrasesNeedingReview,
  getPhrasesByDifficulty,
  getRelatedPhrases,
  getPhraseUsageStats,
  getMostUsedTags
};

============================================================

FILE: .\lib\utils\safeStorage.ts
SIZE: 0.79 KB
LAST MODIFIED: 03/05/2025 15:17:36

// Add this utility function somewhere in your utils folder
// utils/safeStorage.ts

export const safeStorage = {
  getItem: (key: string): string | null => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        return localStorage.getItem(key);
      }
      return null;
    } catch (error) {
      console.warn('Unable to access localStorage:', error);
      return null;
    }
  },
    
    setItem: (key: string, value: string): boolean => {
      try {
        if (typeof window !== 'undefined' && window.localStorage) {
          localStorage.setItem(key, value);
          return true;
        }
        return false;
      } catch (error) {
        console.warn('Unable to access localStorage:', error);
        return false;
      }
    }
  };

============================================================

FILE: .\lib\utils\statsUtils.ts
SIZE: 4.29 KB
LAST MODIFIED: 02/09/2025 10:15:14

import { SupabaseClient } from '@supabase/supabase-js';
import type { Stats, Phrase } from '@/types/types';

interface StatsResult {
  data: Stats | null;
  error: string | null;
}

/**
 * Calculates statistics from phrase data
 */
export const calculateStats = async (supabase: SupabaseClient): Promise<StatsResult> => {
  try {
    const { data: phrases, error, count } = await supabase
      .from('phrases')
      .select('*', { count: 'exact' });

    if (error) throw error;
    if (!phrases || phrases.length === 0) {
      return {
        data: {
          total: 0,
          uniqueCategories: 0,
          difficultyBreakdown: { easy: 0, medium: 0, hard: 0 }
        },
        error: null
      };
    }

    // Calculate unique categories
    const uniqueCategories = new Set(phrases.map(p => p.category)).size;

    // Calculate difficulty breakdown
    const difficultyCount = phrases.reduce((acc, phrase) => {
      const difficulty = phrase.difficulty.toLowerCase();
      acc[difficulty] = (acc[difficulty] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const total = count || phrases.length;

    // Calculate percentages with rounding adjustments
    let easy = Math.round((difficultyCount['easy'] || 0) / total * 100);
    let medium = Math.round((difficultyCount['medium'] || 0) / total * 100);
    let hard = Math.round((difficultyCount['hard'] || 0) / total * 100);

    // Adjust for rounding errors to ensure sum is 100
    const sum = easy + medium + hard;
    if (sum !== 100) {
      const diff = 100 - sum;
      if (easy >= medium && easy >= hard) {
        easy += diff;
      } else if (medium >= easy && medium >= hard) {
        medium += diff;
      } else {
        hard += diff;
      }
    }

    return {
      data: {
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard
        }
      },
      error: null
    };
  } catch (err) {
    console.error('Error calculating stats:', err);
    return {
      data: null,
      error: err instanceof Error ? err.message : 'An unknown error occurred'
    };
  }
};

/**
 * Calculates usage statistics for phrases
 */
export const calculateUsageStats = (phrases: Phrase[]) => {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.setDate(now.getDate() - 30));

  return phrases.reduce((stats, phrase) => {
    if (!phrase.last_used) {
      stats.neverUsed++;
    } else {
      const lastUsed = new Date(phrase.last_used);
      if (lastUsed < thirtyDaysAgo) {
        stats.notRecentlyUsed++;
      } else {
        stats.recentlyUsed++;
      }
    }
    return stats;
  }, {
    neverUsed: 0,
    notRecentlyUsed: 0,
    recentlyUsed: 0
  });
};

/**
 * Calculates category distribution
 */
export const calculateCategoryStats = (phrases: Phrase[]) => {
  const categoryCount = phrases.reduce((acc, phrase) => {
    acc[phrase.category] = (acc[phrase.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Convert to percentages
  const total = phrases.length;
  const categoryPercentages = Object.entries(categoryCount).map(([category, count]) => ({
    category,
    percentage: Math.round((count / total) * 100)
  }));

  // Sort by percentage descending
  return categoryPercentages.sort((a, b) => b.percentage - a.percentage);
};

/**
 * Calculates difficulty distribution over time
 */
export const calculateDifficultyTrends = (phrases: Phrase[]) => {
  // Group by month
  const monthlyStats = phrases.reduce((acc, phrase) => {
    const date = phrase.last_used 
      ? new Date(phrase.last_used)
      : new Date();
    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    
    if (!acc[monthKey]) {
      acc[monthKey] = { easy: 0, medium: 0, hard: 0 };
    }
    
    const difficulty = phrase.difficulty.toLowerCase();
    acc[monthKey][difficulty as 'easy' | 'medium' | 'hard']++;
    
    return acc;
  }, {} as Record<string, Record<'easy' | 'medium' | 'hard', number>>);

  // Convert to array and sort by date
  return Object.entries(monthlyStats)
    .map(([month, stats]) => ({
      month,
      ...stats
    }))
    .sort((a, b) => a.month.localeCompare(b.month));
};

============================================================

FILE: .\lib\utils\validators.ts
SIZE: 3.81 KB
LAST MODIFIED: 02/09/2025 10:13:27

import type { TagValidationResult, Phrase, NewPhrase } from '@/types/types';

/**
 * Validates tags input
 */
export const validateTags = (tags: string): TagValidationResult => {
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  const errors: string[] = [];
  
  if (tagArray.length === 0) {
    errors.push('At least one tag is required');
  }
  
  if (tagArray.some(tag => tag.length < 2)) {
    errors.push('Tags must be at least 2 characters long');
  }
  
  if (tagArray.some(tag => !/^[a-zA-Z0-9\s]+$/.test(tag))) {
    errors.push('Tags can only contain letters, numbers, and spaces');
  }

  return {
    isValid: errors.length === 0,
    formattedTags: tagArray.join(','),
    errors
  };
};

/**
 * Validates a complete phrase object
 */
export const validatePhrase = (phrase: Partial<Phrase | NewPhrase>): {
  isValid: boolean;
  errors: Record<string, string>;
} => {
  const errors: Record<string, string> = {};

  // Required fields
  if (!phrase.phrase?.trim()) {
    errors.phrase = 'Phrase is required';
  }

  if (!phrase.category?.trim()) {
    errors.category = 'Category is required';
  }

  if (!phrase.difficulty?.trim()) {
    errors.difficulty = 'Difficulty is required';
  }

  if (!phrase.part_of_speech?.trim()) {
    errors.part_of_speech = 'Part of speech is required';
  }

  // Length validations
  if (phrase.phrase && phrase.phrase.length < 2) {
    errors.phrase = 'Phrase must be at least 2 characters long';
  }

  if (phrase.subcategory && phrase.subcategory.length < 2) {
    errors.subcategory = 'Subcategory must be at least 2 characters long';
  }

  // Validate difficulty values
  if (
    phrase.difficulty &&
    !['Easy', 'Medium', 'Hard'].includes(phrase.difficulty)
  ) {
    errors.difficulty = 'Invalid difficulty value';
  }

  // Validate tags
  if (phrase.tags) {
    const tagValidation = validateTags(phrase.tags);
    if (!tagValidation.isValid) {
      errors.tags = tagValidation.errors?.[0] || 'Invalid tags';
    }
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

/**
 * Validates bulk import data format
 */
export const validateBulkImport = (
  data: string
): { isValid: boolean; errors: string[] } => {
  const errors: string[] = [];
  const lines = data.trim().split('\n');

  if (lines.length === 0) {
    errors.push('No data provided');
    return { isValid: false, errors };
  }

  lines.forEach((line, index) => {
    const fields = line.split(',').map(field => field.trim());

    if (fields.length !== 7) {
      errors.push(
        `Line ${index + 1}: Expected 7 fields but got ${fields.length}`
      );
      return;
    }

    const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = fields;

    if (!phrase) {
      errors.push(`Line ${index + 1}: Phrase is required`);
    }

    if (!category) {
      errors.push(`Line ${index + 1}: Category is required`);
    }

    if (!['Easy', 'Medium', 'Hard'].includes(difficulty)) {
      errors.push(`Line ${index + 1}: Invalid difficulty value`);
    }

    const tagValidation = validateTags(tags);
    if (!tagValidation.isValid) {
      errors.push(`Line ${index + 1}: ${tagValidation.errors?.[0]}`);
    }
  });

  return {
    isValid: errors.length === 0,
    errors
  };
};

/**
 * Formats and sanitizes phrase data
 */
export const sanitizePhrase = (phrase: Partial<Phrase | NewPhrase>): Partial<Phrase | NewPhrase> => {
  return {
    ...phrase,
    phrase: phrase.phrase?.trim(),
    category: phrase.category?.trim(),
    subcategory: phrase.subcategory?.trim(),
    tags: phrase.tags?.split(',').map(t => t.trim()).filter(Boolean).join(','),
    hint: phrase.hint?.trim(),
    part_of_speech: phrase.part_of_speech?.trim()
  };
};

============================================================

FILE: .\providers\ThemeProvider.tsx
SIZE: 0.77 KB
LAST MODIFIED: 03/06/2025 21:02:46

"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

/**
 * Hook for using the theme
 * @returns Theme utilities including theme, setTheme, and systemTheme
 */
export function useTheme() {
  const { theme, setTheme, systemTheme } = React.useContext(
    // @ts-ignore - This context does exist in next-themes
    require("next-themes").ThemeContext
  )
  
  return { 
    theme, 
    setTheme, 
    systemTheme,
    toggleTheme: () => setTheme(theme === "dark" ? "light" : "dark")
  }
}

============================================================

FILE: .\services\dashboard-data-service.ts
SIZE: 7.64 KB
LAST MODIFIED: 03/09/2025 21:52:03

// src/services/dashboard-data-service.ts
import { supabase } from '@/lib/services/supabase';

export const DashboardDataService = {
  // Fetch phrase timestamps
  fetchPhrasesOverTime: async () => {
    try {
      // Use the created_at column from the phrases table
      const { data, error } = await supabase
        .from('phrases')
        .select('created_at')
        .order('created_at');

      if (error) {
        console.error('Error fetching phrase timestamps:', error);
        return { data: null, error };
      }

      if (data && data.length > 0) {
        return { data, error: null };
      } else {
        return { data: null, error: new Error('No data found') };
      }
    } catch (err) {
      console.error('Error fetching phrase timestamps:', err);
      return { data: null, error: err };
    }
  },

  // Process timestamp data into monthly buckets
  processTimestampData: (data) => {
    const monthCounts = {};

    data.forEach((item) => {
      if (!item.created_at) return;

      const date = new Date(item.created_at);
      const month = date.toLocaleString('default', { month: 'short' });
      const year = date.getFullYear();
      const key = `${month} ${year}`;

      if (!monthCounts[key]) {
        monthCounts[key] = { month, year, count: 0, fullDate: date };
      }
      monthCounts[key].count++;
    });

    // Convert to array, sort by date, and take the most recent 6 months
    return Object.values(monthCounts)
      .sort((a, b) => a.fullDate - b.fullDate)
      .map((item) => ({
        month: item.month,
        year: item.year,
        phrases: item.count,
      }))
      .slice(-6);
  },

  // Generate error state data when no data is available
  getErrorStateData: () => {
    // Return a special data format that indicates an error condition
    return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'].map((month) => ({
      month,
      year: new Date().getFullYear(),
      phrases: null // Use null to indicate missing/error data
    }));
  },

  // Generate monthly activity data
  generateMonthlyActivityData: () => {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
    return months.map(month => ({
      name: month,
      reviews: Math.floor(Math.random() * 100) + 50,
      additions: Math.floor(Math.random() * 40) + 10,
      edits: Math.floor(Math.random() * 30) + 5,
    }));
  },

  // Generate category distribution data
  generateCategoryData: (categories) => {
    if (categories && categories.length > 0) {
      return [
        { name: 'Animals & Plants', value: 30 },
        { name: 'Art & Design', value: 22 },
        { name: 'Education & Learning', value: 13 },
        { name: 'Celebrations & Traditions', value: 16 },
        { name: 'Business & Careers', value: 19 },
      ];
    }
    
    return [
      { name: 'Animals & Plants', value: 30 },
      { name: 'Art & Design', value: 22 },
      { name: 'Education & Learning', value: 13 },
      { name: 'Celebrations & Traditions', value: 16 },
      { name: 'Business & Careers', value: 19 },
    ];
  },

  // Export data
  handleExport: async (options) => {
    try {
      const { data: phrases, error: phrasesError } = await supabase
        .from('phrases')
        .select(`
          id,
          phrase,
          part_of_speech,
          hint,
          category_id,
          subcategory_id,
          difficulty,
          categories:category_id(name),
          subcategories:subcategory_id(name)
        `);

      if (phrasesError) throw phrasesError;

      const { data: phraseTags, error: tagsError } = await supabase
        .from('phrase_tags')
        .select(`
          phrase_id,
          tags:tag_id(tag)
        `);

      if (tagsError) throw tagsError;

      const tagsByPhraseId = {};
      phraseTags.forEach((item) => {
        if (!tagsByPhraseId[item.phrase_id]) {
          tagsByPhraseId[item.phrase_id] = [];
        }
        tagsByPhraseId[item.phrase_id].push(item.tags.tag);
      });

      const categorizedPhrases = {};
      phrases.forEach((phrase) => {
        const categoryName = phrase.categories ? phrase.categories.name : 'Uncategorized';

        if (!categorizedPhrases[categoryName]) {
          categorizedPhrases[categoryName] = [];
        }

        categorizedPhrases[categoryName].push({
          text: phrase.phrase,
          pos: phrase.part_of_speech,
          hint: phrase.hint || '',
          difficulty: phrase.difficulty || 1,
          subcategory: phrase.subcategories ? phrase.subcategories.name : null,
          tags: tagsByPhraseId[phrase.id] || [],
        });
      });

      const esp32Data = {};
      Object.keys(categorizedPhrases).forEach((cat) => {
        if (options.optimizeForESP32) {
          // Optimized format for ESP32
          esp32Data[cat] = categorizedPhrases[cat].map(p => ({
            t: p.text,                    // text (shortened property name)
            h: p.hint || '',              // hint (shortened property name)
            d: p.difficulty || 1          // difficulty (shortened property name)
          }));
        } else {
          // Full format
          esp32Data[cat] = categorizedPhrases[cat];
        }
      });

      const headerContent = options.exportHeader ? DashboardDataService.generateArduinoHeader(esp32Data) : '';

      return {
        jsonData: esp32Data,
        headerContent,
      };
    } catch (error) {
      console.error('Export error:', error);
      return null;
    }
  },

  // Generate Arduino header file
  generateArduinoHeader: (data) => {
    let headerContent = `// Auto-generated phrases header file
#ifndef PHRASES_H
#define PHRASES_H

#include <Arduino.h>

struct Phrase {
  const char* text;
  const char* hint;
  uint8_t difficulty;
};

`;

    Object.keys(data).forEach((category) => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      const phrases = data[category];

      headerContent += `// ${category} phrases\n`;
      headerContent += `constexpr Phrase ${categoryVar}_phrases[] PROGMEM = {\n`;

      phrases.forEach((phrase) => {
        const text = phrase.t || phrase.text;
        const hint = phrase.h || phrase.hint || '';
        const difficulty = phrase.d || phrase.difficulty || 1;

        headerContent += `  {"${DashboardDataService.escapeString(text)}", "${DashboardDataService.escapeString(hint)}", ${difficulty}},\n`;
      });

      headerContent += `};\n\n`;
      headerContent += `constexpr size_t ${categoryVar}_count = ${phrases.length};\n\n`;
    });

    headerContent += `// Category index\n`;
    headerContent += `struct PhraseCategory {\n`;
    headerContent += `  const char* name;\n`;
    headerContent += `  const Phrase* phrases;\n`;
    headerContent += `  size_t count;\n`;
    headerContent += `};\n\n`;

    headerContent += `constexpr PhraseCategory phrase_categories[] PROGMEM = {\n`;
    Object.keys(data).forEach((category) => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      headerContent += `  {"${DashboardDataService.escapeString(category)}", ${categoryVar}_phrases, ${categoryVar}_count},\n`;
    });
    headerContent += `};\n\n`;

    headerContent += `constexpr size_t category_count = ${Object.keys(data).length};\n\n`;
    headerContent += `#endif // PHRASES_H\n`;

    return headerContent;
  },

  // Helper function to escape strings for C++ code
  escapeString: (str) => {
    if (!str) return "";
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n');
  }
};

============================================================

FILE: .\types\supabase.ts
SIZE: 3.57 KB
LAST MODIFIED: 02/16/2025 18:12:15

// src/types/supabase.ts
export type Database = {
  public: {
    Tables: {
      phrases: {
        Row: {
          id: number
          phrase: string | null
          part_of_speech: string | null
          hint: string | null
          category_id: number | null
          subcategory_id: number | null
          difficulty: number | null
        }
        Insert: {
          id?: number
          phrase?: string | null
          part_of_speech?: string | null
          hint?: string | null
          category_id?: number | null
          subcategory_id?: number | null
          difficulty?: number | null
        }
        Update: {
          id?: number
          phrase?: string | null
          part_of_speech?: string | null
          hint?: string | null
          category_id?: number | null
          subcategory_id?: number | null
          difficulty?: number | null
        }
      }
      categories: {
        Row: {
          id: number
          name: string
        }
        Insert: {
          id?: number
          name: string
        }
        Update: {
          id?: number
          name?: string
        }
      }
      subcategories: {
        Row: {
          id: number
          name: string
          category_id: number | null
        }
        Insert: {
          id?: number
          name: string
          category_id?: number | null
        }
        Update: {
          id?: number
          name?: string
          category_id?: number | null
        }
      }
      tags: {
        Row: {
          id: number
          tag: string
        }
        Insert: {
          id?: number
          tag: string
        }
        Update: {
          id?: number
          tag?: string
        }
      }
      phrase_tags: {
        Row: {
          phrase_id: number
          tag_id: number
        }
        Insert: {
          phrase_id: number
          tag_id: number
        }
        Update: {
          phrase_id?: number
          tag_id?: number
        }
      }
      votes: {
        Row: {
          id: string // uuid
          reviewer_id: string // uuid
          phrase_id: number
          category: string // USER-DEFINED type
          vote: boolean
          created_at: string // timestamp with time zone
        }
        Insert: {
          id?: string
          reviewer_id: string
          phrase_id: number
          category: string
          vote: boolean
          created_at?: string
        }
        Update: {
          id?: string
          reviewer_id?: string
          phrase_id?: number
          category?: string
          vote?: boolean
          created_at?: string
        }
      }
      reviewers: {
        Row: {
          id: string // uuid
          name: string
          total_reviews: number | null
          created_at: string // timestamp with time zone
          pin: string
          last_review_at: string | null // timestamp with time zone
          current_streak: number | null
        }
        Insert: {
          id?: string
          name: string
          total_reviews?: number | null
          created_at?: string
          pin?: string
          last_review_at?: string | null
          current_streak?: number | null
        }
        Update: {
          id?: string
          name?: string
          total_reviews?: number | null
          created_at?: string
          pin?: string
          last_review_at?: string | null
          current_streak?: number | null
        }
      }
    }
  }
}

============================================================

FILE: .\types\types.ts
SIZE: 5.35 KB
LAST MODIFIED: 02/16/2025 15:56:38

import type { Session } from '@supabase/supabase-js';

export interface PhraseWithRelations extends Phrase {
  categories: Category;
  subcategories?: Subcategory;
  phrase_tags: {
    tags: Tag;
  }[];
}

export interface SupabaseQueryResponse<T> {
  data: T[] | null;
  error: any;
  count?: number | null;
}

export interface Category {
  id: number;
  name: string;
}

export interface PhraseTagWithTag {
  tag_id: number;
  tags: {
    id: number;
    tag: string;
  };
}

export type SubcategoryName = {
  name: string;
}

export interface Subcategory {
  id: number;
  name: string;
  category_id: number;
}

export interface Tag {
  id: number;
  tag: string;
}

export interface PhraseTag {
  phrase_id: number;
  tag_id: number;
}

export interface PhraseBase {
  phrase: string;
  category_id: number;
  subcategory_id?: number | null;
  difficulty: number;  // Changed from string to number
  part_of_speech: string;
  hint?: string | null;
}

export interface Phrase extends Omit<PhraseBase, 'category_id' | 'subcategory_id'> {
  id: number;
  category: string;
  subcategory?: string;
  tags: string;
  difficulty: number;
}

export interface NewPhrase {
  phrase: string;
  category: string;
  subcategory?: string;
  difficulty: string;
  part_of_speech: string;
  hint?: string;
  tags?: string;
}

export interface Vote {
  id: string;
  reviewer_id: string;
  phrase_id: number;
  category: VoteCategory;
  vote: boolean;
  created_at: string;
}

export type VoteCategory = 'phrase' | 'category' | 'subcategory' | 'hint' | 'tags' | 'difficulty';

export interface Filters {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
}

export interface PaginationState {
  currentPage: number;
  rowsPerPage: number;
  totalPages: number;
}

export interface SortConfig {
  key: keyof Phrase | '';
  direction: 'asc' | 'desc';
}

export interface Stats {
  total: number;
  uniqueCategories: number;
  difficultyBreakdown: {
    easy: number;
    medium: number;
    hard: number;
  };
}

export interface Reviewer {
  id: string;
  name: string;
  pin: string;
  total_reviews: number;
  current_streak: number;
  last_review_at: string | null;
}

export interface BulkImportFormProps {
  onSuccess: (importedIds?: number[]) => void;
  onError: (errorMessage: string) => void;
  categories?: string[];
  difficulties?: string[];
  partsOfSpeech?: string[];
}

export interface ImportedPhrase extends NewPhrase {
  id: number;
}

export interface AddPhraseFormProps {
  onAddPhrase: (phrase: NewPhrase) => Promise<void>;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
}

export interface FilterControlsProps {
  filters: Filters;
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading?: boolean;
}

export interface PhrasesTableProps {
  phrases: Phrase[];
  loading: boolean;
  pagination: PaginationState;
  sortConfig: SortConfig;
  onSort: (key: keyof Phrase) => void;
  onPageChange: (page: number) => void;
  onRowsPerPageChange: (rowsPerPage: number) => void;
  onEdit: (phrase: Phrase) => Promise<void>;
  onDelete: (id: number) => Promise<void>;
  onShowCardView: () => void;
  newIds?: number[];
}

export interface CardViewModalProps {
  isOpen: boolean;
  onClose: () => void;
  phrases: Phrase[];
  currentIndex: number;
  onNavigate: (index: number) => void;
  isEditing: boolean;
  editedPhrase: Phrase | null;
  onEdit: () => void;
  onSave: () => void;
  onCancel: () => void;
  onEditChange: (field: keyof Phrase, value: string) => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  reviewer?: Reviewer;
  onTagClick?: (tag: string) => void;
  loading?: boolean;
  error?: string | null;
}

export interface UsePhrasesReturn {
  phrases: Phrase[];
  loading: boolean;
  error: string | null;
  setError: (error: string | null) => void;
  pagination: PaginationState;
  sortConfig: SortConfig;
  filters: Filters;
  handleSort: (key: keyof Phrase) => void;
  handlePageChange: (page: number) => void;
  handleRowsPerPageChange: (rowsPerPage: number) => void;
  handleFilterChange: (name: string, value: string) => void;
  addPhrase: (phrase: NewPhrase) => Promise<void>;
  editPhrase: (phrase: Phrase) => Promise<void>;
  deletePhrase: (id: number) => Promise<void>;
  fetchPhrases: () => Promise<void>;
  resetFilters: () => void;
  sortByIdDesc: () => void;
}

export interface TagValidationResult {
  isValid: boolean;
  formattedTags: string;
  errors?: string[];
}

export interface UsePaginationProps {
  totalItems: number;
  itemsPerPage: number;
  currentPage: number;
}

export interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

export interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
}

export interface SelectProps {
  value: string;
  onChange: (value: string) => void;
  options: string[];
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  className?: string;
}

export interface StatsSectionProps {
  stats: Stats | null;
  loading: boolean;
}
