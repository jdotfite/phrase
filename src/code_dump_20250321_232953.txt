PROJECT ANALYSIS
Generated: 03/21/2025 23:29:53
Directory: C:\_websites\catch-phrase\src

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: 5.1.19041.5607
OS: Microsoft Windows 10 Pro
Computer Name: OFFICE

============================================================

FILE CONTENTS:

============================================================

FILE: .\code-base.ps1
SIZE: 2.94 KB
LAST MODIFIED: 02/13/2025 10:17:39

# Get current directory path and script start time
$currentPath = (Get-Location).Path
$startTime = Get-Date
$outputFile = "code_dump_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"

# Add exclusion patterns for folders and files
$excludedPaths = @(
    'node_modules',
    '.git',
    'bin',
    'obj',
    'dist',
    'build',
    '.vscode',
    'packages'
)

# Write initial info to console
Write-Host "Starting analysis of $currentPath"
Write-Host "Excluding folders: $($excludedPaths -join ', ')"

# Initial file header
$envInfo = @"
PROJECT ANALYSIS
Generated: $(Get-Date)
Directory: $currentPath

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: $($PSVersionTable.PSVersion)
OS: $(Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty Caption)
Computer Name: $env:COMPUTERNAME
"@
Set-Content -Path $outputFile -Value $envInfo -Encoding utf8

Write-Host "Gathering file list..."

# Get all files, excluding problematic paths
$allFiles = Get-ChildItem -Path $currentPath -Recurse -File | Where-Object {
    $fullPath = $_.FullName
    $exclude = $false
    foreach ($path in $excludedPaths) {
        if ($fullPath -like "*\$path\*") {
            $exclude = $true
            break
        }
    }
    -not $exclude -and
    $_.Name -ne $outputFile -and
    -not $_.Name.EndsWith(".tmp")
}

# Process each file
"`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
"FILE CONTENTS:" | Out-File $outputFile -Append -Encoding utf8

$fileCounter = 0
$totalFiles = $allFiles.Count

# Avoid division by zero
if ($totalFiles -eq 0) {
    Write-Host "No files found to process. Exiting."
    exit
}

$allFiles | Where-Object {
    $_.Extension -notmatch '\.(exe|dll|pdb|obj|bin|cache|jpg|jpeg|png|gif|bmp|ico|mp3|mp4|zip|rar|7z)$' -and
    $_.Length -lt 5MB
} | ForEach-Object {
    $fileCounter++
    $percentComplete = [math]::Round(($fileCounter / $totalFiles) * 100, 1)
    Write-Progress -Activity "Processing Files" -Status "$fileCounter of $totalFiles ($percentComplete%)" -PercentComplete $percentComplete
    Write-Host "Processing ($fileCounter/$totalFiles): $($_.Name)"

    try {
        # Write file metadata
        $relPath = $_.FullName.Replace($currentPath, ".")
        $fileSize = [math]::Round($_.Length / 1KB, 2)
        
        "`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
        "FILE: $relPath`nSIZE: $fileSize KB`nLAST MODIFIED: $($_.LastWriteTime)`n" | Out-File $outputFile -Append -Encoding utf8
        
        # Append file content
        Get-Content $_.FullName -Raw | Out-File $outputFile -Append -Encoding utf8
    } catch {
        Write-Warning "Error processing $($_.FullName): $_"
    }
}

Write-Host "Analysis complete. Output saved to $outputFile"


============================================================

FILE: .\file-structure.ps1
SIZE: 2.99 KB
LAST MODIFIED: 03/17/2025 11:11:08

# Directory Structure Generator for AI Readability
# This script creates a clean, hierarchical text document of the current directory structure
# Format is optimized for AI processing with consistent indentation and clear labeling

$outputFile = "DirectoryStructure.txt"
$indentChar = "    " # 4 spaces for indentation

function Get-FormattedSize {
    param (
        [long]$SizeInBytes
    )
    
    if ($SizeInBytes -lt 1KB) {
        return "$SizeInBytes B"
    }
    elseif ($SizeInBytes -lt 1MB) {
        return "{0:N2} KB" -f ($SizeInBytes / 1KB)
    }
    elseif ($SizeInBytes -lt 1GB) {
        return "{0:N2} MB" -f ($SizeInBytes / 1MB)
    }
    else {
        return "{0:N2} GB" -f ($SizeInBytes / 1GB)
    }
}

function Get-DirectoryStructure {
    param (
        [string]$Path,
        [int]$Level = 0,
        [System.IO.StreamWriter]$Writer
    )

    $indent = $indentChar * $Level
    
    # Get directory information
    $dirInfo = Get-Item -Path $Path
    $dirName = Split-Path -Path $Path -Leaf
    if ($Level -eq 0) {
        $dirName = Resolve-Path -Path $Path
    }
    
    # Write directory entry
    $Writer.WriteLine("$indent[DIR] $dirName")
    
    # Process all files first (for cleaner organization)
    $files = Get-ChildItem -Path $Path -File | Sort-Object Name
    foreach ($file in $files) {
        $size = Get-FormattedSize -SizeInBytes $file.Length
        $extension = if ($file.Extension) { $file.Extension.ToLower() } else { "no-extension" }
        $Writer.WriteLine("$indent$indentChar[FILE] $($file.Name) | Size: $size | Type: $extension | Modified: $($file.LastWriteTime.ToString('yyyy-MM-dd HH:mm:ss'))")
    }
    
    # Then process all subdirectories
    $dirs = Get-ChildItem -Path $Path -Directory | Sort-Object Name
    foreach ($dir in $dirs) {
        Get-DirectoryStructure -Path $dir.FullName -Level ($Level + 1) -Writer $Writer
    }
}

try {
    # Create or overwrite the output file
    $writer = New-Object System.IO.StreamWriter $outputFile
    
    # Write header information
    $writer.WriteLine("DIRECTORY STRUCTURE REPORT")
    $writer.WriteLine("Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')")
    $writer.WriteLine("Computer: $env:COMPUTERNAME")
    $writer.WriteLine("Current User: $env:USERNAME")
    $writer.WriteLine("PowerShell Version: $($PSVersionTable.PSVersion)")
    $writer.WriteLine("---------------------------------------------")
    $writer.WriteLine("")
    
    # Get and write the full directory structure
    $currentPath = Get-Location
    Get-DirectoryStructure -Path $currentPath -Writer $writer
    
    # Close the file
    $writer.Close()
    
    Write-Host "Directory structure has been written to: $((Resolve-Path $outputFile).Path)" -ForegroundColor Green
    Write-Host "This file format is optimized for AI readability." -ForegroundColor Green
}
catch {
    Write-Host "An error occurred: $_" -ForegroundColor Red
    if ($writer) {
        $writer.Close()
    }
}

============================================================

FILE: .\app\globals.css
SIZE: 1.67 KB
LAST MODIFIED: 03/04/2025 21:05:06

@tailwind base;
@tailwind components;
@tailwind utilities;



@layer base {
  :root {

    --background: 0 0% 100%;

    --foreground: 0 0% 3.9%;

    --card: 0 0% 100%;

    --card-foreground: 0 0% 3.9%;

    --popover: 0 0% 100%;

    --popover-foreground: 0 0% 3.9%;

    --primary: 0 0% 9%;

    --primary-foreground: 0 0% 98%;

    --secondary: 0 0% 96.1%;

    --secondary-foreground: 0 0% 9%;

    --muted: 0 0% 96.1%;

    --muted-foreground: 0 0% 45.1%;

    --accent: 0 0% 96.1%;

    --accent-foreground: 0 0% 9%;

    --destructive: 0 84.2% 60.2%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 89.8%;

    --input: 0 0% 89.8%;

    --ring: 0 0% 3.9%;

    --chart-1: 12 76% 61%;

    --chart-2: 173 58% 39%;

    --chart-3: 197 37% 24%;

    --chart-4: 43 74% 66%;

    --chart-5: 27 87% 67%;

    --radius: 0.5rem
  }
  .dark {

    --background: 0 0% 3.9%;

    --foreground: 0 0% 98%;

    --card: 0 0% 3.9%;

    --card-foreground: 0 0% 98%;

    --popover: 0 0% 3.9%;

    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 98%;

    --primary-foreground: 0 0% 9%;

    --secondary: 0 0% 14.9%;

    --secondary-foreground: 0 0% 98%;

    --muted: 0 0% 14.9%;

    --muted-foreground: 0 0% 63.9%;

    --accent: 0 0% 14.9%;

    --accent-foreground: 0 0% 98%;

    --destructive: 0 62.8% 30.6%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 14.9%;

    --input: 0 0% 14.9%;

    --ring: 0 0% 83.1%;

    --chart-1: 220 70% 50%;

    --chart-2: 160 60% 45%;

    --chart-3: 30 80% 55%;

    --chart-4: 280 65% 60%;

    --chart-5: 340 75% 55%
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


============================================================

FILE: .\app\layout.tsx
SIZE: 0.58 KB
LAST MODIFIED: 03/05/2025 16:27:42

import type { Metadata } from "next";
import "./globals.css";
import { ThemeProvider } from "@/providers/ThemeProvider";

export const metadata: Metadata = {
  title: "Catch Phrase Admin",
  description: "Manage your catch phrases",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="font-sans antialiased">
        <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

============================================================

FILE: .\app\page.tsx
SIZE: 0.23 KB
LAST MODIFIED: 02/07/2025 09:27:36

'use client'
 
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
 
export default function Home() {
  const router = useRouter()
  
  useEffect(() => {
    router.push('/admin')
  }, [router])
  
  return null
}

============================================================

FILE: .\app\admin\page.tsx
SIZE: 0.46 KB
LAST MODIFIED: 03/20/2025 23:01:08

// src/app/admin/page.tsx
'use client'

import dynamic from 'next/dynamic';
import { PhrasesListContainer } from '@/features/phrases/components/PhrasesList';

// If you're currently using this pattern:
const Dashboard = dynamic(() => import('@/features/dashboard/Dashboard'), {
  ssr: false
});

export default function AdminPage() {
  // If you have a tab system in your Dashboard component,
  // you'll need to pass the PhrasesListContainer to it
  return <Dashboard />;
}

============================================================

FILE: .\app\api\phrases.ts
SIZE: 0 KB
LAST MODIFIED: 03/20/2025 22:22:15


============================================================

FILE: .\app\api\claude\route.ts
SIZE: 1.41 KB
LAST MODIFIED: 03/01/2025 15:23:07

import { NextResponse } from 'next/server';

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';

export async function POST(req: Request) {
  if (!CLAUDE_API_KEY) {
    console.error('Claude API key is not configured');
    return NextResponse.json(
      { error: 'Claude API key is not configured' },
      { status: 500 }
    );
  }

  try {
    const body = await req.json();
    
    const claudeResponse = await fetch(CLAUDE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-7-sonnet-20250219', // Updated model
        max_tokens: 150,
        messages: body.messages
      })
    });

    if (!claudeResponse.ok) {
      const errorText = await claudeResponse.text();
      console.error('Claude API error:', errorText);
      return NextResponse.json(
        { error: `Claude API error: ${claudeResponse.statusText}` },
        { status: claudeResponse.status }
      );
    }

    const data = await claudeResponse.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

============================================================

FILE: .\app\api\claude\suggest-category\route.ts
SIZE: 2.76 KB
LAST MODIFIED: 03/04/2025 10:15:32

import { NextResponse } from 'next/server';

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';

export async function POST(req: Request) {
  if (!CLAUDE_API_KEY) {
    console.error('Claude API key is not configured');
    return NextResponse.json(
      { error: 'Claude API key is not configured' },
      { status: 500 }
    );
  }

  try {
    const { phrase, categories } = await req.json();
    
    if (!phrase || !Array.isArray(categories) || categories.length === 0) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const messages = [
      {
        role: 'user',
        content: `Choose the most appropriate category for this word or phrase: "${phrase}"
                  
                  Available categories:
                  ${categories.map((cat: string) => `- ${cat}`).join('\n')}
                  
                  Rules:
                  1. Choose exactly ONE category from the list provided
                  2. Consider the meaning, theme, and subject matter
                  3. For ambiguous terms, choose the most likely category
                  4. DO NOT suggest new categories or modify existing ones
                  
                  Return ONLY the exact category name, nothing else.
                  Example: "Sports & Fitness"`
      }
    ];

    const claudeResponse = await fetch(CLAUDE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-7-sonnet-20250219',
        max_tokens: 50,
        messages: messages
      })
    });

    if (!claudeResponse.ok) {
      const errorText = await claudeResponse.text();
      console.error('Claude API error:', errorText);
      return NextResponse.json(
        { error: `Claude API error: ${claudeResponse.statusText}` },
        { status: claudeResponse.status }
      );
    }

    const data = await claudeResponse.json();
    const suggestedCategory = data.content[0].text.trim();
    
    // Verify the category is in our list
    if (!categories.includes(suggestedCategory)) {
      console.error(`Claude suggested an invalid category: "${suggestedCategory}"`);
      return NextResponse.json(
        { error: 'Invalid category suggestion' },
        { status: 500 }
      );
    }

    return NextResponse.json({ category: suggestedCategory });
  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

============================================================

FILE: .\app\api\dashboard\stats\route.ts
SIZE: 0.69 KB
LAST MODIFIED: 03/21/2025 16:56:07

// app/api/dashboard/stats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { DashboardDataService } from '@/services/dashboard-data-service';

export async function POST(request: NextRequest) {
  try {
    const { dateRange = 30 } = await request.json();
    
    const stats = await DashboardDataService.fetchDashboardStats(dateRange);
    
    if (!stats) {
      return NextResponse.json({ error: 'Failed to fetch stats' }, { status: 500 });
    }
    
    return NextResponse.json(stats);
  } catch (error) {
    console.error('Error in stats API route:', error);
    return NextResponse.json({ error: 'Failed to process request' }, { status: 500 });
  }
}

============================================================

FILE: .\components\ui\alert.tsx
SIZE: 2.23 KB
LAST MODIFIED: 02/09/2025 10:34:20

import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-gray-800 border-gray-700 text-white",
        destructive: "border-red-700 bg-red-900/50 text-red-100 [&>svg]:text-red-100",
        success: "border-green-700 bg-green-900/50 text-green-100 [&>svg]:text-green-100",
        warning: "border-yellow-700 bg-yellow-900/50 text-yellow-100 [&>svg]:text-yellow-100",
        info: "border-blue-700 bg-blue-900/50 text-blue-100 [&>svg]:text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> &
    VariantProps<typeof alertVariants> & {
      onClose?: () => void;
    }
>(({ className, variant, children, onClose, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  >
    {children}
    {onClose && (
      <button
        onClick={onClose}
        className="absolute top-4 right-4 p-1 rounded-full hover:bg-gray-700/50 transition-colors"
        aria-label="Close alert"
      >
        <X className="h-4 w-4" />
      </button>
    )}
  </div>
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

============================================================

FILE: .\components\ui\button.tsx
SIZE: 1.69 KB
LAST MODIFIED: 02/09/2025 10:32:42

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-blue-500 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-blue-600 text-white hover:bg-blue-700",
        destructive: "bg-red-600 text-white hover:bg-red-700",
        outline: "border border-gray-600 bg-transparent hover:bg-gray-700 hover:text-white",
        secondary: "bg-gray-600 text-white hover:bg-gray-700",
        ghost: "hover:bg-gray-700 hover:text-white",
        link: "text-blue-500 underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };

============================================================

FILE: .\components\ui\card.tsx
SIZE: 1.79 KB
LAST MODIFIED: 03/21/2025 18:41:24

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-md border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


============================================================

FILE: .\components\ui\chart.tsx
SIZE: 2.92 KB
LAST MODIFIED: 03/07/2025 09:03:03

// components/ui/chart.tsx

"use client"

import * as React from "react"
import { Line, LineChart, ResponsiveContainer, Tooltip } from "recharts"

export type ChartConfig = {
  [key: string]: {
    label: string
    color: string
  }
}

export function ChartContainer({
  config,
  children,
  className,
  ...props
}: React.PropsWithChildren & {
  config: ChartConfig
  className?: string
  [key: string]: any
}) {
  const createCSSVariable = (obj: Record<string, string>) => {
    return Object.entries(obj).reduce((vars, [key, value]) => {
      return {
        ...vars,
        [`--color-${key}`]: value,
      }
    }, {})
  }

  const colors = Object.entries(config).reduce((colors, [key, item]) => {
    return {
      ...colors,
      [key]: item.color,
    }
  }, {})

  const cssVars = createCSSVariable(colors)

  return (
    <div style={cssVars} className={className} {...props}>
      {children}
    </div>
  )
}

export function ChartTooltipContent({
  active,
  payload,
  label,
  config,
  indicator = "circle",
}: {
  active?: boolean
  payload?: any[]
  label?: string
  config?: ChartConfig
  indicator?: "circle" | "line"
}) {
  const TypeIndicator = ({ name }: { name: string }) =>
    indicator === "circle" ? (
      <circle
        cx="6.5"
        cy="6.5"
        r="3.5"
        fill={`var(--color-${name})`}
      />
    ) : (
      <line
        x1="1"
        y1="6.5"
        x2="9"
        y2="6.5"
        stroke={`var(--color-${name})`}
        strokeWidth={2}
        strokeLinecap="round"
      />
    )

  if (!active || !payload) return null

  return (
    <div className="rounded-lg border bg-background p-2 shadow-sm">
      <div className="grid grid-cols-2 gap-2">
        <div className="flex flex-col">
          <span className="text-[0.70rem] uppercase text-muted-foreground">
            {label}
          </span>
        </div>
        <div className="flex flex-col gap-1">
          {payload.map(({ value, name }) => (
            <div key={name} className="flex items-center justify-end gap-1">
              <span className="text-[0.70rem] text-muted-foreground">
                {config?.[name]?.label ?? name}
              </span>
              <span className="font-bold tabular-nums">{value}</span>
              {config?.[name] && (
                <svg
                  width="13"
                  height="13"
                  viewBox="0 0 13 13"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <TypeIndicator name={name} />
                </svg>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

export function ChartTooltip({
  content,
  ...props
}: {
  content?: React.JSXElementConstructor<any>
  [key: string]: any
}) {
  return <Tooltip {...props} content={content} />
}

============================================================

FILE: .\components\ui\checkbox.tsx
SIZE: 1.07 KB
LAST MODIFIED: 03/07/2025 17:11:30

"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

============================================================

FILE: .\components\ui\dialog.tsx
SIZE: 4.78 KB
LAST MODIFIED: 02/09/2025 15:31:45

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-700 bg-gray-800 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-gray-800 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-gray-700 data-[state=open]:text-gray-400">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-400", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

/* Example usage:
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function DialogDemo() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="outline">Edit Profile</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit profile</DialogTitle>
          <DialogDescription>
            Make changes to your profile here.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          Form content here
        </div>
        <DialogFooter>
          <Button type="submit">Save changes</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
*/

============================================================

FILE: .\components\ui\dropdown-menu.tsx
SIZE: 7.37 KB
LAST MODIFIED: 03/07/2025 08:43:08

// components/ui/dropdown-menu.tsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

============================================================

FILE: .\components\ui\input.tsx
SIZE: 0.75 KB
LAST MODIFIED: 03/04/2025 21:21:03

import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


============================================================

FILE: .\components\ui\label.tsx
SIZE: 0.71 KB
LAST MODIFIED: 03/04/2025 21:21:19

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


============================================================

FILE: .\components\ui\modal.tsx
SIZE: 3.93 KB
LAST MODIFIED: 02/09/2025 10:34:53

import * as React from "react";
import { X } from "lucide-react";
import { Button } from "./button";
import { cn } from "@/lib/utils";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: React.ReactNode;
  children: React.ReactNode;
  footer?: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  className?: string;
  showClose?: boolean;
  closeOnOverlayClick?: boolean;
}

const sizeClasses = {
  sm: 'max-w-sm',
  md: 'max-w-md',
  lg: 'max-w-lg',
  xl: 'max-w-xl',
  full: 'max-w-full mx-4'
};

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  size = 'md',
  className,
  showClose = true,
  closeOnOverlayClick = true,
}) => {
  // Handle ESC key
  React.useEffect(() => {
    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener('keydown', handleEsc);
    }
    return () => {
      document.removeEventListener('keydown', handleEsc);
    };
  }, [isOpen, onClose]);

  // Prevent body scroll when modal is open
  React.useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50"
      onClick={closeOnOverlayClick ? onClose : undefined}
    >
      <div
        className={cn(
          "relative bg-gray-800 rounded-lg shadow-xl w-full",
          sizeClasses[size],
          className
        )}
        onClick={e => e.stopPropagation()}
      >
        {/* Header */}
        {(title || showClose) && (
          <div className="flex items-center justify-between p-4 border-b border-gray-700">
            {title && (
              <h2 className="text-lg font-semibold text-white">
                {title}
              </h2>
            )}
            {showClose && (
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 rounded-full"
                onClick={onClose}
                aria-label="Close modal"
              >
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
        )}

        {/* Content */}
        <div className="p-4">
          {children}
        </div>

        {/* Footer */}
        {footer && (
          <div className="flex justify-end gap-2 p-4 border-t border-gray-700">
            {footer}
          </div>
        )}
      </div>
    </div>
  );
};

// Utility components for Modal
export const ModalTitle: React.FC<React.HTMLAttributes<HTMLHeadingElement>> = ({
  children,
  className,
  ...props
}) => (
  <h2
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  >
    {children}
  </h2>
);

export const ModalDescription: React.FC<React.HTMLAttributes<HTMLParagraphElement>> = ({
  children,
  className,
  ...props
}) => (
  <p
    className={cn("text-sm text-gray-400", className)}
    {...props}
  >
    {children}
  </p>
);

export const ModalFooter: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({
  children,
  className,
  ...props
}) => (
  <div
    className={cn(
      "flex justify-end gap-2",
      className
    )}
    {...props}
  >
    {children}
  </div>
);

// Example usage:
/*
<Modal
  isOpen={isOpen}
  onClose={onClose}
  title="Modal Title"
  footer={
    <>
      <Button variant="outline" onClick={onClose}>
        Cancel
      </Button>
      <Button onClick={handleConfirm}>
        Confirm
      </Button>
    </>
  }
>
  <p>Modal content goes here</p>
</Modal>
*/

============================================================

FILE: .\components\ui\pagination.tsx
SIZE: 2.34 KB
LAST MODIFIED: 03/21/2025 09:25:13

// components/ui/pagination.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '@/lib/utils';

export interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  className?: string;
}

export function Pagination({
  currentPage,
  totalPages,
  onPageChange,
  className,
}: PaginationProps) {
  const pages = [];
  
  // Calculate which page numbers to display
  const maxPages = 5;
  let startPage: number, endPage: number;
  
  if (totalPages <= maxPages) {
    // Less than max pages, show all
    startPage = 1;
    endPage = totalPages;
  } else {
    // More than max pages, calculate which to show
    const maxPagesBeforeCurrentPage = Math.floor(maxPages / 2);
    const maxPagesAfterCurrentPage = Math.ceil(maxPages / 2) - 1;
    
    if (currentPage <= maxPagesBeforeCurrentPage) {
      // Near the start
      startPage = 1;
      endPage = maxPages;
    } else if (currentPage + maxPagesAfterCurrentPage >= totalPages) {
      // Near the end
      startPage = totalPages - maxPages + 1;
      endPage = totalPages;
    } else {
      // Middle
      startPage = currentPage - maxPagesBeforeCurrentPage;
      endPage = currentPage + maxPagesAfterCurrentPage;
    }
  }
  
  // Generate page numbers
  for (let i = startPage; i <= endPage; i++) {
    pages.push(i);
  }
  
  return (
    <div className={cn("flex justify-center items-center space-x-2", className)}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
      >
        <ChevronLeft className="h-4 w-4" />
      </Button>
      
      {pages.map((page) => (
        <Button
          key={page}
          variant={currentPage === page ? "default" : "outline"}
          size="sm"
          onClick={() => onPageChange(page)}
          disabled={currentPage === page}
        >
          {page}
        </Button>
      ))}
      
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
      >
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
}

============================================================

FILE: .\components\ui\pill-tabs.tsx
SIZE: 1.42 KB
LAST MODIFIED: 03/17/2025 21:44:17

'use client';

import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import { cn } from '@/lib/utils';

interface PillTabsProps {
  tabs: Array<{
    value: string;
    label: string;
  }>;
  activeTab: string;
  onTabChange: (value: string) => void;
  className?: string;
}

export function PillTabs({ tabs, activeTab, onTabChange, className }: PillTabsProps) {
  return (
    <div className={cn("relative overflow-auto", className)}>
      <div className="flex items-center">
        {tabs.map((tab) => (
          <button
            key={tab.value}
            onClick={() => onTabChange(tab.value)}
            className={cn(
              "flex h-9 items-center justify-center rounded-full px-4 text-center text-sm font-medium transition-colors",
              activeTab === tab.value
                ? "bg-muted text-primary"
                : "text-muted-foreground hover:text-primary"
            )}
          >
            {tab.label}
          </button>
        ))}
      </div>
    </div>
  );
}

interface PillTabsContentProps {
  value: string;
  activeTab: string;
  children: React.ReactNode;
  className?: string;
}

export function PillTabsContent({ value, activeTab, children, className }: PillTabsContentProps) {
  if (value !== activeTab) return null;
  
  return (
    <div className={cn("mt-4", className)}>
      {children}
    </div>
  );
}

============================================================

FILE: .\components\ui\select.tsx
SIZE: 5.51 KB
LAST MODIFIED: 03/04/2025 21:25:38

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


============================================================

FILE: .\components\ui\stat-card.tsx
SIZE: 1.61 KB
LAST MODIFIED: 03/04/2025 21:07:38

// components/ui/stat-card.tsx
import React from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { cn } from "@/lib/utils"

interface StatCardProps extends React.HTMLAttributes<HTMLDivElement> {
  title: string
  value: string | number
  description?: string
  icon?: React.ReactNode
  trend?: {
    value: number
    label: string
    direction: "up" | "down" | "neutral"
  }
}

export function StatCard({
  title,
  value,
  description,
  icon,
  trend,
  className,
  ...props
}: StatCardProps) {
  const trendColors = {
    up: "text-green-500",
    down: "text-red-500",
    neutral: "text-gray-500",
  }

  return (
    <Card className={cn("overflow-hidden", className)} {...props}>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        {icon && <div className="h-4 w-4 text-muted-foreground">{icon}</div>}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground">{description}</p>
        )}
        {trend && (
          <div className={cn("flex items-center text-xs mt-1", trendColors[trend.direction])}>
            {trend.direction === "up" ? "â†‘" : trend.direction === "down" ? "â†“" : "â†’"}
            <span className="ml-1">{trend.value}%</span>
            <span className="ml-1 text-muted-foreground">{trend.label}</span>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

============================================================

FILE: .\components\ui\table.tsx
SIZE: 2.79 KB
LAST MODIFIED: 03/04/2025 21:21:35

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


============================================================

FILE: .\components\ui\tabs.tsx
SIZE: 1.88 KB
LAST MODIFIED: 03/12/2025 09:01:44

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

============================================================

FILE: .\components\ui\tags.tsx
SIZE: 1.03 KB
LAST MODIFIED: 03/11/2025 21:48:59

import React from 'react';
import { cn } from '@/lib/utils';

interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
  className?: string;
}

const TagDisplay: React.FC<TagDisplayProps> = ({ 
  tags, 
  onClick,
  className
}) => {
  if (!tags) return null;
  
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  if (tagArray.length === 0) return null;
  
  return (
    <div className={cn("flex flex-wrap gap-1", className)}>
      {tagArray.map((tag, idx) => (
        <button
          key={`${tag}-${idx}`}
          onClick={() => onClick?.(tag)}
          className={cn(
            "px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300",
            onClick ? "hover:bg-gray-200 dark:hover:bg-gray-600 cursor-pointer" : "cursor-default",
            "transition-colors duration-150",
            className
          )}
        >
          {tag}
        </button>
      ))}
    </div>
  );
};

export default TagDisplay;

============================================================

FILE: .\components\ui\toast.tsx
SIZE: 4.88 KB
LAST MODIFIED: 02/09/2025 10:39:17

import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border-gray-700 bg-gray-800 text-white",
        destructive: "destructive group border-red-700 bg-red-900 text-red-100",
        success: "border-green-700 bg-green-900 text-green-100",
        warning: "border-yellow-700 bg-yellow-900 text-yellow-100",
        info: "border-blue-700 bg-blue-900 text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-gray-700 bg-transparent px-3 text-sm font-medium transition-colors hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-red-700 group-[.destructive]:hover:border-red-600 group-[.destructive]:hover:bg-red-600 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-white/50 opacity-0 transition-opacity hover:text-white focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

============================================================

FILE: .\components\ui\toaster.tsx
SIZE: 1.3 KB
LAST MODIFIED: 02/09/2025 10:39:36

import {
    Toast,
    ToastClose,
    ToastDescription,
    ToastProvider,
    ToastTitle,
    ToastViewport,
  } from "@/components/ui/toast";
  import { useToast } from "@/hooks/useToast";
  
  export function Toaster() {
    const { toasts } = useToast();
  
    return (
      <ToastProvider>
        {toasts.map(function ({ id, title, description, action, ...props }) {
          return (
            <Toast key={id} {...props}>
              <div className="grid gap-1">
                {title && <ToastTitle>{title}</ToastTitle>}
                {description && (
                  <ToastDescription>{description}</ToastDescription>
                )}
              </div>
              {action}
              <ToastClose />
            </Toast>
          );
        })}
        <ToastViewport />
      </ToastProvider>
    );
  }
  
  // Example usage:
  /*
  import { useToast } from '@/hooks/useToast';
  
  function MyComponent() {
    const { toast } = useToast();
    
    const showToast = () => {
      toast({
        title: "Success!",
        description: "Your action was completed successfully.",
        variant: "success", // or "default", "destructive", "warning", "info"
      });
    };
  
    return <button onClick={showToast}>Show Toast</button>;
  }
  */

============================================================

FILE: .\features\auth\PinPad.tsx
SIZE: 2.47 KB
LAST MODIFIED: 03/17/2025 09:58:57

'use client';

import * as React from 'react';
import { Button } from '@/components/ui/button';

interface PinPadProps {
  onSubmit: (pin: string) => void;
  onCancel: () => void;
}

export default function PinPad({ onSubmit, onCancel }: PinPadProps) {
  const [pin, setPin] = React.useState('');
  const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'X', '0', 'â†'];

  function handleClick(num: string) {
    if (num === 'â†') {
      setPin((prev) => prev.slice(0, -1));
    } else if (num === 'X') {
      onCancel();
    } else if (pin.length < 4 && /\d/.test(num)) {
      setPin((prev) => prev + num);
    }
  }

  React.useEffect(() => {
    if (pin.length === 4) {
      onSubmit(pin);
      setPin('');
    }
  }, [pin, onSubmit]);

  return (
    <div className="flex flex-col items-center gap-8 w-full max-w-[320px] py-4">
      <div className="flex gap-3 justify-center">
        {[...Array(4)].map((_, i) => (
          <div
            key={i}
            className={`w-5 h-5 rounded-full ${
              pin.length > i ? 'bg-white' : 'bg-neutral-700'
            }`}
          />
        ))}
      </div>
      
      <div className="grid grid-cols-3 gap-4 w-full">
        {numbers.map((num, idx) => {
          // Special styling for cancel (X) and backspace buttons
          if (num === 'X' || num === 'â†') {
            return (
              <Button
                key={idx}
                variant="ghost"
                className={`h-14 text-xl ${
                  num === 'X' 
                    ? 'text-neutral-400 hover:text-white hover:bg-neutral-800' 
                    : 'text-neutral-300 hover:text-white hover:bg-neutral-800'
                }`}
                onClick={() => handleClick(num)}
              >
                {num}
              </Button>
            );
          }
          
          // Number buttons
          return (
            <Button
              key={idx}
              variant="ghost"
              className="h-14 text-xl font-medium text-neutral-200 hover:bg-neutral-800 hover:text-white"
              onClick={() => handleClick(num)}
            >
              {num}
            </Button>
          );
        })}
      </div>
      
      <Button 
        variant="outline" 
        className="mt-4 border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white"
        onClick={onCancel}
      >
        Back
      </Button>
    </div>
  );
}

============================================================

FILE: .\features\auth\ReviewerLoginButton.tsx
SIZE: 1.06 KB
LAST MODIFIED: 03/17/2025 11:15:00

'use client';

import * as React from 'react';
import { Button } from '@/components/ui/button';
import { ReviewerLoginModal } from './ReviewerLoginModal';
import type { Reviewer } from '@/types/types';

interface ReviewerLoginButtonProps {
  onLoginSuccess?: (reviewer: Reviewer) => void;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  className?: string;
}

export function ReviewerLoginButton({ 
  onLoginSuccess, 
  variant = 'outline',
  className = '' 
}: ReviewerLoginButtonProps) {
  const [open, setOpen] = React.useState(false);

  const handleLoginSuccess = (reviewer: Reviewer) => {
    setOpen(false);
    if (onLoginSuccess) {
      onLoginSuccess(reviewer);
    }
  };

  return (
    <>
      <Button 
        onClick={() => setOpen(true)} 
        variant={variant} 
        className={className}
      >
        Login
      </Button>
      <ReviewerLoginModal
        open={open}
        onClose={() => setOpen(false)}
        onLoginSuccess={handleLoginSuccess}
      />
    </>
  );
}

============================================================

FILE: .\features\auth\ReviewerLoginModal.tsx
SIZE: 5 KB
LAST MODIFIED: 03/17/2025 21:39:28

'use client';

import * as React from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { supabase } from '@/lib/services/supabase';
import PinPad from './PinPad';
import type { Reviewer } from '@/types/types';

interface ReviewerLoginModalProps {
  open: boolean;
  onClose: () => void;
  onLoginSuccess: (reviewer: Reviewer) => void;
}

// Avatar icons for reviewers - desaturated colors
const AVATAR_EMOJIS = ['ðŸ™', 'ðŸˆ', 'ðŸ•', 'ðŸ’', 'ðŸ¢', 'ðŸ£', 'ðŸ¦Š', 'ðŸ¼'];
const AVATAR_COLORS = [
  'from-orange-400/80 to-amber-400/80', // Desaturated Orange/Gold
  'from-red-500/80 to-red-600/80',      // Desaturated Red
  'from-emerald-400/80 to-teal-400/80', // Desaturated Green
  'from-purple-500/80 to-blue-400/80',  // Desaturated Purple/Blue
  'from-blue-400/80 to-cyan-300/80',    // Desaturated Blue
  'from-rose-400/80 to-pink-400/80',    // Desaturated Pink
  'from-amber-300/80 to-yellow-200/80', // Desaturated Yellow
  'from-slate-500/80 to-slate-700/80',  // Desaturated Gray
];

export function ReviewerLoginModal({
  open,
  onClose,
  onLoginSuccess
}: ReviewerLoginModalProps) {
  const [reviewers, setReviewers] = React.useState<Reviewer[]>([]);
  const [selectedReviewer, setSelectedReviewer] = React.useState<Reviewer | null>(null);
  const [error, setError] = React.useState<string | null>(null);
  const [showPinPad, setShowPinPad] = React.useState(false);

  React.useEffect(() => {
    if (open) {
      fetchReviewers();
      setError(null);
      setSelectedReviewer(null);
      setShowPinPad(false);
    }
  }, [open]);

  async function fetchReviewers() {
    try {
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });
      if (error) throw error;
      if (data) setReviewers(data);
    } catch (err: any) {
      console.error('Error fetching reviewers:', err);
      setError('Failed to load reviewers');
    }
  }

  async function handleSelectReviewer(reviewer: Reviewer) {
    setSelectedReviewer(reviewer);
    setShowPinPad(true);
    setError(null);
  }

  async function handlePinSubmit(pin: string) {
    if (!selectedReviewer) return;
    setError(null);

    const { data, error } = await supabase
      .from('reviewers')
      .select('*')
      .eq('id', selectedReviewer.id)
      .eq('pin', pin)
      .maybeSingle();

    if (error) {
      setError('Database error checking PIN');
      return;
    }
    if (!data) {
      setError('Incorrect PIN');
      return;
    }

    onLoginSuccess(selectedReviewer);
    onClose();
  }

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[700px] bg-black border-neutral-800">
        <DialogHeader className="mb-6">
          <DialogTitle className="text-3xl font-medium text-center text-white">
            {!showPinPad ? "Who's reviewing?" : `Enter PIN for ${selectedReviewer?.name}`}
          </DialogTitle>
        </DialogHeader>

        {error && (
          <div className="mb-6 rounded bg-neutral-900 text-neutral-300 p-3 text-center border border-neutral-700">
            {error}
          </div>
        )}

        {!showPinPad ? (
          <div className="flex flex-col items-center">
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-6 mb-8">
              {reviewers.map((rev, index) => (
                <button
                  key={rev.id}
                  onClick={() => handleSelectReviewer(rev)}
                  className="flex flex-col items-center gap-3 transition-transform hover:scale-110 focus:outline-none"
                >
                  <div 
                    className={`w-28 h-28 rounded-md flex items-center justify-center overflow-hidden bg-gradient-to-b ${AVATAR_COLORS[index % AVATAR_COLORS.length]}`}
                  >
                    <div className="text-[3rem] transform scale-150">
                      {AVATAR_EMOJIS[index % AVATAR_EMOJIS.length]}
                    </div>
                  </div>
                  <span className="text-neutral-300 text-sm">{rev.name}</span>
                </button>
              ))}
            </div>
            
            <Button 
              variant="outline" 
              className="border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white mt-4"
              onClick={onClose}
            >
              Cancel
            </Button>
          </div>
        ) : (
          <div className="flex flex-col items-center">
            <PinPad
              onSubmit={handlePinSubmit}
              onCancel={() => {
                setShowPinPad(false);
                setError(null);
                setSelectedReviewer(null);
              }}
            />
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}

============================================================

FILE: .\features\auth\ReviewerProfileDropdown.tsx
SIZE: 3.36 KB
LAST MODIFIED: 03/21/2025 22:46:54

'use client';

import * as React from 'react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ChevronDown, LogOut, FileDownIcon, Plus, CheckSquare } from "lucide-react";
import type { Reviewer } from '@/types/types';

// Avatar icons for reviewers (should match those in ReviewerLoginModal)
const AVATAR_EMOJIS = ['ðŸ™', 'ðŸˆ', 'ðŸ•', 'ðŸ’', 'ðŸ¢', 'ðŸ£', 'ðŸ¦Š', 'ðŸ¼'];
const AVATAR_COLORS = [
  'from-orange-400/80 to-amber-400/80', // Desaturated Orange/Gold
  'from-red-500/80 to-red-600/80',      // Desaturated Red
  'from-emerald-400/80 to-teal-400/80', // Desaturated Green
  'from-purple-500/80 to-blue-400/80',  // Desaturated Purple/Blue
  'from-blue-400/80 to-cyan-300/80',    // Desaturated Blue
  'from-rose-400/80 to-pink-400/80',    // Desaturated Pink
  'from-amber-300/80 to-yellow-200/80', // Desaturated Yellow
  'from-slate-500/80 to-slate-700/80',  // Desaturated Gray
];

interface ReviewerProfileDropdownProps {
  reviewer: Reviewer;
  reviewerIndex: number; // To determine the emoji and color
  onLogout: () => void;
  onExportClick: () => void;
  onAddWordsClick: () => void;
  onReviewWordsClick: () => void;
}

export function ReviewerProfileDropdown({
  reviewer,
  reviewerIndex = 0,
  onLogout,
  onExportClick,
  onAddWordsClick,
  onReviewWordsClick
}: ReviewerProfileDropdownProps) {
  const avatarEmoji = AVATAR_EMOJIS[reviewerIndex % AVATAR_EMOJIS.length];
  const avatarColor = AVATAR_COLORS[reviewerIndex % AVATAR_COLORS.length];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger className="flex items-center gap-2 outline-none">
        <div className={`w-9 h-9 rounded-full flex items-center justify-center overflow-hidden bg-gradient-to-b ${avatarColor}`}>
          <div className="text-2xl transform scale-150 translate-y-1">
            {avatarEmoji}
          </div>
        </div>
        <span className="text-sm text-white hidden sm:inline-block">{reviewer.name}</span>
        <ChevronDown className="h-4 w-4 text-muted-foreground" />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col">
            <span>{reviewer.name}</span>
            <span className="text-xs text-muted-foreground">{reviewer.total_reviews || 0} reviews</span>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem className="cursor-pointer" onClick={onAddWordsClick}>
          <Plus className="mr-2 h-4 w-4" />
          <span>Add Words</span>
        </DropdownMenuItem>
        <DropdownMenuItem className="cursor-pointer" onClick={onReviewWordsClick}>
          <CheckSquare className="mr-2 h-4 w-4" />
          <span>Review Words</span>
        </DropdownMenuItem>
        <DropdownMenuItem className="cursor-pointer" onClick={onExportClick}>
          <FileDownIcon className="mr-2 h-4 w-4" />
          <span>Export</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem className="cursor-pointer" onClick={onLogout}>
          <LogOut className="mr-2 h-4 w-4" />
          <span>Logout</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

============================================================

FILE: .\features\auth\types.ts
SIZE: 0 KB
LAST MODIFIED: 03/16/2025 19:36:17


============================================================

FILE: .\features\charts\ChartContainer.tsx
SIZE: 0.82 KB
LAST MODIFIED: 03/16/2025 15:49:31

"use client";

import * as React from "react";

export type ChartConfig = {
  [key: string]: {
    label: string;
    color: string;
  };
};

export function ChartContainer({
  config,
  children,
  className,
  ...props
}: React.PropsWithChildren & {
  config: ChartConfig;
  className?: string;
  [key: string]: any;
}) {
  const createCSSVariable = (obj: Record<string, string>) => {
    return Object.entries(obj).reduce((vars, [key, value]) => {
      return {
        ...vars,
        [`--color-${key}`]: value,
      };
    }, {});
  };

  const colors = Object.entries(config).reduce((colors, [key, item]) => {
    return {
      ...colors,
      [key]: item.color,
    };
  }, {});

  const cssVars = createCSSVariable(colors);

  return (
    <div style={cssVars} className={className} {...props}>
      {children}
    </div>
  );
}

============================================================

FILE: .\features\charts\ChartTooltip.tsx
SIZE: 0.26 KB
LAST MODIFIED: 03/15/2025 18:35:43

"use client";

import * as React from "react";
import { Tooltip } from "recharts";

export function ChartTooltip({
  content,
  ...props
}: {
  content?: React.JSXElementConstructor<any>;
  [key: string]: any;
}) {
  return <Tooltip {...props} content={content} />;
}


============================================================

FILE: .\features\charts\ChartTooltipContent.tsx
SIZE: 1.5 KB
LAST MODIFIED: 03/16/2025 15:49:59

"use client";

import * as React from "react";

export function ChartTooltipContent({
  active,
  payload,
  label,
  config,
  indicator = "circle",
}: {
  active?: boolean;
  payload?: any[];
  label?: string;
  config?: any;
  indicator?: "circle" | "line";
}) {
  const TypeIndicator = ({ name }: { name: string }) =>
    indicator === "circle" ? (
      <circle cx="6.5" cy="6.5" r="3.5" fill={`var(--color-${name})`} />
    ) : (
      <line x1="1" y1="6.5" x2="9" y2="6.5" stroke={`var(--color-${name})`} strokeWidth={2} strokeLinecap="round" />
    );

  if (!active || !payload) return null;

  return (
    <div className="rounded-lg border bg-background p-2 shadow-sm">
      <div className="grid grid-cols-2 gap-2">
        <div className="flex flex-col">
          <span className="text-[0.70rem] uppercase text-muted-foreground">{label}</span>
        </div>
        <div className="flex flex-col gap-1">
          {payload.map(({ value, name }) => (
            <div key={name} className="flex items-center justify-end gap-1">
              <span className="text-[0.70rem] text-muted-foreground">{config?.[name]?.label ?? name}</span>
              <span className="font-bold tabular-nums">{value}</span>
              {config?.[name] && (
                <svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <TypeIndicator name={name} />
                </svg>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

============================================================

FILE: .\features\charts\index.ts
SIZE: 0.16 KB
LAST MODIFIED: 03/15/2025 18:35:43

export { ChartContainer } from './ChartContainer';
export { ChartTooltip } from './ChartTooltip';
export { ChartTooltipContent } from './ChartTooltipContent';


============================================================

FILE: .\features\dashboard\Dashboard.tsx
SIZE: 19.82 KB
LAST MODIFIED: 03/21/2025 23:18:08

'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { supabase } from '@/lib/services/supabase';
import { useTheme } from 'next-themes';
import './styles/dashboard.css';

// Import chart components
import { ChartContainer, ChartTooltip, ChartTooltipContent } from '@/features/charts';
import WordCreatorModal from '@/features/phrases/WordCreatorModal';
import ReviewModal from '@/features/phrases/ReviewModal';

// Components
import { PhrasesTable } from '@/features/phrases/phrasesTable';
import { DashboardHeader } from '@/features/dashboard/components/DashboardHeader';
import ExportModal from '@/features/dashboard/components/ExportModal';
import FilterModal from '@/features/filters/FilterModal';
import { FilterProvider } from '@/features/phrases/stores/filterContext';
import { StatsCards } from '@/features/dashboard/components/StatsCards';
import { AnalyticsSection } from '@/features/dashboard/components/AnalyticsSection';

// Recharts components
import {
  RadialBarChart, RadialBar, BarChart, Bar, PieChart, Pie, LineChart, Line,
  XAxis, YAxis, CartesianGrid, Legend, ResponsiveContainer, Cell, PolarGrid, PolarRadiusAxis
} from 'recharts';

// UI Components
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { PillTabs, PillTabsContent } from '@/components/ui/pill-tabs'; 

// Icons
import {
  FileText, Users, Award, Moon, Sun, Filter, TrendingUp,
  BarChart2, PieChartIcon, FileDownIcon, X
} from "lucide-react";

// Hooks
import { useStats } from '@/features/data/hooks/useStats';
import { usePhrases } from '@/features/data/hooks/usePhrases';
import { usePhraseMetadata } from '@/features/data/hooks/usePhraseMetadata';
import { useReviewers } from '@/features/data/hooks/useReviewers';
import { useDeletePhrase } from '@/features/phrases/hooks/useDeletePhrase';

// Types
import type { Reviewer, Phrase } from '@/types/types';

const Dashboard = () => {
  const router = useRouter();
  const { theme, setTheme } = useTheme();
  const [showWordCreatorModal, setShowWordCreatorModal] = useState(false);
  const [showReviewModal, setShowReviewModal] = useState(false);
  const [selectedPhraseId, setSelectedPhraseId] = useState<number | null>(null); 

  // Added this state for tracking newly added phrase IDs
  const [newIds, setNewIds] = useState<number[]>([]);
  
  // Initialize the delete phrase mutation
  const deletePhraseMutation = useDeletePhrase();
  
  // ======= REVIEWER AUTH STATE =======
  // State for current logged-in reviewer
  const [currentReviewer, setCurrentReviewer] = useState<Reviewer | null>(null);
  const handleAddWordsClick = () => {
    setShowWordCreatorModal(true);
  };
  
  const handleReviewWordsClick = () => {
    setShowReviewModal(true);
  };
  
  const handleWordAdded = (id: number) => {
    // Track newly added phrase ID
    setNewIds(prev => [...prev, id]);
    // Refresh data after a word is added
    fetchPhrases();
  };
  
  // Add handlers for edit and delete
  const handleEdit = (id: number) => {
    setSelectedPhraseId(id);
    setShowReviewModal(true);
  };

  const handleDelete = (id: number) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      deletePhraseMutation.mutate(id, {
        onSuccess: () => {
          // Refresh the phrases list after deletion
          fetchPhrases();
        }
      });
    }
  };
  
  // ======= DASHBOARD UI STATE =======
  const [activeTab, setActiveTab] = useState('phrases');
  const [showFilterModal, setShowFilterModal] = useState(false);
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [phrasesOverTime, setPhrasesOverTime] = useState<any[]>([]);
  const [showExportModal, setShowExportModal] = useState(false);
  const [isExporting, setIsExporting] = useState(false);

  // ======= DATA HOOKS =======
  const { stats, loading: statsLoading } = useStats();
  const { reviewers } = useReviewers();
  const {
    phrases,
    loading: phrasesLoading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    editPhrase,
    deletePhrase,
    resetFilters,
    fetchPhrases,
  } = usePhrases();
  const { categories, difficulties, partsOfSpeech } = usePhraseMetadata();

  // Find reviewer index for the avatar
  const reviewerIndex = currentReviewer 
    ? reviewers?.findIndex(r => r.id === currentReviewer.id) ?? 0
    : 0;

  // ======= TABLE STATE =======
  const [tableState, setTableState] = useState<TableState>({
    sortConfig: {
      key: '',
      direction: 'asc'
    },
    pagination: {
      currentPage: 1,
      rowsPerPage: 10,  // Set default to 10
      totalItems: 0,
      totalPages: 1
    },
    filters: {
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    }
  });

 
  
  // ======= CHART DATA =======
  // Data for the radial chart
  const wordsAddedData = [
    { name: "Words Added", value: 45, fill: "hsl(var(--primary))" },
    { name: "Goal", value: 100, fill: "hsl(var(--muted))" },
  ];

  // Chart configuration
  const chartConfig = {
    phrases: { label: 'Phrases', color: 'var(--chart-1)' },
    reviews: { label: 'Reviews', color: 'var(--chart-2)' },
    additions: { label: 'Additions', color: 'var(--chart-3)' },
    edits: { label: 'Edits', color: 'var(--chart-4)' }
  };

  // ======= AUTH HANDLERS =======
  /**
   * Handle successful login
   */
  const handleLoginSuccess = (reviewer: Reviewer) => {
    setCurrentReviewer(reviewer);
    localStorage.setItem('currentReviewer', JSON.stringify(reviewer));
    console.log('Reviewer logged in:', reviewer.name);
  };
  
  /**
   * Handle logout
   */
  const handleLogout = () => {
    setCurrentReviewer(null);
    localStorage.removeItem('currentReviewer');
  };

  // ======= EFFECTS =======
  
  // Load reviewer from localStorage on initial render
  useEffect(() => {
    const savedReviewer = localStorage.getItem('currentReviewer');
    if (savedReviewer) {
      try {
        setCurrentReviewer(JSON.parse(savedReviewer));
      } catch (e) {
        console.error("Error parsing saved reviewer:", e);
        localStorage.removeItem('currentReviewer');
      }
    }
  }, []);

  // Hide any debug JSON output on load
  useEffect(() => {
    const preElements = document.querySelectorAll('pre');
    preElements.forEach(el => {
      if (
        el.textContent &&
        el.textContent.includes('"dataLength":') &&
        el.textContent.includes('"totalItems":')
      ) {
        el.style.display = 'none';
      }
    });
  }, []);

  // Sync Table State with hook state
  useEffect(() => {
    if (phrases && pagination) {
      const totalItems = pagination.totalItems || phrases.length || 0;
      const rowsPerPage = pagination.rowsPerPage || 10; // Get rowsPerPage from pagination
      const totalPages = Math.ceil(totalItems / rowsPerPage);
      
      setTableState(prev => ({
        ...prev,
        sortConfig,
        pagination: {
          ...pagination,
          rowsPerPage,
          totalItems,
          totalPages,
          currentPage: Math.min(pagination.currentPage, totalPages || 1)
        },
        filters,
      }));
    }
  }, [phrases, pagination, sortConfig, filters]);



  // Fetch subcategories when the category filter changes
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!filters.category) {
        setSubcategories([]);
        return;
      }
      try {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();
        if (categoryData) {
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');
          if (subcategoryData) {
            setSubcategories(subcategoryData.map(sub => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      }
    };
    fetchSubcategories();
  }, [filters.category]);

  // Fetch phrases over time
  useEffect(() => {
    fetchPhrasesOverTime();
  }, []);

  // ======= DATA FUNCTIONS =======
  /**
   * Fetch phrases over time data for chart
   */
  const fetchPhrasesOverTime = async () => {
    try {
      const { data, error } = await supabase
        .from('phrases')
        .select('created_at')
        .order('created_at');
      if (error) {
        console.error('Error fetching phrase timestamps:', error);
        setPhrasesOverTime(getErrorStateData());
        return;
      }
      if (data && data.length > 0) {
        const monthlyData = processTimestampData(data);
        setPhrasesOverTime(monthlyData);
      } else {
        setPhrasesOverTime(getErrorStateData());
      }
    } catch (err) {
      console.error('Error fetching phrase timestamps:', err);
      setPhrasesOverTime(getErrorStateData());
    }
  };

  /**
   * Process timestamp data for charts
   */
  const processTimestampData = (data: any[]) => {
    const monthCounts: Record<string, any> = {};
    data.forEach(item => {
      if (!item.created_at) return;
      const date = new Date(item.created_at);
      const month = date.toLocaleString('default', { month: 'short' });
      const year = date.getFullYear();
      const key = `${month} ${year}`;
      if (!monthCounts[key]) {
        monthCounts[key] = { month, year, count: 0, fullDate: date };
      }
      monthCounts[key].count++;
    });
    return Object.values(monthCounts)
      .sort((a, b) => a.fullDate - b.fullDate)
      .map(item => ({ month: item.month, year: item.year, phrases: item.count }))
      .slice(-6);
  };

  /**
   * Get fallback data for charts when error occurs
   */
  const getErrorStateData = () => {
    return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'].map(month => ({
      month,
      year: new Date().getFullYear(),
      phrases: null
    }));
  };
  /**
   * Handle table state changes
   */
  const handleTableStateChange = (updates: Partial<TableState>) => {
    // Update local state first
    setTableState(prev => {
      const newState = { ...prev };
      
      if (updates.filters) {
        newState.filters = { ...prev.filters, ...updates.filters };
      }
      
      if (updates.sortConfig) {
        newState.sortConfig = { ...prev.sortConfig, ...updates.sortConfig };
      }
      
      if (updates.pagination) {
        // Make sure all pagination properties are properly set
        newState.pagination = { ...prev.pagination, ...updates.pagination };
      }
      
      return newState;
    });
    
    // Then immediately propagate changes to the hooks
    if (updates.filters) {
      // Apply each filter individually to ensure all are updated
      Object.entries(updates.filters).forEach(([key, value]) => {
        if (value !== undefined) { // Only update if value is provided
          handleFilterChange(key, value || '');
        }
      });
    }
    
    if (updates.sortConfig && updates.sortConfig.key) {
      handleSort(updates.sortConfig.key as keyof Phrase);
    }
    
    if (updates.pagination) {
      // Note: Order matters here! First update rows per page, then page number
      if (updates.pagination.rowsPerPage) {
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
      
      if (updates.pagination.currentPage) {
        handlePageChange(updates.pagination.currentPage);
      }
    }
  };

  /**
   * Generate monthly activity data for charts
   */
  const generateMonthlyActivityData = () => {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
    return months.map(month => ({
      name: month,
      reviews: Math.floor(Math.random() * 100) + 50,
      additions: Math.floor(Math.random() * 40) + 10,
      edits: Math.floor(Math.random() * 30) + 5,
    }));
  };

  const monthlyActivityData = generateMonthlyActivityData();

  /**
   * Generate category data for charts
   */
  const generateCategoryData = () => {
    if (categories && categories.length > 0) {
      return [
        { name: 'Animals & Plants', value: 30 },
        { name: 'Art & Design', value: 22 },
        { name: 'Education & Learning', value: 13 },
        { name: 'Celebrations & Traditions', value: 16 },
        { name: 'Business & Careers', value: 19 },
      ];
    }
    return [
      { name: 'Animals & Plants', value: 30 },
      { name: 'Art & Design', value: 22 },
      { name: 'Education & Learning', value: 13 },
      { name: 'Celebrations & Traditions', value: 16 },
      { name: 'Business & Careers', value: 19 },
    ];
  };

  const categoryData = generateCategoryData();

  /**
   * Handle exporting data
   */
  const handleExport = async (options: any) => {
    try {
      setIsExporting(true);
      const { data: phrases, error: phrasesError } = await supabase
        .from('phrases')
        .select(`
          id,
          phrase,
          part_of_speech,
          hint,
          category_id,
          subcategory_id,
          difficulty,
          categories:category_id(name),
          subcategories:subcategory_id(name)
        `);
      if (phrasesError) throw phrasesError;
      const { data: phraseTags, error: tagsError } = await supabase
        .from('phrase_tags')
        .select(`
          phrase_id,
          tags:tag_id(tag)
        `);
      if (tagsError) throw tagsError;
      
      // Process data
      const tagsByPhraseId: Record<string, string[]> = {};
      phraseTags.forEach((item: any) => {
        if (!tagsByPhraseId[item.phrase_id]) {
          tagsByPhraseId[item.phrase_id] = [];
        }
        tagsByPhraseId[item.phrase_id].push(item.tags.tag);
      });
      
      const categorizedPhrases: Record<string, any[]> = {};
      phrases.forEach((phrase: any) => {
        const categoryName = phrase.categories ? phrase.categories.name : 'Uncategorized';
        if (!categorizedPhrases[categoryName]) {
          categorizedPhrases[categoryName] = [];
        }
        categorizedPhrases[categoryName].push({
          text: phrase.phrase,
          pos: phrase.part_of_speech,
          hint: phrase.hint || '',
          difficulty: phrase.difficulty || 1,
          subcategory: phrase.subcategories ? phrase.subcategories.name : null,
          tags: tagsByPhraseId[phrase.id] || [],
        });
      });
      
      const esp32Data: Record<string, any[]> = {};
      Object.keys(categorizedPhrases).forEach(cat => {
        if (options.optimizeForESP32) {
          esp32Data[cat] = categorizedPhrases[cat].map(p => ({
            t: p.text,
            h: p.hint || '',
            d: p.difficulty || 1
          }));
        } else {
          esp32Data[cat] = categorizedPhrases[cat];
        }
      });
      
      const headerContent = options.exportHeader ? generateArduinoHeader(esp32Data) : '';
      setIsExporting(false);
      return { jsonData: esp32Data, headerContent };
    } catch (error) {
      console.error('Export error:', error);
      setIsExporting(false);
      return null;
    }
  };

  /**
   * Generate Arduino header file
   */
  const generateArduinoHeader = (data: Record<string, any[]>) => {
    let headerContent = `// Auto-generated phrases header file
#ifndef PHRASES_H
#define PHRASES_H

#include <Arduino.h>

struct Phrase {
  const char* text;
  const char* hint;
  uint8_t difficulty;
};
`;
    Object.keys(data).forEach(category => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      const phrases = data[category];
      headerContent += `// ${category} phrases
constexpr Phrase ${categoryVar}_phrases[] PROGMEM = {
`;
      phrases.forEach(phrase => {
        const text = phrase.t || phrase.text;
        const hint = phrase.h || phrase.hint || '';
        const difficulty = phrase.d || phrase.difficulty || 1;
        headerContent += `  {"${escapeString(text)}", "${escapeString(hint)}", ${difficulty}},
`;
      });
      headerContent += `};

constexpr size_t ${categoryVar}_count = ${phrases.length};

`;
    });
    headerContent += `// Category index
struct PhraseCategory {
  const char* name;
  const Phrase* phrases;
  size_t count;
};

constexpr PhraseCategory phrase_categories[] PROGMEM = {
`;
    Object.keys(data).forEach(category => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      headerContent += `  {"${escapeString(category)}", ${categoryVar}_phrases, ${categoryVar}_count},
`;
    });
    headerContent += `};

constexpr size_t category_count = ${Object.keys(data).length};

#endif // PHRASES_H
`;
    return headerContent;
  };

  /**
   * Escape strings for C++ code
   */
  const escapeString = (str: string) => {
    if (!str) return "";
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
  };

  // ======= RENDER =======
  return (
    <div className="container mx-auto py-6 space-y-6">
    {/* Header with login */}
    <DashboardHeader
      theme={theme}
      setTheme={setTheme}
      onExportClick={() => setShowExportModal(true)}
      currentReviewer={currentReviewer}
      onLoginSuccess={handleLoginSuccess}
      onLogout={handleLogout}
      onAddWordsClick={handleAddWordsClick}
      onReviewWordsClick={handleReviewWordsClick}
    />
    
    {/* Add the StatsCards component here */}
    <StatsCards />

      <div className="mb-6">
        {/* Word Creator Modal */}
{currentReviewer && (
  <WordCreatorModal
    isOpen={showWordCreatorModal}
    onClose={() => setShowWordCreatorModal(false)}
    reviewer={currentReviewer}
    onWordAdded={handleWordAdded}
  />
)}

{/* Review Modal */}
{currentReviewer && (
  <ReviewModal
  isOpen={showReviewModal}
  onClose={() => {
    setShowReviewModal(false);
    setSelectedPhraseId(null);
  }}
  reviewer={currentReviewer}
  selectedPhraseId={selectedPhraseId}
/>
)}
  <PillTabs
    tabs={[
      { value: 'phrases', label: 'Phrases' },
      { value: 'analytics', label: 'Analytics' }
    ]}
    activeTab={activeTab}
    onTabChange={setActiveTab}
    className="py-3 border-dashed border-y"
  />

{/* Phrases Tab */}
<PillTabsContent value="phrases" activeTab={activeTab}>
  <div className="flex flex-col space-y-4">
    {/* Wrap your existing PhrasesTable with FilterProvider */}
    <FilterProvider>
      <PhrasesTable
        phrases={phrases}
        loading={phrasesLoading}
        tableState={tableState}
        onTableStateChange={handleTableStateChange}
        onEdit={handleEdit}
        onDelete={handleDelete}
        newIds={newIds}
      />
    </FilterProvider>
  </div>
</PillTabsContent>

        {/* Analytics Tab */}
        <PillTabsContent value="analytics" activeTab={activeTab}>
          <AnalyticsSection />
        </PillTabsContent>
          </div>

      {/* Modals */}
      <FilterModal
        isOpen={showFilterModal}
        onClose={() => setShowFilterModal(false)}
        filters={filters}
        onChange={handleFilterChange}
        onReset={resetFilters}
        categories={categories}
        difficulties={difficulties}
        partsOfSpeech={partsOfSpeech}
        subcategories={subcategories}
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        onExport={handleExport}
        isLoading={isExporting}
      />
    </div>
  );
};

export default Dashboard;

============================================================

FILE: .\features\dashboard\types.ts
SIZE: 1.01 KB
LAST MODIFIED: 03/21/2025 16:58:56

// features/dashboard/types.ts
export interface TableState {
    sortConfig: {
      key: string;
      direction: 'asc' | 'desc';
    };
    pagination: {
      currentPage: number;
      rowsPerPage: number;
      totalItems: number;
      totalPages: number;
    };
    filters: {
      searchTerm: string;
      category: string;
      difficulty: string;
      subcategory: string;
      part_of_speech: string;
    };
  }
  
  export interface DashboardStateHook {
    activeTab: string;
    setActiveTab: (tab: string) => void;
    showWordCreatorModal: boolean;
    setShowWordCreatorModal: (show: boolean) => void;
    showReviewModal: boolean;
    setShowReviewModal: (show: boolean) => void;
    showFilterModal: boolean;
    setShowFilterModal: (show: boolean) => void;
    showExportModal: boolean;
    setShowExportModal: (show: boolean) => void;
    newIds: number[];
    setNewIds: (ids: number[]) => void;
    dateRange: number;
    updateDateRange: (days: number) => void;
  }

============================================================

FILE: .\features\dashboard\components\AnalyticsSection.tsx
SIZE: 8.79 KB
LAST MODIFIED: 03/21/2025 23:21:19

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import {
  RadialBarChart, RadialBar, BarChart, Bar, PieChart, Pie, LineChart, Line,
  XAxis, YAxis, CartesianGrid, Legend, ResponsiveContainer, Cell, PolarGrid, PolarRadiusAxis
} from 'recharts';
import { ChartTooltip, ChartTooltipContent } from '@/features/charts';
import { useMonthlyActivity } from '@/features/dashboard/hooks/useMonthlyActivity';



export const AnalyticsSection: React.FC = () => {
  return (
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Monthly Activity */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Monthly Activity</CardTitle>
                <CardDescription>Reviews, additions and edits over time</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={monthlyActivityData} margin={{ top: 10, right: 10, left: 0, bottom: 20 }}>
                      <CartesianGrid vertical={false} stroke="hsl(var(--muted-foreground) / 20%)" strokeDasharray="3 3" />
                      <XAxis dataKey="name" tick={{ fill: "hsl(var(--foreground))" }} tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} />
                      <YAxis tick={{ fill: "hsl(var(--foreground))" }} tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} />
                      <ChartTooltip 
                        content={props => 
                          <ChartTooltipContent 
                            {...props} 
                            config={chartConfig}
                          />
                        }
                      />
                      <Legend wrapperStyle={{ paddingTop: 20 }} />
                      <Bar dataKey="reviews" fill="hsl(var(--primary) / 80%)" />
                      <Bar dataKey="additions" fill="hsl(var(--primary) / 60%)" />
                      <Bar dataKey="edits" fill="hsl(var(--primary) / 40%)" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>

            {/* Category Distribution */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Category Distribution</CardTitle>
                <CardDescription>Phrases by category</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <PieChart>
                      <Pie
                        data={categoryData}
                        cx="50%"
                        cy="50%"
                        innerRadius={60}
                        outerRadius={90}
                        paddingAngle={2}
                        dataKey="value"
                        label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                      >
                        <Cell fill="hsl(var(--primary))" />
                        <Cell fill="hsl(var(--primary) / 90%)" />
                        <Cell fill="hsl(var(--primary) / 80%)" />
                        <Cell fill="hsl(var(--primary) / 70%)" />
                        <Cell fill="hsl(var(--primary) / 60%)" />
                      </Pie>
                      <ChartTooltip 
                        content={props => 
                          <ChartTooltipContent 
                            {...props} 
                            config={chartConfig}
                          />
                        }
                      />
                    </PieChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>

            {/* Top Reviewers Performance */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Top Reviewers Performance</CardTitle>
                <CardDescription>Reviews and streaks by contributor</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      layout="vertical"
                      data={[
                        { name: "Kari", reviews: 120, streak: 14 },
                        { name: "Sarah", reviews: 85, streak: 7 },
                        { name: "Justin", reviews: 65, streak: 5 },
                        { name: "Alex", reviews: 45, streak: 3 },
                        { name: "Morgan", reviews: 30, streak: 2 }
                      ]}
                      margin={{ top: 20, right: 30, left: 60, bottom: 5 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--muted-foreground) / 20%)" />
                      <XAxis
                        type="number"
                        tick={{ fill: "hsl(var(--foreground))" }}
                        tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
                        axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
                      />
                      <YAxis
                        dataKey="name"
                        type="category"
                        tick={{ fill: "hsl(var(--foreground))" }}
                        tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
                        axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
                      />
                      <ChartTooltip 
                        content={props => 
                          <ChartTooltipContent 
                            {...props} 
                            config={chartConfig}
                          />
                        }
                      />
                      <Legend />
                      <Bar dataKey="reviews" fill="hsl(var(--primary) / 80%)" />
                      <Bar dataKey="streak" fill="hsl(var(--primary) / 40%)" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>

            {/* Words Added This Month */}
            <Card className="border rounded-md">
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Words Added This Month</CardTitle>
                <CardDescription>Progress towards the goal of 100 words</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-[250px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <RadialBarChart
                      data={wordsAddedData}
                      innerRadius="80%"
                      outerRadius="100%"
                      startAngle={180}
                      endAngle={0}
                    >
                      <PolarGrid stroke="hsl(var(--muted))" />
                      <PolarRadiusAxis angle={30} domain={[0, 100]} tick={false} />
                      <RadialBar
                        dataKey="value"
                        cornerRadius={10}
                        background
                        fill="hsl(var(--primary))"
                      />
                      <text
                        x="50%"
                        y="50%"
                        textAnchor="middle"
                        dominantBaseline="middle"
                        className="fill-foreground text-2xl font-bold"
                      >
                        {wordsAddedData[0].value} / 100
                      </text>
                    </RadialBarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
              <CardFooter>
                <div className="w-full flex justify-between items-center">
                  <div className="text-sm text-muted-foreground">
                    Goal: <span className="font-bold text-foreground">100 words</span>
                  </div>
                  <div className="text-sm text-muted-foreground">
                    Remaining: <span className="font-bold text-foreground">{100 - wordsAddedData[0].value}</span>
                  </div>
                </div>
              </CardFooter>
            </Card>
          </div>
  );
};

============================================================

FILE: .\features\dashboard\components\DashboardHeader.tsx
SIZE: 2 KB
LAST MODIFIED: 03/21/2025 18:26:13

'use client';

import React from 'react';
import { Button } from "@/components/ui/button";
import { Moon, Sun } from "lucide-react";
import { ReviewerLoginButton } from '@/features/auth/ReviewerLoginButton';
import { ReviewerProfileDropdown } from '@/features/auth/ReviewerProfileDropdown';
import type { Reviewer } from '@/types/types';

interface DashboardHeaderProps {
  theme: string;
  setTheme: (theme: string) => void;
  onExportClick: () => void;
  currentReviewer: Reviewer | null;
  onLoginSuccess?: (reviewer: Reviewer) => void;
  onLogout: () => void;
  onAddWordsClick: () => void;
  onReviewWordsClick: () => void;
}

export function DashboardHeader({ 
  theme, 
  setTheme, 
  onExportClick,
  currentReviewer,
  onLoginSuccess,
  onLogout,
  onAddWordsClick,
  onReviewWordsClick
}: DashboardHeaderProps) {
  return (
    <div className="flex justify-between items-center">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground">Manage your catch phrases</p>
      </div>

      <div className="flex items-center gap-3">
        <Button
          variant="outline"
          size="icon"
          onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
          className="h-9 w-9 rounded-md"
        >
          {theme === 'dark' ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />}
        </Button>

        {currentReviewer ? (
          <ReviewerProfileDropdown 
            reviewer={currentReviewer} 
            reviewerIndex={0} 
            onLogout={onLogout}
            onExportClick={onExportClick}
            onAddWordsClick={onAddWordsClick}
            onReviewWordsClick={onReviewWordsClick}
          />
        ) : (
          <ReviewerLoginButton 
            variant="secondary"
            className="text-black bg-white hover:bg-gray-100 rounded-md border-0"
            onLoginSuccess={onLoginSuccess}
          />
        )}
      </div>
    </div>
  );
}

============================================================

FILE: .\features\dashboard\components\ExportModal.tsx
SIZE: 4.29 KB
LAST MODIFIED: 03/17/2025 21:35:28

// src/components/common/ExportModal.tsx

import React, { useState } from 'react';
import { saveAs } from 'file-saver';
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogFooter, 
  DialogHeader, 
  DialogTitle
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

interface ExportModalProps {
  isOpen: boolean;
  onClose: () => void;
  onExport: (options: ExportOptions) => Promise<ExportResult | null>;
  isLoading: boolean;
}

interface ExportOptions {
  exportJson: boolean;
  exportHeader: boolean;
  optimizeForESP32: boolean;
}

interface ExportResult {
  jsonData: any;
  headerContent: string;
}

const ExportModal: React.FC<ExportModalProps> = ({ 
  isOpen, 
  onClose, 
  onExport,
  isLoading
}) => {
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    exportJson: true,
    exportHeader: true,
    optimizeForESP32: true
  });

  const handleOptionChange = (option: keyof ExportOptions) => {
    setExportOptions(prev => ({
      ...prev,
      [option]: !prev[option]
    }));
  };

  const handleExport = async () => {
    const data = await onExport(exportOptions);
    
    if (!data) return;

    // Download files based on options
    if (exportOptions.exportJson) {
      const jsonBlob = new Blob(
        [JSON.stringify(data.jsonData, null, 2)], 
        { type: 'application/json' }
      );
      saveAs(jsonBlob, 'phrases_esp32.json');
    }
    
    if (exportOptions.exportHeader) {
      const headerBlob = new Blob(
        [data.headerContent], 
        { type: 'text/plain' }
      );
      saveAs(headerBlob, 'phrases.h');
    }

    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md bg-black border-neutral-800">
        <DialogHeader>
          <DialogTitle className="text-white">Export Phrases for ESP32</DialogTitle>
          <DialogDescription className="text-neutral-400">
            Choose export options for your ESP32 catch phrase game
          </DialogDescription>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-json" 
              checked={exportOptions.exportJson} 
              onCheckedChange={() => handleOptionChange('exportJson')}
            />
            <Label htmlFor="export-json" className="text-neutral-300">Export JSON file (for SPIFFS)</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-header" 
              checked={exportOptions.exportHeader} 
              onCheckedChange={() => handleOptionChange('exportHeader')}
            />
            <Label htmlFor="export-header" className="text-neutral-300">Export Arduino header file</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="optimize" 
              checked={exportOptions.optimizeForESP32} 
              onCheckedChange={() => handleOptionChange('optimizeForESP32')}
            />
            <Label htmlFor="optimize" className="text-neutral-300">Optimize for ESP32 memory usage</Label>
          </div>
        </div>
        
        <DialogFooter>
          <Button 
            type="button" 
            variant="outline" 
            onClick={onClose}
            className="border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white"
          >
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleExport}
            disabled={isLoading}
            className="bg-neutral-100 text-black hover:bg-white"
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Exporting...
              </>
            ) : (
              'Export'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default ExportModal;

============================================================

FILE: .\features\dashboard\components\ImportSection.tsx
SIZE: 0.49 KB
LAST MODIFIED: 03/21/2025 10:05:40

// features/dashboard/components/ImportSection.tsx
import React from 'react';
import BulkImportForm from '@/features/import/BulkImportForm';

interface ImportSectionProps {
  onSuccess?: () => void;
}

export const ImportSection: React.FC<ImportSectionProps> = ({ onSuccess }) => {
  const handleError = (error: string) => {
    console.error('Import error:', error);
  };

  return (
    <BulkImportForm 
      onSuccess={onSuccess} 
      onError={handleError} 
    />
  );
};

============================================================

FILE: .\features\dashboard\components\PhrasesSection.tsx
SIZE: 2.41 KB
LAST MODIFIED: 03/21/2025 10:04:10

// features/dashboard/components/PhrasesSection.tsx
import React from 'react';
import { PhrasesTable } from '@/features/phrases/phrasesTable';
import { FilterProvider } from '@/features/phrases/stores/filterContext';
import { useDeletePhrase } from '@/features/phrases/hooks/useDeletePhrase';
import { usePhrases } from '@/features/data/hooks/usePhrases';

interface PhrasesSectionProps {
  newIds: number[];
}

export const PhrasesSection: React.FC<PhrasesSectionProps> = ({ newIds }) => {
  const {
    phrases,
    loading: phrasesLoading,
    filters,
    pagination,
    sortConfig,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    fetchPhrases
  } = usePhrases();

  // Initialize the delete phrase mutation
  const deletePhraseMutation = useDeletePhrase();
  
  // Add handlers for edit and delete
  const handleEdit = (id: number) => {
    console.log('Editing phrase with ID:', id);
  };

  const handleDelete = (id: number) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      deletePhraseMutation.mutate(id, {
        onSuccess: () => {
          fetchPhrases();
        }
      });
    }
  };

  // Create a tableState object from the hook's state
  const tableState = {
    sortConfig,
    pagination,
    filters
  };

  // Function to update the table state
  const handleTableStateChange = (updates: any) => {
    if (updates.filters) {
      Object.entries(updates.filters).forEach(([key, value]) => {
        if (value !== undefined) {
          handleFilterChange(key, value as string);
        }
      });
    }
    
    if (updates.sortConfig?.key) {
      handleSort(updates.sortConfig.key);
    }
    
    if (updates.pagination) {
      if (updates.pagination.rowsPerPage) {
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
      
      if (updates.pagination.currentPage) {
        handlePageChange(updates.pagination.currentPage);
      }
    }
  };

  return (
    <div className="flex flex-col space-y-4">
      <FilterProvider>
        <PhrasesTable
          phrases={phrases}
          loading={phrasesLoading}
          tableState={tableState}
          onTableStateChange={handleTableStateChange}
          onEdit={handleEdit}
          onDelete={handleDelete}
          newIds={newIds}
        />
      </FilterProvider>
    </div>
  );
};

============================================================

FILE: .\features\dashboard\components\StatsCards.tsx
SIZE: 6.34 KB
LAST MODIFIED: 03/21/2025 18:41:00

// features/dashboard/components/StatsCards.tsx
import React, { useEffect, useState } from 'react';
import { Card } from '@/components/ui/card';
import { useDashboardState } from '../hooks/useDashboardState';
import { TrendingUp, TrendingDown, Minus, Award, Users, BookOpen, Clock } from 'lucide-react';

// Type for each stat card
type StatCardProps = {
  title: string;
  value: string | number;
  description: string;
  trend?: number;
  trendDirection?: 'up' | 'down' | 'neutral';
  timeframe: string;
  icon?: React.ReactNode;
  loading?: boolean;
  sparklineData?: number[];
};

// Individual stat card component
const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  trend = 0,
  trendDirection = 'neutral',
  timeframe,
  icon,
  loading = false,
  sparklineData = [],
}) => {
  // Determine color and icon based on trend direction
  const getTrendColor = () => {
    if (trendDirection === 'up') return 'text-green-500';
    if (trendDirection === 'down') return 'text-red-500';
    return 'text-gray-500';
  };

  const getTrendIcon = () => {
    if (trendDirection === 'up') return <TrendingUp className="w-4 h-4 ml-1" />;
    if (trendDirection === 'down') return <TrendingDown className="w-4 h-4 ml-1" />;
    return <Minus className="w-4 h-4 ml-1" />;
  };

  // Render sparkline if data is provided
  const renderSparkline = () => {
    if (!sparklineData.length) return null;
    
    const max = Math.max(...sparklineData);
    const min = Math.min(...sparklineData);
    const range = max - min || 1;
    
    return (
      <div className="h-8 mt-2">
        <svg width="100%" height="100%" viewBox={`0 0 ${sparklineData.length} 50`} preserveAspectRatio="none">
          {sparklineData.map((value, index) => {
            const height = ((value - min) / range) * 40 + 10;
            const x = index;
            const y = 50 - height;
            const color = trendDirection === 'up' ? '#10B981' : trendDirection === 'down' ? '#EF4444' : '#3B82F6';
            
            return (
              <rect 
                key={index} 
                x={x} 
                y={y} 
                width="0.8" 
                height={height}
                fill={color}
                rx="1"
              />
            );
          })}
        </svg>
      </div>
    );
  };

  return (
    <Card className="p-6  text-white shadow-lg">
      <div className="flex justify-between items-start">
        <div className="space-y-2">
          <h3 className="text-gray-400 text-sm uppercase font-medium">{title}</h3>
          <div className="flex items-baseline">
            <h2 className="text-2xl font-bold">{loading ? '...' : value}</h2>
            {trend !== 0 && (
              <span className={`text-sm ml-2 flex items-center ${getTrendColor()}`}>
                {trend > 0 ? '+' : ''}{trend}% {getTrendIcon()}
              </span>
            )}
          </div>
        </div>
        {icon && <div className="rounded-full p-2 bg-gray-800">{icon}</div>}
      </div>
      
      <p className="text-gray-400 text-sm mt-1">{description}</p>
      
      {renderSparkline()}
      
      <div className="mt-2 text-xs text-gray-500">
        {timeframe}
      </div>
    </Card>
  );
};

// Main StatsCards component
export const StatsCards: React.FC = () => {
  const { dateRange } = useDashboardState();
  const [stats, setStats] = useState({
    newPhrases: { value: 0, trend: 0, sparkline: [] },
    reviewedPhrases: { value: 0, trend: 0, sparkline: [] },
    activeReviewers: { value: 0, trend: 0 },
    topReviewer: { name: '', count: 0, streak: 0 }
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchStats = async () => {
      setLoading(true);
      try {
        const response = await fetch('/api/dashboard/stats', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ dateRange }),
        });
        
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        setStats(data);
      } catch (error) {
        console.error('Error fetching dashboard stats:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchStats();
  }, [dateRange]);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
      <StatCard
        title="NEW PHRASES"
        value={stats.newPhrases.value}
        description="Phrases added in the last month"
        trend={stats.newPhrases.trend}
        trendDirection={stats.newPhrases.trend > 0 ? 'up' : stats.newPhrases.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<BookOpen className="text-blue-500 w-5 h-5" />}
        loading={loading}
        sparklineData={stats.newPhrases.sparkline}
      />
      
      <StatCard
        title="PHRASES REVIEWED"
        value={stats.reviewedPhrases.value}
        description="Total reviews in the last month"
        trend={stats.reviewedPhrases.trend}
        trendDirection={stats.reviewedPhrases.trend > 0 ? 'up' : stats.reviewedPhrases.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<Clock className="text-green-500 w-5 h-5" />}
        loading={loading}
        sparklineData={stats.reviewedPhrases.sparkline}
      />
      
      <StatCard
        title="ACTIVE REVIEWERS"
        value={stats.activeReviewers.value}
        description="Unique reviewers this month"
        trend={stats.activeReviewers.trend}
        trendDirection={stats.activeReviewers.trend > 0 ? 'up' : stats.activeReviewers.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<Users className="text-purple-500 w-5 h-5" />}
        loading={loading}
      />
      
      <StatCard
        title="TOP REVIEWER"
        value={stats.topReviewer.name || 'N/A'}
        description={`${stats.topReviewer.count} reviews (${stats.topReviewer.streak} day streak)`}
        timeframe={`Last ${dateRange} days`}
        icon={<Award className="text-yellow-500 w-5 h-5" />}
        loading={loading}
      />
    </div>
  );
};

export default StatsCards;

============================================================

FILE: .\features\dashboard\components\charts\CategoryDistributionChart.tsx
SIZE: 7.04 KB
LAST MODIFIED: 03/21/2025 09:59:00

// features/dashboard/components/charts/CategoryDistributionChart.jsx
import React from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer } from 'recharts';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { ChartTooltip, ChartTooltipContent } from '@/features/charts';
import { useCategoryDistribution } from '@/features/dashboard/hooks/useCategoryDistribution';

export const CategoryDistributionChart = () => {
  const { categoryData } = useCategoryDistribution();
  
  // Chart configuration
  const chartConfig = {
    value: { label: 'Count', color: 'hsl(var(--primary))' }
  };

  return (
    <Card className="border rounded-md">
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Category Distribution</CardTitle>
        <CardDescription>Phrases by category</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-[250px]">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={categoryData}
                cx="50%"
                cy="50%"
                innerRadius={60}
                outerRadius={90}
                paddingAngle={2}
                dataKey="value"
                label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
              >
                <Cell fill="hsl(var(--primary))" />
                <Cell fill="hsl(var(--primary) / 90%)" />
                <Cell fill="hsl(var(--primary) / 80%)" />
                <Cell fill="hsl(var(--primary) / 70%)" />
                <Cell fill="hsl(var(--primary) / 60%)" />
              </Pie>
              <ChartTooltip 
                content={props => 
                  <ChartTooltipContent 
                    {...props} 
                    config={chartConfig}
                  />
                }
              />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};

// features/dashboard/components/charts/TopReviewersPerformanceChart.jsx
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Legend, ResponsiveContainer } from 'recharts';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { ChartTooltip, ChartTooltipContent } from '@/features/charts';

export const TopReviewersPerformanceChart = () => {
  // Sample data - could be fetched from a hook
  const reviewersData = [
    { name: "Kari", reviews: 120, streak: 14 },
    { name: "Sarah", reviews: 85, streak: 7 },
    { name: "Justin", reviews: 65, streak: 5 },
    { name: "Alex", reviews: 45, streak: 3 },
    { name: "Morgan", reviews: 30, streak: 2 }
  ];
  
  // Chart configuration
  const chartConfig = {
    reviews: { label: 'Reviews', color: 'hsl(var(--primary) / 80%)' },
    streak: { label: 'Streak', color: 'hsl(var(--primary) / 40%)' }
  };

  return (
    <Card className="border rounded-md">
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Top Reviewers Performance</CardTitle>
        <CardDescription>Reviews and streaks by contributor</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-[250px]">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              layout="vertical"
              data={reviewersData}
              margin={{ top: 20, right: 30, left: 60, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--muted-foreground) / 20%)" />
              <XAxis
                type="number"
                tick={{ fill: "hsl(var(--foreground))" }}
                tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
                axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
              />
              <YAxis
                dataKey="name"
                type="category"
                tick={{ fill: "hsl(var(--foreground))" }}
                tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
                axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }}
              />
              <ChartTooltip 
                content={props => 
                  <ChartTooltipContent 
                    {...props} 
                    config={chartConfig}
                  />
                }
              />
              <Legend />
              <Bar dataKey="reviews" fill="hsl(var(--primary) / 80%)" />
              <Bar dataKey="streak" fill="hsl(var(--primary) / 40%)" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};

// features/dashboard/components/charts/WordsAddedChart.jsx
import React from 'react';
import { RadialBarChart, RadialBar, PolarGrid, PolarRadiusAxis, ResponsiveContainer } from 'recharts';
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from "@/components/ui/card";

export const WordsAddedChart = () => {
  // Sample data - could be fetched from a hook
  const wordsAddedData = [
    { name: "Words Added", value: 45, fill: "hsl(var(--primary))" },
    { name: "Goal", value: 100, fill: "hsl(var(--muted))" },
  ];

  return (
    <Card className="border rounded-md">
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Words Added This Month</CardTitle>
        <CardDescription>Progress towards the goal of 100 words</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-[250px]">
          <ResponsiveContainer width="100%" height="100%">
            <RadialBarChart
              data={wordsAddedData}
              innerRadius="80%"
              outerRadius="100%"
              startAngle={180}
              endAngle={0}
            >
              <PolarGrid stroke="hsl(var(--muted))" />
              <PolarRadiusAxis angle={30} domain={[0, 100]} tick={false} />
              <RadialBar
                dataKey="value"
                cornerRadius={10}
                background
                fill="hsl(var(--primary))"
              />
              <text
                x="50%"
                y="50%"
                textAnchor="middle"
                dominantBaseline="middle"
                className="fill-foreground text-2xl font-bold"
              >
                {wordsAddedData[0].value} / 100
              </text>
            </RadialBarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
      <CardFooter>
        <div className="w-full flex justify-between items-center">
          <div className="text-sm text-muted-foreground">
            Goal: <span className="font-bold text-foreground">100 words</span>
          </div>
          <div className="text-sm text-muted-foreground">
            Remaining: <span className="font-bold text-foreground">{100 - wordsAddedData[0].value}</span>
          </div>
        </div>
      </CardFooter>
    </Card>
  );
};

============================================================

FILE: .\features\dashboard\components\charts\PhraseGrowthChart.tsx
SIZE: 8.55 KB
LAST MODIFIED: 03/21/2025 09:56:27

// features/dashboard/components/charts/PhraseGrowthChart.jsx
import React from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, ResponsiveContainer } from 'recharts';
import { TrendingUp } from "lucide-react";
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from "@/components/ui/card";
import { ChartContainer, ChartTooltip, ChartTooltipContent } from '@/features/charts';
import { useStats } from '@/features/data/hooks/useStats';
import { usePhraseGrowth } from '@/features/dashboard/hooks/usePhraseGrowth';

export const PhraseGrowthChart = () => {
  const { stats } = useStats();
  const { phrasesOverTime } = usePhraseGrowth();
  
  // Chart configuration
  const chartConfig = {
    phrases: { label: 'Phrases', color: 'var(--color-phrases)' },
  };

  return (
    <Card className="border rounded-md">
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Total Phrases</CardTitle>
        <CardDescription>Growth trend over time</CardDescription>
      </CardHeader>
      <CardContent className="pb-0">
        <div className="h-[120px]">
          <ChartContainer config={chartConfig}>
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={phrasesOverTime} margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
                <CartesianGrid stroke="#3F3F46" strokeDasharray="3 3" opacity={0.3} />
                <XAxis dataKey="month" tick={{ fill: 'white', fontSize: 10 }} axisLine={{ stroke: '#3F3F46' }} tickLine={{ stroke: '#3F3F46' }} />
                <YAxis tick={{ fill: 'white', fontSize: 10 }} axisLine={{ stroke: '#3F3F46' }} tickLine={{ stroke: '#3F3F46' }} />
                <ChartTooltip content={props => <ChartTooltipContent {...props} config={chartConfig} />} />
                <Line
                  type="monotone"
                  dataKey="phrases"
                  stroke="var(--color-phrases)"
                  strokeWidth={2}
                  dot={{ fill: 'var(--color-phrases)', r: 4 }}
                  activeDot={{ r: 6, fill: 'var(--color-phrases)' }}
                  isAnimationActive={false}
                />
                {phrasesOverTime[0]?.phrases === null && (
                  <text
                    x="50%"
                    y="50%"
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fill="#FF6B6B"
                    fontSize="14px"
                    fontWeight="bold"
                  >
                    No Data Available
                  </text>
                )}
              </LineChart>
            </ResponsiveContainer>
          </ChartContainer>
        </div>
      </CardContent>
      <CardFooter>
        <div className="flex w-full items-start gap-2 text-sm">
          <div className="grid gap-0">
            <div className="flex items-center gap-1 font-medium text-lg">
              {stats?.total || 1392} total phrases <TrendingUp className="h-4 w-4 ml-1 text-green-500" />
            </div>
            <div className="flex items-center gap-2 text-xs text-muted-foreground">
              Last 6 months
            </div>
          </div>
        </div>
      </CardFooter>
    </Card>
  );
};

// features/dashboard/components/charts/DifficultyDistributionChart.jsx
import React from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer } from 'recharts';
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from "@/components/ui/card";
import { ChartTooltip, ChartTooltipContent } from '@/features/charts';
import { useStats } from '@/features/data/hooks/useStats';

export const DifficultyDistributionChart = () => {
  const { stats } = useStats();
  
  // Chart configuration
  const chartConfig = {
    easy: { label: 'Easy', color: 'hsl(var(--primary) / 60%)' },
    medium: { label: 'Medium', color: 'hsl(var(--primary) / 80%)' },
    hard: { label: 'Hard', color: 'hsl(var(--primary))' }
  };

  return (
    <Card className="border rounded-md">
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Difficulty Distribution</CardTitle>
        <CardDescription>Distribution by difficulty level</CardDescription>
      </CardHeader>
      <CardContent className="pb-0">
        <div className="h-[120px]">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={[
                  { name: 'Easy', value: stats?.difficultyBreakdown?.easy || 30 },
                  { name: 'Medium', value: stats?.difficultyBreakdown?.medium || 20 },
                  { name: 'Hard', value: stats?.difficultyBreakdown?.hard || 10 },
                ]}
                cx="50%"
                cy="50%"
                innerRadius={25}
                outerRadius={45}
                paddingAngle={2}
                dataKey="value"
                label={({ name }) => name}
              >
                <Cell fill="hsl(var(--primary) / 60%)" />
                <Cell fill="hsl(var(--primary) / 80%)" />
                <Cell fill="hsl(var(--primary))" />
              </Pie>
              <ChartTooltip content={props => <ChartTooltipContent {...props} config={chartConfig} />} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
      <CardFooter className="pt-3">
        <div className="flex w-full items-center gap-4 text-sm justify-around">
          <div className="flex items-center gap-1">
            <div className="w-3 h-3 rounded-full bg-primary/60"></div>
            <span className="text-xs">Easy</span>
          </div>
          <div className="flex items-center gap-1">
            <div className="w-3 h-3 rounded-full bg-primary/80"></div>
            <span className="text-xs">Medium</span>
          </div>
          <div className="flex items-center gap-1">
            <div className="w-3 h-3 rounded-full bg-primary"></div>
            <span className="text-xs">Hard</span>
          </div>
        </div>
      </CardFooter>
    </Card>
  );
};

// features/dashboard/components/charts/MonthlyActivityChart.jsx
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Legend, ResponsiveContainer } from 'recharts';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { ChartTooltip, ChartTooltipContent } from '@/features/charts';
import { useMonthlyActivity } from '@/features/dashboard/hooks/useMonthlyActivity';

export const MonthlyActivityChart = () => {
  const { monthlyActivityData } = useMonthlyActivity();
  
  // Chart configuration
  const chartConfig = {
    reviews: { label: 'Reviews', color: 'hsl(var(--primary) / 80%)' },
    additions: { label: 'Additions', color: 'hsl(var(--primary) / 60%)' },
    edits: { label: 'Edits', color: 'hsl(var(--primary) / 40%)' }
  };

  return (
    <Card className="border rounded-md">
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Monthly Activity</CardTitle>
        <CardDescription>Reviews, additions and edits over time</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-[250px]">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={monthlyActivityData} margin={{ top: 10, right: 10, left: 0, bottom: 20 }}>
              <CartesianGrid vertical={false} stroke="hsl(var(--muted-foreground) / 20%)" strokeDasharray="3 3" />
              <XAxis dataKey="name" tick={{ fill: "hsl(var(--foreground))" }} tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} />
              <YAxis tick={{ fill: "hsl(var(--foreground))" }} tickLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} axisLine={{ stroke: "hsl(var(--muted-foreground) / 40%)" }} />
              <ChartTooltip 
                content={props => 
                  <ChartTooltipContent 
                    {...props} 
                    config={chartConfig}
                  />
                }
              />
              <Legend wrapperStyle={{ paddingTop: 20 }} />
              <Bar dataKey="reviews" fill="hsl(var(--primary) / 80%)" />
              <Bar dataKey="additions" fill="hsl(var(--primary) / 60%)" />
              <Bar dataKey="edits" fill="hsl(var(--primary) / 40%)" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};

// Add more chart components as needed...

============================================================

FILE: .\features\dashboard\hooks\useDashboardState.ts
SIZE: 2.89 KB
LAST MODIFIED: 03/21/2025 23:17:53

// features/dashboard/hooks/useDashboardState.ts
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase';
import { DashboardFilters } from '../types';

export const useDashboardState = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<string>('phrases');
  const [showWordCreatorModal, setShowWordCreatorModal] = useState<boolean>(false);
  const [showReviewModal, setShowReviewModal] = useState<boolean>(false);
  const [showFilterModal, setShowFilterModal] = useState<boolean>(false);
  const [showExportModal, setShowExportModal] = useState<boolean>(false);
  const [newIds, setNewIds] = useState<number[]>([]);
  const [dateRange, setDateRange] = useState<number>(30); // Default to 30 days
  const [filters, setFilters] = useState<DashboardFilters>({
    categories: [],
    subcategories: [],
    difficulty: [],
    dateRange: { start: null, end: null },
  });

  // Function to update date range
  const updateDateRange = useCallback((days: number) => {
    setDateRange(days);
  }, []);

  // Function to update filters
  const updateFilters = useCallback((newFilters: Partial<DashboardFilters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  }, []);

  // Function to reset filters
  const resetFilters = useCallback(() => {
    setFilters({
      categories: [],
      subcategories: [],
      difficulty: [],
      dateRange: { start: null, end: null },
    });
  }, []);

  // Load initial metadata (categories, subcategories, etc.)
  useEffect(() => {
    const loadMetadata = async () => {
      setIsLoading(true);
      setError(null);
      
      try {
        // Load categories
        const { data: categories, error: categoriesError } = await supabase
          .from('categories')
          .select('id, name');
        
        if (categoriesError) throw categoriesError;
        
        // Load subcategories
        const { data: subcategories, error: subcategoriesError } = await supabase
          .from('subcategories')
          .select('id, name, category_id');
        
        if (subcategoriesError) throw subcategoriesError;
        
        // Initialize any other necessary data
        
      } catch (err) {
        setError('Failed to load dashboard data');
        console.error('Dashboard data loading error:', err);
      } finally {
        setIsLoading(false);
      }
    };
    
    loadMetadata();
  }, []);

  return {
    isLoading,
    error,
    activeTab, 
    setActiveTab,
    showWordCreatorModal, 
    setShowWordCreatorModal,
    showReviewModal, 
    setShowReviewModal,
    showFilterModal, 
    setShowFilterModal,
    showExportModal, 
    setShowExportModal,
    newIds, 
    setNewIds,
    dateRange,
    updateDateRange,
    filters,
    updateFilters,
    resetFilters
  };
};

export default useDashboardState;

============================================================

FILE: .\features\dashboard\hooks\usePhraseGrowth.ts
SIZE: 4.18 KB
LAST MODIFIED: 03/21/2025 09:57:03

// features/dashboard/hooks/usePhraseGrowth.js
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';

export const usePhraseGrowth = () => {
  const [phrasesOverTime, setPhrasesOverTime] = useState([]);
  
  // Fetch phrases over time
  useEffect(() => {
    fetchPhrasesOverTime();
  }, []);
  
  /**
   * Fetch phrases over time data for chart
   */
  const fetchPhrasesOverTime = async () => {
    try {
      const { data, error } = await supabase
        .from('phrases')
        .select('created_at')
        .order('created_at');
      if (error) {
        console.error('Error fetching phrase timestamps:', error);
        setPhrasesOverTime(getErrorStateData());
        return;
      }
      if (data && data.length > 0) {
        const monthlyData = processTimestampData(data);
        setPhrasesOverTime(monthlyData);
      } else {
        setPhrasesOverTime(getErrorStateData());
      }
    } catch (err) {
      console.error('Error fetching phrase timestamps:', err);
      setPhrasesOverTime(getErrorStateData());
    }
  };

  /**
   * Process timestamp data for charts
   */
  const processTimestampData = (data) => {
    const monthCounts = {};
    data.forEach(item => {
      if (!item.created_at) return;
      const date = new Date(item.created_at);
      const month = date.toLocaleString('default', { month: 'short' });
      const year = date.getFullYear();
      const key = `${month} ${year}`;
      if (!monthCounts[key]) {
        monthCounts[key] = { month, year, count: 0, fullDate: date };
      }
      monthCounts[key].count++;
    });
    return Object.values(monthCounts)
      .sort((a, b) => a.fullDate - b.fullDate)
      .map(item => ({ month: item.month, year: item.year, phrases: item.count }))
      .slice(-6);
  };

  /**
   * Get fallback data for charts when error occurs
   */
  const getErrorStateData = () => {
    return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'].map(month => ({
      month,
      year: new Date().getFullYear(),
      phrases: null
    }));
  };
  
  return {
    phrasesOverTime,
    fetchPhrasesOverTime
  };
};

// features/dashboard/hooks/useMonthlyActivity.js
import { useState, useEffect } from 'react';

export const useMonthlyActivity = () => {
  const [monthlyActivityData, setMonthlyActivityData] = useState([]);
  
  // Generate monthly activity data for charts
  useEffect(() => {
    const generateMonthlyActivityData = () => {
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
      return months.map(month => ({
        name: month,
        reviews: Math.floor(Math.random() * 100) + 50,
        additions: Math.floor(Math.random() * 40) + 10,
        edits: Math.floor(Math.random() * 30) + 5,
      }));
    };
    
    setMonthlyActivityData(generateMonthlyActivityData());
  }, []);
  
  return {
    monthlyActivityData
  };
};

// features/dashboard/hooks/useCategoryDistribution.js
import { useState, useEffect } from 'react';
import { usePhraseMetadata } from '@/features/data/hooks/usePhraseMetadata';

export const useCategoryDistribution = () => {
  const [categoryData, setCategoryData] = useState([]);
  const { categories } = usePhraseMetadata();
  
  // Generate category data for charts
  useEffect(() => {
    const generateCategoryData = () => {
      if (categories && categories.length > 0) {
        // You could implement real data fetching here
        return [
          { name: 'Animals & Plants', value: 30 },
          { name: 'Art & Design', value: 22 },
          { name: 'Education & Learning', value: 13 },
          { name: 'Celebrations & Traditions', value: 16 },
          { name: 'Business & Careers', value: 19 },
        ];
      }
      return [
        { name: 'Animals & Plants', value: 30 },
        { name: 'Art & Design', value: 22 },
        { name: 'Education & Learning', value: 13 },
        { name: 'Celebrations & Traditions', value: 16 },
        { name: 'Business & Careers', value: 19 },
      ];
    };
    
    setCategoryData(generateCategoryData());
  }, [categories]);
  
  return {
    categoryData
  };
};

// Add more hooks as needed...

============================================================

FILE: .\features\dashboard\hooks\useTableState.ts
SIZE: 2.94 KB
LAST MODIFIED: 03/21/2025 09:58:31

// features/dashboard/hooks/useTableState.js
import { useState, useEffect } from 'react';
import { usePhrases } from '@/features/data/hooks/usePhrases';

export const useTableState = () => {
  const {
    phrases,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
  } = usePhrases();

  // Initialize table state
  const [tableState, setTableState] = useState({
    sortConfig: {
      key: '',
      direction: 'asc'
    },
    pagination: {
      currentPage: 1,
      rowsPerPage: 10,
      totalItems: 0,
      totalPages: 1
    },
    filters: {
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    }
  });

  // Sync Table State with hook state
  useEffect(() => {
    if (phrases && pagination) {
      const totalItems = pagination.totalItems || phrases.length || 0;
      const rowsPerPage = pagination.rowsPerPage || 10;
      const totalPages = Math.ceil(totalItems / rowsPerPage);
      
      setTableState(prev => ({
        ...prev,
        sortConfig,
        pagination: {
          ...pagination,
          rowsPerPage,
          totalItems,
          totalPages,
          currentPage: Math.min(pagination.currentPage, totalPages || 1)
        },
        filters,
      }));
    }
  }, [phrases, pagination, sortConfig, filters]);

  /**
   * Handle table state changes
   */
  const handleTableStateChange = (updates) => {
    // Update local state first
    setTableState(prev => {
      const newState = { ...prev };
      
      if (updates.filters) {
        newState.filters = { ...prev.filters, ...updates.filters };
      }
      
      if (updates.sortConfig) {
        newState.sortConfig = { ...prev.sortConfig, ...updates.sortConfig };
      }
      
      if (updates.pagination) {
        newState.pagination = { ...prev.pagination, ...updates.pagination };
      }
      
      return newState;
    });
    
    // Then immediately propagate changes to the hooks
    if (updates.filters) {
      // Apply each filter individually to ensure all are updated
      Object.entries(updates.filters).forEach(([key, value]) => {
        if (value !== undefined) { // Only update if value is provided
          handleFilterChange(key, value || '');
        }
      });
    }
    
    if (updates.sortConfig && updates.sortConfig.key) {
      handleSort(updates.sortConfig.key);
    }
    
    if (updates.pagination) {
      // Note: Order matters here! First update rows per page, then page number
      if (updates.pagination.rowsPerPage) {
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
      
      if (updates.pagination.currentPage) {
        handlePageChange(updates.pagination.currentPage);
      }
    }
  };

  return {
    tableState,
    setTableState,
    handleTableStateChange
  };
};

============================================================

FILE: .\features\dashboard\styles\dashboard.css
SIZE: 1.53 KB
LAST MODIFIED: 03/06/2025 22:07:22

@keyframes flash {
  0%, 100% {
    background-color: transparent;
  }
  50% {
    background-color: var(--accent);
  }
}

.animate-flash {
  animation: flash 1.5s ease-in-out;
}

/* Table row hover effect */
.table-row-hover {
  transition: background-color 0.15s ease;
}

.table-row-hover:hover {
  background-color: var(--muted);
}

/* Ensure top margin for pie labels */
.recharts-pie-label-text {
  margin-top: 5px; /* Fix for cut-off text */
}

/* Chart hover effects */
.recharts-wrapper {
  margin-top: 5px;
}

/* Chart style updates */
.recharts-bar-rectangle:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

.recharts-pie-sector:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

/* Custom grayscale palette for charts */
.chart-gray-100 {
  fill: #f5f5f5;
}

.chart-gray-200 {
  fill: #e0e0e0;
}

.chart-gray-300 {
  fill: #cccccc;
}

.chart-gray-400 {
  fill: #bbbbbb;
}

.chart-gray-500 {
  fill: #999999;
}

.chart-gray-600 {
  fill: #777777;
}

.chart-gray-700 {
  fill: #555555;
}

.chart-gray-800 {
  fill: #333333;
}

/* Tooltip styling */
.custom-tooltip {
  background-color: var(--background);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  padding: 0.5rem;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Login button styling */
.login-button {
  background-color: white;
  color: black;
  border: 1px solid var(--border);
}

.login-button:hover {
  background-color: #f0f0f0;
}

============================================================

FILE: .\features\data\hooks\usePhraseMetadata.ts
SIZE: 2.39 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';

interface PhraseMetadata {
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
  error: string | null;
}

interface CategoryRecord {
  name: string;
}

interface PartOfSpeechRecord {
  part_of_speech: string;
}

export const usePhraseMetadata = (): PhraseMetadata => {
  const [categories, setCategories] = useState<string[]>([]);
  const [difficulties, setDifficulties] = useState<string[]>([]);
  const [partsOfSpeech, setPartsOfSpeech] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchMetadata = async () => {
      setLoading(true);
      setError(null);
      
      try {
        // Fetch categories
        const { data: categoryData, error: categoryError } = await supabase
          .from('categories')
          .select('name')
          .order('name');

        if (categoryError) throw categoryError;

        // Fetch parts of speech from phrases
        const { data: posData, error: posError } = await supabase
          .from('phrases')
          .select('part_of_speech')
          .not('part_of_speech', 'is', null);

        if (posError) throw posError;

        // Process categories
        const uniqueCategories = Array.from(
          new Set((categoryData as CategoryRecord[]).map(record => record.name))
        );

        // Process parts of speech
        const uniquePartsOfSpeech = Array.from(
          new Set((posData as PartOfSpeechRecord[])
            .map(record => record.part_of_speech)
            .filter(Boolean))
        ).sort();

        // Set predefined difficulties
        const difficultyLevels = ['Easy', 'Medium', 'Hard'];

        setCategories(uniqueCategories);
        setDifficulties(difficultyLevels);
        setPartsOfSpeech(uniquePartsOfSpeech);
      } catch (err) {
        console.error('Error fetching metadata:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch metadata');
      } finally {
        setLoading(false);
      }
    };

    fetchMetadata();
  }, []);

  return {
    categories,
    difficulties,
    partsOfSpeech,
    loading,
    error
  };
};

export default usePhraseMetadata;


============================================================

FILE: .\features\data\hooks\usePhrases.ts
SIZE: 6.12 KB
LAST MODIFIED: 03/17/2025 21:29:25

// hooks/usePhrases.ts

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase'
import type { Phrase, PaginationState, SortConfig, Filters } from '@/types/types';

export const usePhrases = () => {
  const [phrases, setPhrases] = useState<Phrase[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    rowsPerPage: 10,  // Default to 10 rows per page
    totalPages: 1,
    totalItems: 0
  });

  const [sortConfig, setSortConfig] = useState<SortConfig>({
    key: '',
    direction: 'asc'
  });

  const [filters, setFilters] = useState<Filters>({
    searchTerm: '',
    category: '',
    difficulty: '',
    subcategory: '',
    part_of_speech: ''
  });

  const fetchPhrases = useCallback(async () => {
    try {
      setLoading(true);
      let query = supabase
      .from('phrases')
      .select(`
        *,
        categories:category_id(id, name),
        subcategories:subcategory_id(id, name),
        phrase_tags!inner(
          tags(id, tag)
        )
      `, { count: 'exact' });
      // Apply filters
      if (filters.category) {
        // First get the category id
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          query = query.eq('category_id', categoryData.id);
        }
      }

      if (filters.difficulty) {
        query = query.eq('difficulty', filters.difficulty);
      }

      if (filters.subcategory) {
        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('id')
          .eq('name', filters.subcategory)
          .single();

        if (subcategoryData) {
          query = query.eq('subcategory_id', subcategoryData.id);
        }
      }

      if (filters.part_of_speech) {
        query = query.eq('part_of_speech', filters.part_of_speech);
      }

      if (filters.searchTerm) {
        query = query.or(`phrase.ilike.%${filters.searchTerm}%`);
      }

      // Apply sorting
      if (sortConfig.key) {
        query = query.order(sortConfig.key, {
          ascending: sortConfig.direction === 'asc',
          nullsFirst: false
        });
      } else {
        // Default sort
        query = query.order('id', { ascending: false });
      }

      // Apply pagination
      console.log('Pagination values:', {
        currentPage: pagination.currentPage,
        rowsPerPage: pagination.rowsPerPage,
        calculatedStart: (pagination.currentPage - 1) * pagination.rowsPerPage,
        calculatedEnd: (pagination.currentPage - 1) * pagination.rowsPerPage + pagination.rowsPerPage - 1
      });
      const start = (pagination.currentPage - 1) * pagination.rowsPerPage;
      const end = start + pagination.rowsPerPage - 1;
      query = query.range(start, end);

      const { data, error: supabaseError, count } = await query as SupabaseQueryResponse<PhraseWithRelations>;

    if (supabaseError) throw supabaseError;

      // Transform the data
      const transformedData = data?.map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      setPhrases(transformedData || []);
      
      if (count !== null) {
        const totalPages = Math.ceil(count / pagination.rowsPerPage);
        setPagination(prev => ({
          ...prev,
          totalItems: count,
          totalPages: totalPages,
          // Ensure currentPage doesn't exceed total pages
          currentPage: Math.min(prev.currentPage, totalPages || 1)
        }));
      }
  
      setPhrases(transformedData || []);
    } catch (err) {
      // ... Error handling ...
    } finally {
      setLoading(false);
    }
  }, [filters, sortConfig, pagination.currentPage, pagination.rowsPerPage]);

  // Fetch categories for the filter
  const fetchCategories = async () => {
    try {
      const { data, error } = await supabase
        .from('categories')
        .select('name')
        .order('name');
        
      if (error) {
        console.error('Supabase error fetching categories:', error);
        return [];
      }
      
      return data.map(category => category.name);
    } catch (error) {
      console.error('Error fetching categories:', error);
      return [];
    }
  };

  const handleFilterChange = (name: string, value: string) => {
    setFilters(prev => ({ ...prev, [name]: value }));
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const resetFilters = () => {
    setFilters({
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    });
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const handleSort = (key: keyof Phrase) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };

  const handlePageChange = (page: number) => {
    setPagination(prev => ({
      ...prev,
      currentPage: page
    }));
  };

  const handleRowsPerPageChange = (rowsPerPage: number) => {
    setPagination(prev => ({
      ...prev,
      rowsPerPage,
      currentPage: 1,  // Reset to page 1 when changing rows per page
      totalPages: Math.ceil((prev.totalItems || 0) / rowsPerPage)
    }));
  };

  useEffect(() => {
    fetchPhrases();
  }, [fetchPhrases, pagination.currentPage, pagination.rowsPerPage, filters, sortConfig]);

  return {
    phrases,
    loading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    resetFilters,
    fetchCategories,
    fetchPhrases,
    setError
  };
};

============================================================

FILE: .\features\data\hooks\useReviewers.ts
SIZE: 0.95 KB
LAST MODIFIED: 03/05/2025 15:03:18

// hooks/useReviewers.ts
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Reviewer } from '@/types/types';

export const useReviewers = () => {
  const [reviewers, setReviewers] = useState<Reviewer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchReviewers = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });

      if (error) throw error;
      setReviewers(data || []);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to fetch reviewers'));
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchReviewers();
  }, []);

  return { reviewers, loading, error, refetch: fetchReviewers };
};


============================================================

FILE: .\features\data\hooks\useStats.ts
SIZE: 2.84 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Stats, Phrase } from '@/types/types';

interface UseStatsReturn {
  stats: Stats;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const useStats = (): UseStatsReturn => {
  const [stats, setStats] = useState<Stats>({
    total: 0,
    uniqueCategories: 0,
    difficultyBreakdown: {
      easy: 0,
      medium: 0,
      hard: 0,
    },
  });

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const calculateStats = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const { data: phrases, error: fetchError, count } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id (name)
        `, { count: 'exact' });

      if (fetchError) throw fetchError;
      if (!phrases) throw new Error('No data received');

      // Calculate unique categories
      const uniqueCategories = new Set(phrases.map((p) => p.categories?.name)).size;

      // Map difficulty numbers to labels
      const difficultyLabels = {
        1: 'easy',
        2: 'medium',
        3: 'hard',
      };

      // Calculate difficulty breakdown
      const difficultyCount = phrases.reduce((acc: Record<string, number>, phrase) => {
        const difficultyLabel = difficultyLabels[phrase.difficulty] || 'unknown';
        acc[difficultyLabel] = (acc[difficultyLabel] || 0) + 1;
        return acc;
      }, {});

      const total = count || phrases.length;

      // Calculate percentages
      let easy = Math.round(((difficultyCount['easy'] || 0) / total) * 100);
      let medium = Math.round(((difficultyCount['medium'] || 0) / total) * 100);
      let hard = Math.round(((difficultyCount['hard'] || 0) / total) * 100);

      // Adjust for rounding errors
      const sum = easy + medium + hard;
      if (sum !== 100) {
        const diff = 100 - sum;
        if (easy >= medium && easy >= hard) {
          easy += diff;
        } else if (medium >= easy && medium >= hard) {
          medium += diff;
        } else {
          hard += diff;
        }
      }

      setStats({
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard,
        },
      });
    } catch (err) {
      console.error('Error calculating stats:', err);
      setError(err instanceof Error ? err.message : 'Failed to calculate stats');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    calculateStats();
  }, [calculateStats]);

  return {
    stats,
    loading,
    error,
    refetch: calculateStats,
  };
};

export default useStats;


============================================================

FILE: .\features\filters\FilterModal.tsx
SIZE: 5.5 KB
LAST MODIFIED: 03/05/2025 16:59:06

// components/common/FilterModal.tsx
import React from 'react';
import { X, Search } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface FilterModalProps {
  isOpen: boolean;
  onClose: () => void;
  filters: {
    searchTerm: string;
    category: string;
    difficulty: string;
    subcategory: string;
    part_of_speech: string;
  };
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  subcategories: string[];
}

const FilterModal: React.FC<FilterModalProps> = ({
  isOpen,
  onClose,
  filters,
  onChange,
  onReset,
  categories,
  difficulties,
  partsOfSpeech,
  subcategories = []
}) => {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Filter Phrases</DialogTitle>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          {/* Search */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Search</label>
            <div className="relative">
              <Search className="absolute left-3 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                value={filters.searchTerm}
                onChange={(e) => onChange('searchTerm', e.target.value)}
                placeholder="Search phrases or tags..."
                className="pl-9"
              />
            </div>
          </div>
          
          {/* Category */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Category</label>
            <Select
              value={filters.category}
              onValueChange={(value) => onChange('category', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Categories</SelectItem>
                {categories.map(category => (
                  <SelectItem key={category} value={category}>
                    {category}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Subcategory */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Subcategory</label>
            <Select
              value={filters.subcategory}
              onValueChange={(value) => onChange('subcategory', value)}
              disabled={!filters.category}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Subcategories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Subcategories</SelectItem>
                {subcategories.map(subcategory => (
                  <SelectItem key={subcategory} value={subcategory}>
                    {subcategory}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Difficulty */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Difficulty</label>
            <Select
              value={filters.difficulty}
              onValueChange={(value) => onChange('difficulty', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Difficulties" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Difficulties</SelectItem>
                {difficulties.map(difficulty => (
                  <SelectItem key={difficulty} value={difficulty}>
                    {difficulty}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Part of Speech */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Part of Speech</label>
            <Select
              value={filters.part_of_speech}
              onValueChange={(value) => onChange('part_of_speech', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Parts of Speech" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Parts of Speech</SelectItem>
                {partsOfSpeech.map(pos => (
                  <SelectItem key={pos} value={pos}>
                    {pos}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
        
        <DialogFooter className="flex justify-between">
          <Button 
            variant="outline" 
            onClick={onReset}
            className="flex items-center gap-1"
          >
            <X className="h-4 w-4" />
            Reset Filters
          </Button>
          <Button type="submit" onClick={onClose}>Apply Filters</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default FilterModal;

============================================================

FILE: .\features\import\BulkImportForm.tsx
SIZE: 3.89 KB
LAST MODIFIED: 03/06/2025 22:11:26

import React, { useState, useRef } from 'react';
import { Upload } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import type { BulkImportFormProps, NewPhrase } from '@/types/types';
import { supabase } from '@/lib/services/supabase';
import Papa from 'papaparse';

const BulkImportForm: React.FC<BulkImportFormProps> = ({
  onSuccess,
  onError
}) => {
  const [bulkImportText, setBulkImportText] = useState('');
  const [loading, setLoading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Existing handleBulkImport code and other processing functions

  const handleFileSelect = async (file: File) => {
    try {
      const text = await file.text();
      setBulkImportText(text);
    } catch (err) {
      console.error('File reading error:', err);
      onError('Failed to read file');
    }
  };

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(e.type === 'dragenter' || e.type === 'dragover');
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    const file = e.dataTransfer.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Bulk Import</CardTitle>
      </CardHeader>
      <CardContent>
        <div
          className={`relative border-2 border-dashed rounded-lg p-6 mb-4
            ${dragActive 
              ? 'border-blue-500 bg-blue-500/10' 
              : 'border-gray-600'
            }`}
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          <input
            ref={fileInputRef}
            type="file"
            onChange={handleFileInput}
            accept=".csv"
            className="hidden"
          />
          
          <div className="text-center">
            <Upload className="mx-auto h-12 w-12 text-gray-400" />
            <p className="mt-2 text-sm text-gray-400">
              Drag and drop a CSV file, or{' '}
              <button
                type="button"
                onClick={() => fileInputRef.current?.click()}
                className="text-blue-500 hover:text-blue-400"
              >
                browse
              </button>
            </p>
          </div>
        </div>

        <textarea
          value={bulkImportText}
          onChange={(e) => setBulkImportText(e.target.value)}
          className="w-full h-32 p-2 mb-4 border rounded bg-background focus:ring-2 focus:ring-blue-500"
          placeholder="phrase,category,difficulty,subcategory,tags,hint,part_of_speech"
        />

        <p className="text-sm text-muted-foreground mb-4">
          Format: phrase,category,difficulty,subcategory,tags,hint,part_of_speech
        </p>

        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => setBulkImportText('')}
            disabled={loading || !bulkImportText.trim()}
          >
            Clear
          </Button>
          <Button
            onClick={() => handleBulkImport(bulkImportText)}
            disabled={loading || !bulkImportText.trim()}
            className="bg-white text-black hover:bg-gray-100"
          >
            {loading ? 'Importing...' : 'Import Phrases'}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default BulkImportForm;

============================================================

FILE: .\features\phrases\ReviewModal.tsx
SIZE: 22.48 KB
LAST MODIFIED: 03/21/2025 23:09:32

'use client';

import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { ChevronLeft, ChevronRight, Flag } from 'lucide-react';
import { supabase } from '@/lib/services/supabase';
import { usePhrases } from '@/features/data/hooks/usePhrases';
import { generateTags, generateHint } from '@/lib/services/claudeService';
import type { Reviewer } from '@/types/types';

interface ReviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  reviewer: Reviewer;
  selectedPhraseId?: number | null;
}

interface EditedPhrase {
  id: number;
  category: string | undefined;
  hint?: string | undefined;
  difficulty?: number | undefined;
  tags?: string[] | undefined;
}

const ReviewModal: React.FC<ReviewModalProps> = ({
  isOpen,
  onClose,
  reviewer,
  selectedPhraseId 
}) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [selectedCategory, setSelectedCategory] = useState<string>('all');
  const [categories, setCategories] = useState<string[]>([]);
  const [isFlagged, setIsFlagged] = useState(false);
  const [isApproved, setIsApproved] = useState(false);
  const [isApproving, setIsApproving] = useState(false);
  const [isGeneratingTags, setIsGeneratingTags] = useState(false);
  const [isGeneratingHint, setIsGeneratingHint] = useState(false);
  const [streak, setStreak] = useState(0);
  const [showCelebration, setShowCelebration] = useState(false);
  const [editedPhrase, setEditedPhrase] = useState<EditedPhrase>({
    id: -1,
    category: undefined,
    hint: undefined,
    difficulty: undefined,
    tags: undefined
  });
  const [hasChanges, setHasChanges] = useState(false);
  
  const {
    phrases,
    loading: phrasesLoading,
    handleFilterChange,
    fetchCategories: fetchCategoriesFromHook,
    fetchPhrases
  } = usePhrases();

  // Fetch categories on load
  useEffect(() => {
    const loadCategories = async () => {
      const fetchedCategories = await fetchCategoriesFromHook();
      if (fetchedCategories) {
        setCategories(fetchedCategories);
      }
    };
    loadCategories();
  }, [fetchCategoriesFromHook]);

  // Reset current index when modal opens or filter changes
  useEffect(() => {
    if (isOpen) {
      setCurrentIndex(0);
      setIsFlagged(false);
      setHasChanges(false);
      
      // Get the reviewer's streak from local storage or set it to 0
      const savedStreak = localStorage.getItem(`reviewer-streak-${reviewer.id}`);
      if (savedStreak) {
        setStreak(parseInt(savedStreak));
      } else {
        setStreak(0);
      }
    }
  }, [isOpen, selectedCategory, reviewer.id]);

  useEffect(() => {
    if (isOpen && selectedPhraseId && phrases.length > 0) {
      const index = phrases.findIndex(p => p.id === selectedPhraseId);
      if (index !== -1) {
        setCurrentIndex(index);
      }
    }
  }, [isOpen, selectedPhraseId, phrases]);
  // Check if current phrase is flagged
  useEffect(() => {
    const checkFlagged = async () => {
      if (!phrases[currentIndex] || !reviewer) return;
      
      try {
        const { data, error } = await supabase
          .from('votes')
          .select('*')
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', false)
          .maybeSingle();
          
        setIsFlagged(!!data);
      } catch (err) {
        console.error('Error checking flag status:', err);
      }
    };
    
    checkFlagged();
  }, [phrases, currentIndex, reviewer]);

  // Check if phrase is already approved
  useEffect(() => {
    const checkApprovalStatus = async () => {
      if (!phrases[currentIndex] || !reviewer) return;
      
      try {
        const { data, error } = await supabase
          .from('votes')
          .select('*')
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', true)
          .maybeSingle();
          
        setIsApproved(!!data);
      } catch (err) {
        console.error('Error checking approval status:', err);
      }
    };
    
    checkApprovalStatus();
  }, [phrases, currentIndex, reviewer]);

  // Load current phrase data
  useEffect(() => {
    const loadPhraseData = async () => {
      if (!phrases[currentIndex]) return;
      
      const currentPhrase = phrases[currentIndex];
      
      if (currentPhrase) {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('name')
          .eq('id', currentPhrase.category_id)
          .single();

        // Get tags as array
        let tagsArray: string[] = [];
        if (currentPhrase.tags) {
          tagsArray = currentPhrase.tags.split(',').map(tag => tag.trim());
        }

        setEditedPhrase({
          id: currentPhrase.id,
          category: categoryData?.name || undefined,
          hint: currentPhrase.hint || undefined,
          difficulty: currentPhrase.difficulty || undefined,
          tags: tagsArray
        });
        
        setHasChanges(false);
      }
    };

    loadPhraseData();
  }, [phrases, currentIndex]);

  const handleCategorySelect = (category: string) => {
    setSelectedCategory(category);
    // If "all" is selected, pass empty string to filter function
    handleFilterChange('category', category === 'all' ? '' : category);
    setCurrentIndex(0);
  };

  const handleNext = () => {
    if (currentIndex < phrases.length - 1) {
      setCurrentIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentIndex(prev => prev - 1);
    }
  };

  // Increment and manage streak
  const incrementStreak = () => {
    const newStreak = streak + 1;
    setStreak(newStreak);
    localStorage.setItem(`reviewer-streak-${reviewer.id}`, newStreak.toString());
    
    // Check if we've hit a milestone (10)
    if (newStreak >= 10) {
      setShowCelebration(true);
      
      // Reset streak after celebration
      setTimeout(() => {
        setStreak(0);
        localStorage.setItem(`reviewer-streak-${reviewer.id}`, '0');
        setShowCelebration(false);
      }, 3000);
    }
    
    // Update reviewer streak in database
    supabase
      .from('reviewers')
      .update({
        current_streak: newStreak % 10, // Keep it within 0-9
        last_review_at: new Date().toISOString()
      })
      .eq('id', reviewer.id)
      .then(() => {})
      .catch(err => console.error('Error updating streak:', err));
  };

  const handleFlag = async () => {
    if (!reviewer || !phrases[currentIndex]) return;
    
    const newFlagState = !isFlagged;
    setIsFlagged(newFlagState);
    
    try {
      if (newFlagState) {
        const { error } = await supabase
          .from('votes')
          .insert({
            reviewer_id: reviewer.id,
            phrase_id: phrases[currentIndex].id,
            category: 'phrase',
            vote: false,
            created_at: new Date().toISOString()
          });
          
        if (error) {
          setIsFlagged(!newFlagState);
          throw error;
        }
      } else {
        const { error } = await supabase
          .from('votes')
          .delete()
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', false);
          
        if (error) {
          setIsFlagged(!newFlagState);
          throw error;
        }
      }
    } catch (err) {
      console.error('Error toggling flag:', err);
    }
  };

  const handleFieldChange = (field: keyof EditedPhrase, value: any) => {
    setEditedPhrase(prev => ({ ...prev, [field]: value }));
    setHasChanges(true);
  };

  const handleTagChange = (index: number, value: string) => {
    const newTags = [...(editedPhrase.tags || ['', '', ''])];
    while (newTags.length < 3) newTags.push('');
    
    newTags[index] = value.trim();
    handleFieldChange('tags', newTags);
  };

  const handleGenerateTags = async () => {
    if (!phrases[currentIndex]?.phrase) return;

    setIsGeneratingTags(true);
    try {
      const result = await generateTags(phrases[currentIndex].phrase);
      if (result.tags.length > 0) {
        const newTags = result.tags.slice(0, 3);
        while (newTags.length < 3) newTags.push('');
        handleFieldChange('tags', newTags);
      }
    } catch (error) {
      console.error('Error generating tags:', error);
    } finally {
      setIsGeneratingTags(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!phrases[currentIndex]?.phrase) return;
  
    setIsGeneratingHint(true);
    try {
      const result = await generateHint(phrases[currentIndex].phrase);
      if (result.hint) {
        handleFieldChange('hint', result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
    } finally {
      setIsGeneratingHint(false);
    }
  };

  const handleApprove = async () => {
    if (!reviewer || !phrases[currentIndex]) return;
    
    setIsApproving(true);
    
    try {
      // Save any changes first if needed
      if (hasChanges) {
        await handleSave();
      }
      
      // Add or update the approval vote
      const { error } = await supabase
        .from('votes')
        .upsert({
          reviewer_id: reviewer.id,
          phrase_id: phrases[currentIndex].id,
          category: 'phrase',
          vote: true,
          created_at: new Date().toISOString()
        });
        
      if (error) throw error;
      
      // Set as approved
      setIsApproved(true);
      
      // Increment streak
      incrementStreak();
      
      // Move to next phrase if not at the end
      if (currentIndex < phrases.length - 1) {
        setCurrentIndex(prev => prev + 1);
      }
    } catch (err) {
      console.error('Error approving phrase:', err);
    } finally {
      setIsApproving(false);
    }
  };
  
  // Original save function for changes only
  const handleSave = async () => {
    if (!editedPhrase.id || editedPhrase.id === -1) return;

    try {
      // Get category ID
      const { data: categoryData } = await supabase
        .from('categories')
        .select('id')
        .eq('name', editedPhrase.category)
        .single();
        
      if (!categoryData) throw new Error('Category not found');
      const categoryId = categoryData.id;
      
      // Update phrase
      const { error: phraseError } = await supabase
        .from('phrases')
        .update({
          hint: editedPhrase.hint,
          difficulty: editedPhrase.difficulty,
          category_id: categoryId,
          subcategory_id: null
        })
        .eq('id', editedPhrase.id);

      if (phraseError) throw phraseError;

      // Handle tags
      if (editedPhrase.tags) {
        const newTags = editedPhrase.tags.filter(Boolean);
        
        // Get existing tags
        const { data: existingTagsData } = await supabase
          .from('phrase_tags')
          .select('tags(id, tag)')
          .eq('phrase_id', editedPhrase.id);

        const existingTags = existingTagsData?.map((pt: any) => pt.tags.tag) || [];

        // Remove tags that are no longer present
        const tagsToRemove = existingTags.filter((tag: string) => !newTags.includes(tag));
        for (const tagToRemove of tagsToRemove) {
          const { data: tagData } = await supabase
            .from('tags')
            .select('id')
            .eq('tag', tagToRemove)
            .single();

          if (tagData) {
            await supabase
              .from('phrase_tags')
              .delete()
              .eq('phrase_id', editedPhrase.id)
              .eq('tag_id', tagData.id);
          }
        }

        // Add new tags
        for (const newTag of newTags) {
          if (!existingTags.includes(newTag)) {
            let tagId: number | undefined;
            const { data: existingTag } = await supabase
              .from('tags')
              .select('id')
              .eq('tag', newTag)
              .single();

            if (existingTag) {
              tagId = existingTag.id;
            } else {
              const { data: newTagData } = await supabase
                .from('tags')
                .insert({ tag: newTag })
                .select('id')
                .single();

              if (newTagData) tagId = newTagData.id;
            }

            if (tagId) {
              await supabase
                .from('phrase_tags')
                .insert({
                  phrase_id: editedPhrase.id,
                  tag_id: tagId
                });
            }
          }
        }
      }

      await fetchPhrases();
      setHasChanges(false);
    } catch (err) {
      console.error('Error saving changes:', err);
      throw err;
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-xl bg-black border border-neutral-800 max-h-[90vh] overflow-y-auto p-6 pt-10">
        <DialogTitle className="sr-only">Review Phrases</DialogTitle>
        <DialogDescription className="sr-only">Review and approve phrases for your collection</DialogDescription>
        
        <div className="flex justify-between items-center mb-5">
          <div>
            <h2 className="text-xl font-bold text-white">Phrase Review</h2>
            <p className="text-sm text-neutral-400">Reviewer: {reviewer.name} ({reviewer.total_reviews || 0} reviews)</p>
          </div>
          
          <Select value={selectedCategory} onValueChange={handleCategorySelect}>
            <SelectTrigger className="w-[180px] bg-transparent border-neutral-700 text-white">
              <SelectValue placeholder="All Categories" />
            </SelectTrigger>
            <SelectContent className="bg-black border border-neutral-700 text-white">
              <SelectItem value="all" className="hover:bg-neutral-800">All Categories</SelectItem>
              {categories.map(category => (
                <SelectItem 
                  key={category} 
                  value={category}
                  className="hover:bg-neutral-800"
                >{category}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        
        {/* Review Hot Streak */}
        <div className="mb-5 space-y-1">
          <div className="text-sm text-neutral-400">Review Hot Streak: {streak}</div>
          <div className="h-2 bg-neutral-800 rounded-full overflow-hidden">
            <div 
              className="h-full bg-gradient-to-r from-orange-500 to-red-500 transition-all"
              style={{ width: `${(streak % 10) * 10}%` }}
            ></div>
          </div>
        </div>
        
        {/* Celebration Overlay */}
        {showCelebration && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="text-center p-8 bg-black border-2 border-orange-500 rounded-lg">
              <div className="text-4xl mb-4">ðŸŽ‰ ðŸ”¥ ðŸŽ‰</div>
              <h3 className="text-2xl font-bold text-white mb-2">Hot Streak Complete!</h3>
              <p className="text-xl text-orange-400">You reviewed 10 phrases!</p>
            </div>
          </div>
        )}
        
        {phrasesLoading ? (
          <div className="flex items-center justify-center py-12">
            <div className="animate-spin h-8 w-8 border-t-2 border-blue-500 rounded-full"></div>
          </div>
        ) : phrases.length === 0 ? (
          <div className="text-center py-8">
            <p className="text-neutral-300 mb-4">No phrases available for review.</p>
            <Button 
              onClick={onClose}
              className="bg-neutral-100 text-black hover:bg-white"
            >
              Close
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Phrase Section */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Phrase</label>
                <Button
                  onClick={handleFlag}
                  variant="ghost"
                  size="sm"
                  className={`h-7 text-xs ${isFlagged ? 'text-red-500' : 'text-neutral-400 hover:text-white'}`}
                >
                  <Flag className="h-3.5 w-3.5 mr-1" />
                  Flag for Removal
                </Button>
              </div>
              <Input
                type="text"
                value={phrases[currentIndex]?.phrase || ''}
                readOnly
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0 rounded-md"
              />
            </div>
            
            {/* Difficulty */}
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Difficulty</label>
              <Select
                value={editedPhrase.difficulty?.toString() || '1'}
                onValueChange={(value) => handleFieldChange('difficulty', parseInt(value))}
              >
                <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                  <SelectValue placeholder="Select difficulty" />
                </SelectTrigger>
                <SelectContent className="bg-black border border-neutral-700 text-white">
                  <SelectItem value="1" className="hover:bg-neutral-800">Easy</SelectItem>
                  <SelectItem value="2" className="hover:bg-neutral-800">Medium</SelectItem>
                  <SelectItem value="3" className="hover:bg-neutral-800">Hard</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            {/* Category */}
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Category</label>
              <Select
                value={editedPhrase.category || ''}
                onValueChange={(value) => handleFieldChange('category', value)}
              >
                <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                  <SelectValue placeholder="Select category" />
                </SelectTrigger>
                <SelectContent className="bg-black border border-neutral-700 text-white">
                  {categories.map(category => (
                    <SelectItem 
                      key={category} 
                      value={category}
                      className="hover:bg-neutral-800"
                    >{category}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            {/* Tags */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Tags</label>
                <Button 
                  onClick={handleGenerateTags}
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs text-neutral-400 hover:text-white"
                  disabled={isGeneratingTags}
                >
                  {isGeneratingTags ? "..." : "ðŸ¤– Ask AI"}
                </Button>
              </div>
              <div className="grid grid-cols-3 gap-2">
                {Array.from({ length: 3 }).map((_, index) => (
                  <Input
                    key={`tag-${index}`}
                    type="text"
                    value={editedPhrase.tags?.[index] || ''}
                    onChange={(e) => handleTagChange(index, e.target.value)}
                    className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                    placeholder={`Tag ${index + 1}`}
                    maxLength={16}
                  />
                ))}
              </div>
            </div>
            
            {/* Hint */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Hint</label>
                <Button 
                  onClick={handleGenerateHint}
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs text-neutral-400 hover:text-white"
                  disabled={isGeneratingHint}
                >
                  {isGeneratingHint ? "..." : "ðŸ¤– Ask AI"}
                </Button>
              </div>
              <Input
                type="text"
                value={editedPhrase.hint || ''}
                onChange={(e) => handleFieldChange('hint', e.target.value)}
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
              />
            </div>

            {/* Actions */}
            <div className="flex justify-between items-center pt-4 mt-4 border-t border-neutral-800">
                <div className="flex items-center gap-1 border border-neutral-700 rounded-md">
                  <Button
                    onClick={handlePrevious}
                    disabled={currentIndex === 0}
                    variant="ghost"
                    className="h-10 px-2 text-neutral-300 hover:bg-neutral-800 hover:text-white disabled:opacity-50 border-r border-neutral-700 rounded-r-none"
                  >
                    <ChevronLeft className="h-4 w-4" />
                  </Button>
                  <span className="px-3 text-neutral-400 text-sm">
                    {currentIndex + 1} / {phrases.length}
                  </span>
                  <Button
                    onClick={handleNext}
                    disabled={currentIndex === phrases.length - 1}
                    variant="ghost"
                    className="h-10 px-2 text-neutral-300 hover:bg-neutral-800 hover:text-white disabled:opacity-50 border-l border-neutral-700 rounded-l-none"
                  >
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                </div>
                
                <Button
                  onClick={handleApprove}
                  className={isApproved 
                    ? "bg-neutral-700 text-white hover:bg-neutral-600" 
                    : "bg-white text-black hover:bg-neutral-200"}
                  disabled={isApproving}
                >
                  {isApproving ? 'Approving...' : isApproved ? 'Approved' : 'Approve'}
                </Button>
            </div>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
};

export default ReviewModal;

============================================================

FILE: .\features\phrases\WordCreatorModal.tsx
SIZE: 19.24 KB
LAST MODIFIED: 03/19/2025 08:29:13

'use client';

import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Loader2 } from 'lucide-react';
import { supabase } from '@/lib/services/supabase';
import { generateTags, generateHint, generatePhrases, suggestCategory } from '@/lib/services/claudeService';
import type { Reviewer } from '@/types/types';

interface WordCreatorModalProps {
  isOpen: boolean;
  onClose: () => void;
  reviewer: Reviewer;
  onWordAdded?: () => void;
}

interface NewWord {
  phrase: string;
  category: string;
  difficulty: number;
  hint?: string;
  tags: string[];
}

const WordCreatorModal: React.FC<WordCreatorModalProps> = ({
  isOpen,
  onClose,
  reviewer,
  onWordAdded
}) => {
  const [categories, setCategories] = useState<string[]>([]);
  const [inspiration, setInspiration] = useState('');
  const [newWord, setNewWord] = useState<NewWord>({
    phrase: '',
    category: '',
    difficulty: 1,
    hint: '',
    tags: ['', '', '']
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingTags, setIsGeneratingTags] = useState(false);
  const [isGeneratingHint, setIsGeneratingHint] = useState(false);
  const [isGeneratingCategory, setIsGeneratingCategory] = useState(false);
  const [generatedWords, setGeneratedWords] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [wordGenerated, setWordGenerated] = useState(false);

  // Fetch categories on load
  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const { data, error } = await supabase
          .from('categories')
          .select('name')
          .order('name');
        
        if (error) throw error;
        if (data) setCategories(data.map(c => c.name));
      } catch (err) {
        console.error('Error fetching categories:', err);
        setError('Failed to load categories');
      }
    };

    fetchCategories();
  }, []);

  // Reset form when modal opens
  useEffect(() => {
    if (isOpen) {
      setInspiration('');
      setNewWord({
        phrase: '',
        category: '',
        difficulty: 1,
        hint: '',
        tags: ['', '', '']
      });
      setError(null);
      setSuccess(null);
      setWordGenerated(false);
      setGeneratedWords([]);
    }
  }, [isOpen]);

  const handleChange = (field: keyof NewWord, value: string | number | string[]) => {
    setNewWord(prev => ({ ...prev, [field]: value }));
    setError(null);
  };

  const handleTagChange = (index: number, value: string) => {
    const newTags = [...newWord.tags];
    newTags[index] = value.trim().replace(/\s+/g, '');
    handleChange('tags', newTags);
  };

  const handleGenerateTags = async () => {
    if (!newWord.phrase) {
      setError('Please generate a phrase first');
      return;
    }

    setIsGeneratingTags(true);
    try {
      const result = await generateTags(newWord.phrase);
      if (result.tags.length > 0) {
        const aiTags = result.tags.slice(0, 3);
        const newTags = [...aiTags, ...Array(3 - aiTags.length).fill('')];
        handleChange('tags', newTags);
      }
    } catch (error) {
      console.error('Error generating tags:', error);
      setError('Failed to generate tags');
    } finally {
      setIsGeneratingTags(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!newWord.phrase) {
      setError('Please generate a phrase first');
      return;
    }

    setIsGeneratingHint(true);
    try {
      const result = await generateHint(newWord.phrase);
      if (result.hint) {
        handleChange('hint', result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
      setError('Failed to generate hint');
    } finally {
      setIsGeneratingHint(false);
    }
  };

  const handleGenerateWords = async () => {
    if (!inspiration) {
      setError('Please enter some inspiration first');
      return;
    }

    setIsGenerating(true);
    setError(null);
    
    try {
      // Use the real Claude API to generate phrases
      const result = await generatePhrases(inspiration, 5);
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      if (result.phrases.length > 0) {
        setGeneratedWords(result.phrases);
        
        // Select the first generated word
        const firstPhrase = result.phrases[0];
        
        // Generate tags and hint for the selected phrase
        setIsGeneratingTags(true);
        setIsGeneratingHint(true);
        
        try {
          const [tagsResult, hintResult] = await Promise.all([
            generateTags(firstPhrase),
            generateHint(firstPhrase)
          ]);
          
          setNewWord(prev => ({
            ...prev,
            phrase: firstPhrase,
            hint: hintResult.hint || '',
            tags: tagsResult.tags.slice(0, 3)
          }));
        } catch (error) {
          console.error('Error generating tags/hint:', error);
          // Fallback values if API calls fail
          setNewWord(prev => ({
            ...prev,
            phrase: firstPhrase,
            hint: `Information about ${inspiration}`,
            tags: [`${inspiration}`, 'new', 'word']
          }));
        } finally {
          setIsGeneratingTags(false);
          setIsGeneratingHint(false);
        }
        
        setWordGenerated(true);
      } else {
        setError('No phrases were generated. Please try again with different inspiration.');
      }
    } catch (error) {
      console.error('Error generating phrases:', error);
      setError('Failed to generate phrases. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSelectWord = async (phrase: string) => {
    // Update the word with the selected phrase
    setNewWord(prev => ({
      ...prev,
      phrase
    }));
    
    // Set loading states
    setIsGeneratingTags(true);
    setIsGeneratingHint(true);
    setIsGeneratingCategory(true);
    
    try {
      // Generate tags, hint and category for the selected phrase using Claude
      const [tagsResult, hintResult, categoryResult] = await Promise.all([
        generateTags(phrase),
        generateHint(phrase),
        suggestCategory(phrase, categories)
      ]);
      
      setNewWord(prev => ({
        ...prev,
        hint: hintResult.hint || '',
        tags: tagsResult.tags.slice(0, 3),
        category: categoryResult.category || prev.category
      }));
    } catch (error) {
      console.error('Error generating phrase metadata:', error);
      // Fallback values if API calls fail
      const words = phrase.split(/\s+/);
      setNewWord(prev => ({
        ...prev,
        hint: `About ${words[0]?.toLowerCase() || phrase}`,
        tags: [
          words[0]?.toLowerCase() || 'general',
          phrase.length > 6 ? 'complex' : 'simple',
          words.length > 1 ? 'multi' : 'single'
        ]
      }));
    } finally {
      // Reset loading states
      setIsGeneratingTags(false);
      setIsGeneratingHint(false);
      setIsGeneratingCategory(false);
      
      // Set word as generated
      setWordGenerated(true);
    }
  };

  const handleSubmit = async () => {
    // Validate form
    if (!newWord.phrase) {
      setError('Please enter or generate a phrase');
      return;
    }
    if (!newWord.category) {
      setError('Please select a category');
      return;
    }

    setIsSubmitting(true);
    setError(null);
    
    try {
      // Get category ID
      const { data: categoryData } = await supabase
        .from('categories')
        .select('id')
        .eq('name', newWord.category)
        .single();
      
      if (!categoryData) {
        throw new Error('Category not found');
      }
      
      // Insert phrase
      const { data: phraseData, error: phraseError } = await supabase
        .from('phrases')
        .insert({
          phrase: newWord.phrase,
          category_id: categoryData.id,
          subcategory_id: null, // No subcategory
          difficulty: newWord.difficulty,
          hint: newWord.hint || null,
          created_by: reviewer.id,
          created_at: new Date().toISOString()
        })
        .select('id')
        .single();
      
      if (phraseError) throw phraseError;
      
      // Process tags
      const validTags = newWord.tags.filter(Boolean);
      for (const tag of validTags) {
        // Check if tag exists
        const { data: existingTag } = await supabase
          .from('tags')
          .select('id')
          .eq('tag', tag)
          .single();
          
        let tagId;
        if (existingTag) {
          tagId = existingTag.id;
        } else {
          // Create new tag
          const { data: newTag } = await supabase
            .from('tags')
            .insert({ tag })
            .select('id')
            .single();
            
          if (newTag) tagId = newTag.id;
        }
        
        // Link tag to phrase
        if (tagId && phraseData) {
          await supabase
            .from('phrase_tags')
            .insert({
              phrase_id: phraseData.id,
              tag_id: tagId
            });
        }
      }
      
      // Update reviewer stats
      await supabase
        .from('reviewers')
        .update({
          total_reviews: reviewer.total_reviews + 1,
          last_review_at: new Date().toISOString()
        })
        .eq('id', reviewer.id);
      
      setSuccess('Word added successfully');
      
      // Reset form but keep inspiration
      setTimeout(() => {
        setNewWord({
          phrase: '',
          category: '',
          difficulty: 1,
          hint: '',
          tags: ['', '', '']
        });
        setSuccess(null);
        setWordGenerated(false);
        
        if (onWordAdded) {
          onWordAdded();
        }
      }, 1500);
      
    } catch (err) {
      console.error('Error adding word:', err);
      setError('Failed to add word');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-xl bg-black border border-neutral-800 max-h-[90vh] overflow-y-auto p-6 pt-10">
        <DialogTitle className="sr-only">Word Creator</DialogTitle>
        <DialogDescription className="sr-only">Create new phrases for your collection</DialogDescription>
        
        <div className="mb-6">
          <h2 className="text-xl font-bold text-white">Word Creator</h2>
          <p className="text-sm text-neutral-400">Reviewer: {reviewer.name}</p>
        </div>
        
        {error && (
          <div className="mb-4 p-3 rounded bg-red-900/30 border border-red-700 text-red-300 text-sm">
            {error}
          </div>
        )}
        
        {success && (
          <div className="mb-4 p-3 rounded bg-green-900/30 border border-green-700 text-green-300 text-sm">
            {success}
          </div>
        )}
        
        <div className="space-y-4">
          {/* Inspiration Field */}
          <div>
            <label className="block text-sm text-neutral-400 mb-2">Provide Inspiration</label>
            <div className="flex gap-2">
              <Input
                value={inspiration}
                onChange={(e) => setInspiration(e.target.value)}
                placeholder="Enter a theme, topic, or concept"
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
              />
              <Button
                onClick={handleGenerateWords}
                disabled={isGenerating || !inspiration}
                className="bg-white text-black hover:bg-neutral-200 whitespace-nowrap"
              >
                {isGenerating ? (
                  <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Generating...</>
                ) : (
                  <>ðŸ¤– Generate Phrase</>
                )}
              </Button>
            </div>
          </div>
          
          {/* Generated Words List (shown after generation) */}
          {generatedWords.length > 0 && (
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Select a Phrase</label>
              <div className="grid grid-cols-1 gap-2 mb-4">
                {generatedWords.map((phrase, index) => (
                  <Button
                    key={index}
                    variant="outline"
                    className={`justify-start text-left p-3 border-neutral-700 ${newWord.phrase === phrase ? 'bg-neutral-800 border-blue-500' : 'bg-transparent hover:bg-neutral-800'}`}
                    onClick={() => handleSelectWord(phrase)}
                  >
                    {phrase}
                  </Button>
                ))}
              </div>
            </div>
          )}
          
          {/* Phrase Field */}
          {wordGenerated && (
            <>
              <div>
                <label className="block text-sm text-neutral-400 mb-2">Phrase</label>
                <Input
                  value={newWord.phrase}
                  onChange={(e) => handleChange('phrase', e.target.value)}
                  className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              </div>
              
              {/* Difficulty */}
              <div>
                <label className="block text-sm text-neutral-400 mb-2">Difficulty</label>
                <Select
                  value={newWord.difficulty.toString()}
                  onValueChange={(value) => handleChange('difficulty', parseInt(value))}
                >
                  <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                    <SelectValue placeholder="Select difficulty" />
                  </SelectTrigger>
                  <SelectContent className="bg-black border border-neutral-700 text-white">
                    <SelectItem value="1" className="hover:bg-neutral-800">Easy</SelectItem>
                    <SelectItem value="2" className="hover:bg-neutral-800">Medium</SelectItem>
                    <SelectItem value="3" className="hover:bg-neutral-800">Hard</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              {/* Category */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Category</label>
                  {isGeneratingCategory && (
                    <span className="text-xs text-neutral-400">
                      <Loader2 className="inline h-3 w-3 animate-spin mr-1" /> 
                      AI selecting...
                    </span>
                  )}
                </div>
                <Select
                  value={newWord.category}
                  onValueChange={(value) => handleChange('category', value)}
                >
                  <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                    <SelectValue placeholder="Select category" />
                  </SelectTrigger>
                  <SelectContent className="bg-black border border-neutral-700 text-white">
                    {categories.map(category => (
                      <SelectItem 
                        key={category} 
                        value={category}
                        className="hover:bg-neutral-800"
                      >{category}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {newWord.category && (
                  <p className="text-xs text-neutral-400 mt-1">
                    Category selected by AI based on the phrase content
                  </p>
                )}
              </div>
              
              {/* Tags */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Tags</label>
                  <Button 
                    onClick={handleGenerateTags}
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs text-neutral-400 hover:text-white"
                    disabled={isGeneratingTags || !newWord.phrase}
                  >
                    {isGeneratingTags ? "..." : "ðŸ¤– Ask AI"}
                  </Button>
                </div>
                <div className="grid grid-cols-3 gap-2">
                  {Array.from({ length: 3 }).map((_, index) => (
                    <Input
                      key={`tag-${index}`}
                      type="text"
                      value={newWord.tags[index] || ''}
                      onChange={(e) => handleTagChange(index, e.target.value)}
                      className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                      placeholder={`Tag ${index + 1}`}
                      maxLength={16}
                    />
                  ))}
                </div>
              </div>
              
              {/* Hint */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Hint</label>
                  <Button 
                    onClick={handleGenerateHint}
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs text-neutral-400 hover:text-white"
                    disabled={isGeneratingHint || !newWord.phrase}
                  >
                    {isGeneratingHint ? "..." : "ðŸ¤– Ask AI"}
                  </Button>
                </div>
                <Input
                  type="text"
                  value={newWord.hint || ''}
                  onChange={(e) => handleChange('hint', e.target.value)}
                  className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              </div>
              
              {/* Submit Button */}
              <div className="flex justify-end pt-4 mt-4 border-t border-neutral-800">
                <Button
                  onClick={handleSubmit}
                  disabled={isSubmitting || !newWord.phrase || !newWord.category}
                  className="bg-white text-black hover:bg-neutral-200"
                >
                  {isSubmitting ? (
                    <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Adding...</>
                  ) : (
                    'Add Word'
                  )}
                </Button>
              </div>
            </>
          )}
          
          {!wordGenerated && !isGenerating && generatedWords.length === 0 && (
            <div className="flex flex-col items-center justify-center py-12 text-neutral-400">
              <p className="mb-2">Enter some inspiration and click Generate</p>
              <p className="text-sm">Example: "medical terms", "sports activities", "cooking verbs"</p>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default WordCreatorModal;

============================================================

FILE: .\features\phrases\components\PhrasesList\index.ts
SIZE: 0.15 KB
LAST MODIFIED: 03/20/2025 22:38:17

// src/features/phrases/components/PhrasesList/index.ts
export * from './PhrasesList';
export * from './PhrasesListContainer';
export * from './types';

============================================================

FILE: .\features\phrases\components\PhrasesList\PhrasesList.tsx
SIZE: 5.68 KB
LAST MODIFIED: 03/20/2025 22:54:01

// In PhrasesList.tsx, update the difficulty rendering section
import React from 'react';
import { Button } from '@/components/ui/button';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';
import { Checkbox } from '@/components/ui/checkbox';
import TagDisplay from '@/components/ui/tags';
import { Pencil, Trash, MoreHorizontal } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { PhraseListProps } from './types';
import { getDifficultyBar } from '../../utils/formatting'; 
import { cn } from '@/lib/utils';

export function PhrasesList({
  phrases,
  loading,
  selectedRows,
  hiddenColumns,
  onSelectRow,
  onSelectAll,
  onEdit,
  onDelete,
  newIds = []
}: PhraseListProps) {
  if (loading) {
    return (
      <TableRow>
        <TableCell colSpan={8} className="h-24 text-center">
          Loading...
        </TableCell>
      </TableRow>
    );
  }

  if (phrases.length === 0) {
    return (
      <TableRow>
        <TableCell colSpan={8} className="h-24 text-center">
          No phrases found.
        </TableCell>
      </TableRow>
    );
  }

  return (
    <Table>
      <TableHeader>
        <TableRow>
          {/* Checkbox column */}
          <TableHead className="w-12">
            <Checkbox
              checked={selectedRows.length > 0 && selectedRows.length === phrases.length}
              indeterminate={selectedRows.length > 0 && selectedRows.length < phrases.length ? true : undefined}
              onCheckedChange={onSelectAll}
            />
          </TableHead>
          
          {/* Phrase column */}
          {!hiddenColumns.includes('phrase') && (
            <TableHead>Phrase</TableHead>
          )}
          
          {/* Category column */}
          {!hiddenColumns.includes('category') && (
            <TableHead>Category</TableHead>
          )}
          
          {/* Hint column */}
          {!hiddenColumns.includes('hint') && (
            <TableHead>Hint</TableHead>
          )}
          
          {/* Tags column */}
          {!hiddenColumns.includes('tags') && (
            <TableHead>Tags</TableHead>
          )}
          
          {/* Difficulty column */}
          {!hiddenColumns.includes('difficulty') && (
            <TableHead>Difficulty</TableHead>
          )}
          
          {/* Actions column */}
          <TableHead className="w-[80px]">
            Actions
          </TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {phrases.map((phrase) => (
          <TableRow 
            key={phrase.id}
            className={cn(
              selectedRows.includes(phrase.id) && "bg-muted",
              newIds.includes(phrase.id) && "animate-flash"
            )}
          >
            {/* Checkbox */}
            <TableCell className="w-12">
              <Checkbox
                checked={selectedRows.includes(phrase.id)}
                onCheckedChange={() => onSelectRow(phrase.id)}
              />
            </TableCell>
            
            {/* Phrase */}
            {!hiddenColumns.includes('phrase') && (
              <TableCell className="font-medium">{phrase.phrase}</TableCell>
            )}
            
            {/* Category */}
            {!hiddenColumns.includes('category') && (
              <TableCell>{phrase.category}</TableCell>
            )}
            
            {/* Hint */}
            {!hiddenColumns.includes('hint') && (
              <TableCell>{phrase.hint || '-'}</TableCell>
            )}
            
            {/* Tags */}
            {!hiddenColumns.includes('tags') && (
              <TableCell>
                <TagDisplay tags={phrase.tags || ''} />
              </TableCell>
            )}
            
            {/* Difficulty - use the utility function */}
            {!hiddenColumns.includes('difficulty') && (
              <TableCell>
                {/* Use the returned CSS classes */}
                <div className={getDifficultyBar(phrase.difficulty).containerClass}>
                  <div className={getDifficultyBar(phrase.difficulty).barClass}></div>
                </div>
              </TableCell>
            )}
            
            {/* Actions */}
            <TableCell>
              <div className="flex justify-end">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" className="h-8 w-8 p-0">
                      <span className="sr-only">Open menu</span>
                      <MoreHorizontal className="h-4 w-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuLabel>Actions</DropdownMenuLabel>
                    <DropdownMenuItem onClick={() => onEdit(phrase.id)}>
                      <Pencil className="h-4 w-4 mr-2" />
                      Edit
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem 
                      onClick={() => onDelete(phrase.id)}
                      className="text-red-600"
                    >
                      <Trash className="h-4 w-4 mr-2" />
                      Delete
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}

============================================================

FILE: .\features\phrases\components\PhrasesList\PhrasesListContainer.tsx
SIZE: 2.82 KB
LAST MODIFIED: 03/21/2025 09:11:45

// features/phrases/components/PhrasesList/PhrasesListContainer.tsx
import React, { useState } from 'react';
import { usePhrases } from '../../hooks/usePhrases';
import { useDeletePhrase } from '../../hooks/useDeletePhrase';
import { PhrasesList } from './PhrasesList';
import { Pagination } from '@/components/ui/pagination';
import { useFilter } from '../../stores/filterContext';
import { useRouter } from 'next/navigation';
import { getDifficultyBar } from '../../utils/formatting';

export function PhrasesListContainer() {
  const router = useRouter();
  const [selectedRows, setSelectedRows] = useState<number[]>([]);
  const [hiddenColumns, setHiddenColumns] = useState<string[]>([]);
  
  // Use the filter context
  const { 
    searchTerm, 
    category, 
    difficulty, 
    subcategory, 
    part_of_speech, 
    page, 
    pageSize, 
    sortBy, 
    sortDirection,
    setFilter, 
    resetFilters 
  } = useFilter();

  // Compile all filters for the query
  const filters = {
    searchTerm,
    category,
    difficulty,
    subcategory,
    part_of_speech
  };
  
  // Use the data fetching hook
  const { data, isLoading, error } = usePhrases(
    filters,
    { page, pageSize },
    { column: sortBy, direction: sortDirection }
  );
  
  // Use the delete hook
  const deletePhraseHook = useDeletePhrase();
  
  const handleSelectRow = (id: number) => {
    setSelectedRows(prev =>
      prev.includes(id)
        ? prev.filter(rowId => rowId !== id)
        : [...prev, id]
    );
  };
  
  const handleSelectAll = () => {
    if (selectedRows.length === data?.data?.length) {
      setSelectedRows([]);
    } else {
      setSelectedRows(data?.data?.map(phrase => phrase.id) || []);
    }
  };
  
  const handleEdit = (id: number) => {
    router.push(`/admin/phrases/edit/${id}`);
  };
  
  const handleDelete = (id: number) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      deletePhraseHook.mutate(id, {
        onSuccess: () => {
          setSelectedRows(prev => prev.filter(rowId => rowId !== id));
        }
      });
    }
  };
  
  const handlePageChange = (page: number) => {
    setFilter('page', page);
  };
  
  return (
    <div className="space-y-4">
      <div>
        <PhrasesList
          phrases={data?.data || []}
          loading={isLoading}
          selectedRows={selectedRows}
          hiddenColumns={hiddenColumns}
          onSelectRow={handleSelectRow}
          onSelectAll={handleSelectAll}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      </div>
      
      {data?.totalPages > 1 && (
        <Pagination
          currentPage={page}
          totalPages={data.totalPages}
          onPageChange={handlePageChange}
        />
      )}
    </div>
  );
}

============================================================

FILE: .\features\phrases\components\PhrasesList\types.ts
SIZE: 0.38 KB
LAST MODIFIED: 03/20/2025 22:38:04

// src/features/phrases/components/PhrasesList/types.ts
import { Phrase } from '@/types';

export interface PhraseListProps {
  phrases: Phrase[];
  loading: boolean;
  selectedRows: number[];
  hiddenColumns: string[];
  onSelectRow: (id: number) => void;
  onSelectAll: () => void;
  onEdit: (id: number) => void;
  onDelete: (id: number) => void;
  newIds?: number[];
}

============================================================

FILE: .\features\phrases\hooks\useDeletePhrase.ts
SIZE: 0.97 KB
LAST MODIFIED: 03/21/2025 09:26:33

// features/phrases/hooks/useDeletePhrase.ts
import { useState } from 'react';
import { supabase } from '@/lib/services/supabase';

export const useDeletePhrase = () => {
  const [isDeleting, setIsDeleting] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const mutate = async (id: number, options?: { onSuccess?: () => void }) => {
    setIsDeleting(true);
    setError(null);
    
    try {
      const { error: deleteError } = await supabase
        .from('phrases')
        .delete()
        .eq('id', id);
        
      if (deleteError) {
        throw deleteError;
      }
      
      if (options?.onSuccess) {
        options.onSuccess();
      }
    } catch (err) {
      console.error('Error deleting phrase:', err);
      setError(err instanceof Error ? err : new Error('An unknown error occurred'));
    } finally {
      setIsDeleting(false);
    }
  };
  
  return {
    mutate,
    isDeleting,
    error
  };
};

============================================================

FILE: .\features\phrases\hooks\usePhrases.ts
SIZE: 3.9 KB
LAST MODIFIED: 03/21/2025 09:26:41

// features/phrases/hooks/usePhrases.ts
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';

export const usePhrases = (
  filters = {},
  pagination = { page: 1, pageSize: 10 },
  sort = { column: 'id', direction: 'desc' as const }
) => {
  const [data, setData] = useState<{ 
    data: any[], 
    totalItems: number, 
    totalPages: number 
  }>({ data: [], totalItems: 0, totalPages: 1 });
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchPhrases = async () => {
      setIsLoading(true);
      setError(null);
      
      try {
        // Start building the query
        let query = supabase
          .from('phrases')
          .select(`
            *,
            categories:category_id(id, name),
            subcategories:subcategory_id(id, name),
            phrase_tags(
              tags(id, tag)
            )
          `, { count: 'exact' });

        // Apply filters
        if (filters.searchTerm) {
          query = query.ilike('phrase', `%${filters.searchTerm}%`);
        }
        
        if (filters.category) {
          // First get the category id
          const { data: categoryData } = await supabase
            .from('categories')
            .select('id')
            .eq('name', filters.category)
            .single();
            
          if (categoryData?.id) {
            query = query.eq('category_id', categoryData.id);
          }
        }
        
        if (filters.difficulty) {
          query = query.eq('difficulty', filters.difficulty);
        }
        
        if (filters.part_of_speech) {
          query = query.eq('part_of_speech', filters.part_of_speech);
        }
        
        if (filters.subcategory) {
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('id')
            .eq('name', filters.subcategory)
            .single();
            
          if (subcategoryData?.id) {
            query = query.eq('subcategory_id', subcategoryData.id);
          }
        }

        // Apply sorting
        query = query.order(sort.column, { 
          ascending: sort.direction === 'asc' 
        });

        // Apply pagination
        const from = (pagination.page - 1) * pagination.pageSize;
        const to = from + pagination.pageSize - 1;
        query = query.range(from, to);

        // Execute the query
        const { data: phraseData, error: queryError, count } = await query;

        if (queryError) {
          throw queryError;
        }

        // Transform the data
        const transformedData = phraseData?.map(item => ({
          id: item.id,
          phrase: item.phrase || '',
          category: item.categories?.name || '',
          subcategory: item.subcategories?.name || '',
          difficulty: item.difficulty || 1,
          part_of_speech: item.part_of_speech || '',
          hint: item.hint || '',
          tags: item.phrase_tags
            ?.map((pt: any) => pt.tags.tag)
            .filter(Boolean)
            .join(',') || ''
        })) || [];

        setData({
          data: transformedData,
          totalItems: count || 0,
          totalPages: Math.ceil((count || 0) / pagination.pageSize)
        });
      } catch (err) {
        console.error('Error fetching phrases:', err);
        setError(err instanceof Error ? err : new Error('An unknown error occurred'));
      } finally {
        setIsLoading(false);
      }
    };

    fetchPhrases();
  }, [
    filters.searchTerm,
    filters.category,
    filters.difficulty,
    filters.subcategory,
    filters.part_of_speech,
    pagination.page,
    pagination.pageSize,
    sort.column,
    sort.direction
  ]);

  return {
    data,
    isLoading,
    error
  };
};

============================================================

FILE: .\features\phrases\phrasesTable\index.tsx
SIZE: 17.44 KB
LAST MODIFIED: 03/20/2025 22:09:51

import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import { Search, Columns, Pencil, Trash, ChevronLeft, ChevronRight, MoreHorizontal, X } from 'lucide-react';
import { TableState } from '@/components/tables/types';
import TagDisplay from '@/components/ui/tags';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuCheckboxItem,
} from "@/components/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Check } from 'lucide-react';
import { cn } from '@/lib/utils';
import { supabase } from '@/lib/services/supabase';

interface PhrasesTableProps {
  phrases: any[];
  loading?: boolean;
  tableState: TableState;
  onTableStateChange: (updates: Partial<TableState>) => void;
  onEdit?: (id: number) => void;
  onDelete?: (id: number) => void;
  newIds?: number[];
  onShowFilters?: () => void;
}

export function PhrasesTable({
  phrases,
  loading = false,
  tableState,
  onTableStateChange,
  onEdit,
  onDelete,
  newIds = [],
  onShowFilters
}: PhrasesTableProps) {
  const [selectedRows, setSelectedRows] = useState<number[]>([]);
  const [searchValue, setSearchValue] = useState(tableState.filters.search || '');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  // Columns configuration for dropdown
  const columns = [
    { key: 'phrase', label: 'Phrase' },
    { key: 'category', label: 'Category' },
    { key: 'hint', label: 'Hint' }, // Moved hint to be after category
    { key: 'tags', label: 'Tags' },
    { key: 'difficulty', label: 'Difficulty' },
    { key: 'reviewed', label: 'Reviewed' }
  ];

  // Current visible columns
  const [hiddenColumns, setHiddenColumns] = useState<string[]>([]);

  // Handle search input changes
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchValue(e.target.value);
  };

  // Global search across the entire database - Only search phrase column
  const performGlobalSearch = async () => {
    if (!searchValue.trim()) {
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: ''
        }
      });
      return;
    }

    setIsSearching(true);
    try {
      const searchTerm = searchValue.toLowerCase().trim();
      
      // Search only the phrase column
      const { data, error } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(name),
          subcategories:subcategory_id(name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `)
        .ilike('phrase', `%${searchTerm}%`); // Only search in phrase column

      if (error) throw error;

      const transformedData = (data || []).map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      // Update search results and pagination
      setSearchResults(transformedData);
      
      // Update filter state
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: searchValue
        },
        pagination: {
          ...tableState.pagination,
          currentPage: 1,
          totalItems: transformedData.length,
          totalPages: Math.ceil(transformedData.length / tableState.pagination.rowsPerPage)
        }
      });
    } catch (err) {
      console.error('Error searching phrases:', err);
    } finally {
      setIsSearching(false);
    }
  };

  // Handle enter key
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      performGlobalSearch();
    }
  };

  // Clear search
  const clearSearch = () => {
    setSearchValue('');
    setSearchResults([]);
    onTableStateChange({
      filters: {
        ...tableState.filters,
        search: ''
      }
    });
  };

  const handleRowsPerPageChange = (value: string) => {
    const newRowsPerPage = parseInt(value, 10);
    
    // Call the parent component's handler
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        rowsPerPage: newRowsPerPage,
        currentPage: 1  // Reset to page 1 when changing rows per page
      }
    });
  };

  const handlePageChange = (newPage: number) => {
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        currentPage: newPage
      }
    });
  };

  const handleSort = (key: string) => {
    onTableStateChange({
      sortConfig: {
        key,
        direction: 
          tableState.sortConfig.key === key && 
          tableState.sortConfig.direction === 'asc' ? 'desc' : 'asc'
      }
    });
  };

  const toggleSelectAll = () => {
    if (selectedRows.length === phrases.length) {
      setSelectedRows([]);
    } else {
      setSelectedRows(phrases.map(phrase => phrase.id));
    }
  };

  const toggleRowSelection = (id: number) => {
    if (selectedRows.includes(id)) {
      setSelectedRows(prev => prev.filter(rowId => rowId !== id));
    } else {
      setSelectedRows(prev => [...prev, id]);
    }
  };

  const handleBulkDelete = async () => {
    if (selectedRows.length > 0 && window.confirm(`Are you sure you want to delete ${selectedRows.length} phrases?`)) {
      for (const id of selectedRows) {
        await onDelete?.(id);
      }
      setSelectedRows([]);
    }
  };

  // Helper function to get difficulty bar color and width
  const getDifficultyBar = (difficulty: number) => {
    const colorClass = 
      difficulty === 1 ? 'bg-gray-200' : 
      difficulty === 2 ? 'bg-gray-200' : 
      difficulty === 3 ? 'bg-gray-200' : 'bg-gray-200';
    
    const width = 
      difficulty === 1 ? 'w-1/3' : 
      difficulty === 2 ? 'w-2/3' : 
      difficulty === 3 ? 'w-full' : 'w-0';
    
    return (
      <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-600">
        <div className={`${colorClass} ${width} h-2.5 rounded-full`}></div>
      </div>
    );
  };

  // Determine which data to show
  const displayData = searchValue && searchResults.length > 0 ? searchResults : phrases;


  return (
    <div className="space-y-2">
      {/* Top toolbar with pagination and search */}
      <div className="flex flex-wrap items-center justify-between pb-4">
        <div className="flex items-center gap-4">
          {/* Rows per page dropdown */}
          <Select
  value={tableState.pagination.rowsPerPage.toString()}
  onValueChange={handleRowsPerPageChange}
>
  <SelectTrigger className="w-[120px]">
    <SelectValue placeholder={`${tableState.pagination.rowsPerPage} per page`} />
  </SelectTrigger>
  <SelectContent>
    {[10, 25, 50, 100].map(value => (  // Removed 20 from here
      <SelectItem key={value} value={value.toString()}>
        {value} per page
      </SelectItem>
    ))}
  </SelectContent>
</Select>
          
          {/* Page info */}
          <span className="text-sm text-muted-foreground">
            {tableState.pagination.totalPages > 0
              ? `Page ${tableState.pagination.currentPage} of ${tableState.pagination.totalPages}`
              : 'No results'}
          </span>
        </div>

        <div className="flex items-center gap-2">
          {/* Search input */}
          <div className="relative w-full md:w-64">
            <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
              <Search className="h-4 w-4 text-muted-foreground" />
            </div>
            <Input
              placeholder="Search phrases..."
              value={searchValue}
              onChange={handleSearchChange}
              onKeyDown={handleKeyDown}
              onBlur={performGlobalSearch}
              className="pl-10 pr-10"
            />
            {searchValue && (
              <button
                onClick={clearSearch}
                className="absolute inset-y-0 right-0 flex items-center pr-3 text-muted-foreground hover:text-foreground"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
          
          {/* Column visibility */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-9">
                <Columns className="mr-2 h-4 w-4" />
                Columns
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {columns.map((column) => (
                <DropdownMenuCheckboxItem
                  key={column.key}
                  checked={!hiddenColumns.includes(column.key)}
                  onCheckedChange={(checked) => {
                    setHiddenColumns(prev => 
                      checked 
                        ? prev.filter(key => key !== column.key)
                        : [...prev, column.key]
                    );
                  }}
                >
                  {column.label}
                </DropdownMenuCheckboxItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
          
          {/* Pagination buttons */}
          <Button
  variant="outline"
  size="sm"
  onClick={() => handlePageChange(tableState.pagination.currentPage - 1)}
  disabled={tableState.pagination.currentPage <= 1}
>
  <ChevronLeft className="h-4 w-4" />
</Button>
<Button
  variant="outline"
  size="sm"
  onClick={() => handlePageChange(tableState.pagination.currentPage + 1)}
  disabled={tableState.pagination.currentPage >= tableState.pagination.totalPages}
>
  <ChevronRight className="h-4 w-4" />
</Button>
        </div>
      </div>

      {/* Main table */}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              {/* Checkbox column */}
              <TableHead className="w-12">
                <Checkbox
                  checked={selectedRows.length > 0 && selectedRows.length === displayData.length}
                  indeterminate={selectedRows.length > 0 && selectedRows.length < displayData.length ? true : undefined}
  onCheckedChange={toggleSelectAll}
                />
              </TableHead>
              
              {/* Phrase column */}
              {!hiddenColumns.includes('phrase') && (
                <TableHead onClick={() => handleSort('phrase')} className="cursor-pointer">
                  Phrase
                </TableHead>
              )}
              
              {/* Category column */}
              {!hiddenColumns.includes('category') && (
                <TableHead onClick={() => handleSort('category')} className="cursor-pointer">
                  Category
                </TableHead>
              )}
              
              {/* Hint column - Moved here */}
              {!hiddenColumns.includes('hint') && (
                <TableHead onClick={() => handleSort('hint')} className="cursor-pointer">
                  Hint
                </TableHead>
              )}
              
              {/* Tags column */}
              {!hiddenColumns.includes('tags') && (
                <TableHead onClick={() => handleSort('tags')} className="cursor-pointer">
                  Tags
                </TableHead>
              )}
              
              {/* Difficulty column */}
              {!hiddenColumns.includes('difficulty') && (
                <TableHead onClick={() => handleSort('difficulty')} className="cursor-pointer">
                  Difficulty
                </TableHead>
              )}
              
              {/* Reviewed column */}
              {!hiddenColumns.includes('reviewed') && (
                <TableHead>Reviewed</TableHead>
              )}
              
              {/* Actions column */}
              <TableHead className="w-[80px]">
                {selectedRows.length > 0 ? (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={handleBulkDelete}
                    className="h-8"
                  >
                    <Trash className="h-4 w-4 mr-2" />
                    Delete
                  </Button>
                ) : null}
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading || isSearching ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  {isSearching ? 'Searching...' : 'Loading...'}
                </TableCell>
              </TableRow>
            ) : displayData.length === 0 ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  No phrases found.
                </TableCell>
              </TableRow>
            ) : (
              displayData.map((phrase) => (
                <TableRow 
                  key={phrase.id}
                  className={cn(
                    selectedRows.includes(phrase.id) && "bg-muted",
                    newIds.includes(phrase.id) && "animate-flash"
                  )}
                >
                  {/* Checkbox */}
                  <TableCell className="w-12">
                    <Checkbox
                      checked={selectedRows.includes(phrase.id)}
                      onCheckedChange={() => toggleRowSelection(phrase.id)}
                    />
                  </TableCell>
                  
                  {/* Phrase */}
                  {!hiddenColumns.includes('phrase') && (
                    <TableCell className="font-medium">{phrase.phrase}</TableCell>
                  )}
                  
                  {/* Category */}
                  {!hiddenColumns.includes('category') && (
                    <TableCell>{phrase.category}</TableCell>
                  )}
                  
                  {/* Hint - Moved here */}
                  {!hiddenColumns.includes('hint') && (
                    <TableCell>{phrase.hint || '-'}</TableCell>
                  )}
                  
                  {/* Tags */}
                  {!hiddenColumns.includes('tags') && (
                    <TableCell>
                      <TagDisplay tags={phrase.tags || ''} />
                    </TableCell>
                  )}
                  
                  {/* Difficulty - Bar Style */}
                  {!hiddenColumns.includes('difficulty') && (
                    <TableCell>
                      {getDifficultyBar(phrase.difficulty)}
                    </TableCell>
                  )}
                  
                  {/* Reviewed Status */}
                  {!hiddenColumns.includes('reviewed') && (
                    <TableCell>
                      <div className="flex justify-center">
                        {phrase.reviewed ? (
                          <Check className="h-5 w-5 text-green-500" />
                        ) : (
                          <Check className="h-5 w-5 text-gray-300" />
                        )}
                      </div>
                    </TableCell>
                  )}
                  
                  {/* Actions */}
                  <TableCell>
                    <div className="flex justify-end">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" className="h-8 w-8 p-0">
                            <span className="sr-only">Open menu</span>
                            <MoreHorizontal className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuLabel>Actions</DropdownMenuLabel>
                          <DropdownMenuItem onClick={() => onEdit?.(phrase.id)}>
                            <Pencil className="h-4 w-4 mr-2" />
                            Edit
                          </DropdownMenuItem>
                          <DropdownMenuSeparator />
                          <DropdownMenuItem 
                            onClick={() => {
                              if (window.confirm('Are you sure you want to delete this phrase?')) {
                                onDelete?.(phrase.id);
                              }
                            }}
                            className="text-red-600"
                          >
                            <Trash className="h-4 w-4 mr-2" />
                            Delete
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}

============================================================

FILE: .\features\phrases\stores\filterContext.tsx
SIZE: 1.63 KB
LAST MODIFIED: 03/21/2025 09:15:13

// features/phrases/stores/filterContext.tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface FilterState {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
  page: number;
  pageSize: number;
  sortBy: string;
  sortDirection: 'asc' | 'desc';
}

interface FilterContextValue extends FilterState {
  setFilter: (key: string, value: string | number) => void;
  resetFilters: () => void;
}

const defaultState: FilterState = {
  searchTerm: '',
  category: '',
  difficulty: '',
  subcategory: '',
  part_of_speech: '',
  page: 1,
  pageSize: 10,
  sortBy: 'id',
  sortDirection: 'desc'
};

const FilterContext = createContext<FilterContextValue | undefined>(undefined);

export function FilterProvider({ children }: { children: ReactNode }) {
  const [filters, setFilters] = useState<FilterState>(defaultState);

  const setFilter = (key: string, value: string | number) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
      // Reset to page 1 when changing filters
      ...(key !== 'page' ? { page: 1 } : {})
    }));
  };

  const resetFilters = () => {
    setFilters(defaultState);
  };

  return (
    <FilterContext.Provider
      value={{
        ...filters,
        setFilter,
        resetFilters
      }}
    >
      {children}
    </FilterContext.Provider>
  );
}

export function useFilter() {
  const context = useContext(FilterContext);
  if (context === undefined) {
    throw new Error('useFilter must be used within a FilterProvider');
  }
  return context;
}

============================================================

FILE: .\features\phrases\stores\filterstore.ts
SIZE: 1.03 KB
LAST MODIFIED: 03/21/2025 09:24:30

// features/phrases/stores/filterStore.ts
import { create } from 'zustand';

interface FilterState {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
  page: number;
  pageSize: number;
  sortBy: string;
  sortDirection: 'asc' | 'desc';
  setFilter: (key: string, value: string | number) => void;
  resetFilters: () => void;
}

export const useFilterStore = create<FilterState>((set) => ({
  searchTerm: '',
  category: '',
  difficulty: '',
  subcategory: '',
  part_of_speech: '',
  page: 1,
  pageSize: 10,
  sortBy: 'id',
  sortDirection: 'desc',
  
  setFilter: (key, value) => set((state) => ({ 
    ...state, 
    [key]: value,
    // Reset to page 1 when changing filters
    ...(key !== 'page' ? { page: 1 } : {})
  })),
  
  resetFilters: () => set({
    searchTerm: '',
    category: '',
    difficulty: '',
    subcategory: '',
    part_of_speech: '',
    page: 1,
    pageSize: 10,
    sortBy: 'id',
    sortDirection: 'desc'
  })
}));

============================================================

FILE: .\features\phrases\utils\formatting.ts
SIZE: 1.1 KB
LAST MODIFIED: 03/21/2025 09:24:12

// features/phrases/utils/formatting.ts
/**
 * Returns the appropriate CSS classes for a difficulty bar
 */
export const getDifficultyBar = (difficulty: number) => {
  const colorClass = 
    difficulty === 1 ? 'bg-gray-200' : 
    difficulty === 2 ? 'bg-gray-200' : 
    difficulty === 3 ? 'bg-gray-200' : 'bg-gray-200';
  
  const width = 
    difficulty === 1 ? 'w-1/3' : 
    difficulty === 2 ? 'w-2/3' : 
    difficulty === 3 ? 'w-full' : 'w-0';
  
  return (
    <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-600">
      <div className={`${colorClass} ${width} h-2.5 rounded-full`}></div>
    </div>
  );
};

/**
 * Converts a numeric difficulty to a human-readable string
 */
export const formatDifficulty = (value: number): string => {
  switch (value) {
    case 1: return 'Easy';
    case 2: return 'Medium';
    case 3: return 'Hard';
    default: return 'Unknown';
  }
};

/**
 * Formats tags string into an array of tag strings
 */
export const formatTags = (tags: string): string[] => {
  return tags.split(',').map(tag => tag.trim()).filter(Boolean);
};

============================================================

FILE: .\lib\utils.ts
SIZE: 0.16 KB
LAST MODIFIED: 03/04/2025 21:05:08

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


============================================================

FILE: .\lib\api\client.ts
SIZE: 7.66 KB
LAST MODIFIED: 03/20/2025 22:29:36

// lib/api/client.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  }
});

// lib/api/base.ts
/**
 * Helper functions for API calls
 */
export async function handleResponse<T>(
  promise: Promise<{ data: T | null; error: any }>
): Promise<T> {
  const { data, error } = await promise;

  if (error) {
    console.error('API error:', error);
    throw new Error(error.message || 'An unknown error occurred');
  }

  if (!data) {
    throw new Error('No data returned from API');
  }

  return data;
}

// lib/api/phrases.ts
import { supabase } from './client';
import { handleResponse } from './base';
import type { Phrase, NewPhrase, PhraseFilters, PaginatedResponse } from '@/types';

export const phrasesApi = {
  /**
   * Fetch phrases with filtering, sorting, and pagination
   */
  async getPhrases(
    filters?: PhraseFilters,
    pagination?: { page: number; pageSize: number },
    sort?: { column: string; direction: 'asc' | 'desc' }
  ): Promise<PaginatedResponse<Phrase>> {
    try {
      let query = supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(id, name),
          subcategories:subcategory_id(id, name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `, { count: 'exact' });

      // Apply filters
      if (filters) {
        // Apply each filter conditionally
        // ...implementation...
      }

      // Apply sorting
      if (sort && sort.column) {
        query = query.order(sort.column, {
          ascending: sort.direction === 'asc',
          nullsFirst: false,
        });
      } else {
        // Default sort
        query = query.order('id', { ascending: false });
      }

      // Apply pagination
      if (pagination) {
        const { page, pageSize } = pagination;
        const start = (page - 1) * pageSize;
        const end = start + pageSize - 1;
        query = query.range(start, end);
      }

      const { data, error, count } = await query;

      if (error) throw error;

      // Transform the data
      const transformedData = data?.map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || '',
      })) || [];

      return {
        data: transformedData,
        total: count || 0,
        page: pagination?.page || 1,
        pageSize: pagination?.pageSize || transformedData.length,
        totalPages: count ? Math.ceil(count / (pagination?.pageSize || 10)) : 1,
      };
    } catch (error) {
      console.error('Error fetching phrases:', error);
      throw error;
    }
  },

  /**
   * Get a single phrase by ID
   */
  async getPhrase(id: number): Promise<Phrase> {
    return handleResponse(
      supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(id, name),
          subcategories:subcategory_id(id, name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `)
        .eq('id', id)
        .single()
    ).then(data => ({
      ...data,
      category: data.categories?.name || '',
      subcategory: data.subcategories?.name || '',
      tags: data.phrase_tags
        ?.map((pt: any) => pt.tags.tag)
        .filter(Boolean)
        .join(',') || '',
    }));
  },

  /**
   * Add a new phrase
   */
  async addPhrase(phrase: NewPhrase): Promise<Phrase> {
    // Implementation...
    return {} as Phrase; // Placeholder
  },

  /**
   * Update a phrase
   */
  async updatePhrase(id: number, updates: Partial<Phrase>): Promise<Phrase> {
    // Implementation...
    return {} as Phrase; // Placeholder
  },

  /**
   * Delete a phrase
   */
  async deletePhrase(id: number): Promise<void> {
    // Implementation...
  }
};

// lib/api/categories.ts
import { supabase } from './client';
import { handleResponse } from './base';
import type { Category } from '@/types';

export const categoriesApi = {
  /**
   * Fetch all categories
   */
  async getCategories(): Promise<Category[]> {
    return handleResponse(
      supabase
        .from('categories')
        .select('*')
        .order('name')
    );
  },
  
  /**
   * Get a category by ID
   */
  async getCategory(id: number): Promise<Category> {
    return handleResponse(
      supabase
        .from('categories')
        .select('*')
        .eq('id', id)
        .single()
    );
  },
  
  /**
   * Get a category by name
   */
  async getCategoryByName(name: string): Promise<Category> {
    return handleResponse(
      supabase
        .from('categories')
        .select('*')
        .eq('name', name)
        .single()
    );
  },
  
  /**
   * Add a new category
   */
  async addCategory(name: string): Promise<Category> {
    return handleResponse(
      supabase
        .from('categories')
        .insert({ name })
        .select()
        .single()
    );
  },
  
  /**
   * Update a category
   */
  async updateCategory(id: number, name: string): Promise<Category> {
    return handleResponse(
      supabase
        .from('categories')
        .update({ name })
        .eq('id', id)
        .select()
        .single()
    );
  },
  
  /**
   * Delete a category
   */
  async deleteCategory(id: number): Promise<void> {
    await handleResponse(
      supabase
        .from('categories')
        .delete()
        .eq('id', id)
    );
  }
};

// lib/api/auth.ts
import { supabase } from './client';
import { handleResponse } from './base';
import type { Reviewer } from '@/types';

export const authApi = {
  /**
   * Fetch all reviewers
   */
  async getReviewers(): Promise<Reviewer[]> {
    return handleResponse(
      supabase
        .from('reviewers')
        .select('*')
        .order('name')
    );
  },
  
  /**
   * Get a reviewer by ID
   */
  async getReviewer(id: string): Promise<Reviewer> {
    return handleResponse(
      supabase
        .from('reviewers')
        .select('*')
        .eq('id', id)
        .single()
    );
  },
  
  /**
   * Authenticate a reviewer with PIN
   */
  async authenticateReviewer(name: string, pin: string): Promise<Reviewer | null> {
    const { data, error } = await supabase
      .from('reviewers')
      .select('*')
      .eq('name', name)
      .eq('pin', pin)
      .single();
    
    if (error || !data) {
      return null;
    }
    
    return data;
  },
  
  /**
   * Update reviewer stats
   */
  async updateReviewerStats(id: string, stats: {
    total_reviews?: number;
    current_streak?: number;
  }): Promise<void> {
    await handleResponse(
      supabase
        .from('reviewers')
        .update({
          ...stats,
          last_review_at: new Date().toISOString()
        })
        .eq('id', id)
    );
  }
};

// lib/api/index.ts
// Barrel export for all API modules
export * from './client';
export * from './phrases';
export * from './categories';
export * from './auth';

// Example usage in a component:
// import { phrasesApi } from '@/lib/api';
//
// const { data, total } = await phrasesApi.getPhrases(
//   { category: 'Animals' }, 
//   { page: 1, pageSize: 10 }
// );

============================================================

FILE: .\lib\services\claudeService.ts
SIZE: 5.79 KB
LAST MODIFIED: 03/04/2025 11:02:57

'use client';

export interface GenerateTagsResponse {
  tags: string[];
  error?: string;
}

export interface GenerateHintResponse {
  hint: string;
  error?: string;
}

export interface GeneratePhrasesResponse {
  phrases: string[];
  error?: string;
}

export interface SuggestCategoryResponse {
  category: string;
  error?: string;
}

const makeClaudeRequest = async (messages: Array<{ role: string; content: string }>) => {
  const response = await fetch('/api/claude', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ messages })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('API error response:', errorText);
    throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
  }

  return await response.json();
};

export const generateTags = async (phrase: string): Promise<GenerateTagsResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate exactly 3 descriptive tags for this catch phrase: "${phrase}".
                Rules for tags:
                1. Must be single words, no spaces or hyphens
                2. All lowercase
                3. Maximum 15 characters per tag
                4. No special characters or numbers
                5. No generic words like "fun" or "game"
                6. Focus on theme, subject matter, or skill required
                7. Avoid duplicate meaning tags
                
                Return only the 3 tags separated by commas, nothing else.
                Example format: strategy,teamwork,creativity`
    }]);

    const tags = data.content[0].text
      .split(',')
      .map((tag: string) => tag.trim())
      .filter((tag: string) => 
        tag.length <= 15 && 
        /^[a-z]+$/.test(tag) &&
        !['fun', 'game', 'play'].includes(tag)
      );

    if (tags.length !== 3) {
      throw new Error('Invalid tag generation result');
    }

    return { tags };
  } catch (error) {
    console.error('Error generating tags:', error);
    return {
      tags: [],
      error: error instanceof Error ? error.message : 'Failed to generate tags'
    };
  }
};

export const generateHint = async (phrase: string): Promise<GenerateHintResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Create a VERY SHORT helpful hint for the catch phrase: "${phrase}".
                Rules for hints:
                1. MUST BE 20 CHARACTERS OR LESS - THIS IS CRITICAL
                2. Don't reveal the exact answer
                3. Focus on context or category
                4. No direct synonyms
                5. Can be a clever riddle or wordplay
                6. Should help players think in right direction
                7. No explicit "This is..." or "Think about..." phrases
                
                Return only the hint text, nothing else.
                Example: For "BOOKWORM" -> "Reads a lot"`
    }]);

    const hint = data.content[0].text.trim();

    if (hint.length > 20) {
      // Truncate if still over limit, keeping it to 20 characters
      return { hint: hint.substring(0, 20) };
    }

    return { hint };
  } catch (error) {
    console.error('Error generating hint:', error);
    return {
      hint: '',
      error: error instanceof Error ? error.message : 'Failed to generate hint'
    };
  }
};

export const generatePhrases = async (inspiration: string, count: number = 5): Promise<GeneratePhrasesResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate ${count} unique and interesting catch phrases or words based on this inspiration: "${inspiration}".
                Rules for generated words/phrases:
                1. Mix of single words and short phrases (2-3 words)
                2. Suitable for a word game
                3. Each entry should be distinct and creative
                4. No extremely obscure terms
                5. Family-friendly content only
                6. No proper nouns unless very well known
                7. Varying difficulty levels
                
                Return only the list of words/phrases separated by commas, nothing else.
                Example format: Slumber party, DÃ©jÃ  vu, Photograph, Brain teaser, Pumpkin spice`
    }]);

    const phrases = data.content[0].text
      .split(',')
      .map((phrase: string) => phrase.trim())
      .filter((phrase: string) => phrase.length > 0);

    if (phrases.length === 0) {
      throw new Error('No phrases were generated');
    }

    return { phrases };
  } catch (error) {
    console.error('Error generating phrases:', error);
    return {
      phrases: [],
      error: error instanceof Error ? error.message : 'Failed to generate phrases'
    };
  }
};

export const suggestCategory = async (phrase: string, categories: string[]): Promise<SuggestCategoryResponse> => {
  try {
    const response = await fetch('/api/claude/suggest-category', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        phrase,
        categories
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('API error response:', errorText);
      throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
    }

    const data = await response.json();
    return { category: data.category };
  } catch (error) {
    console.error('Error suggesting category:', error);
    return {
      category: '',
      error: error instanceof Error ? error.message : 'Failed to suggest category'
    };
  }
};

============================================================

FILE: .\lib\services\supabase.ts
SIZE: 0.55 KB
LAST MODIFIED: 02/18/2025 10:42:19

import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/supabase'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  }
})

export const checkAuth = async () => {
  if (typeof window === 'undefined') {
    return null
  }
  const { data: { session } } = await supabase.auth.getSession()
  return session
}

============================================================

FILE: .\lib\utils\bulkImport.ts
SIZE: 5.11 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { supabase } from '@/lib/services/supabase';
import { validateBulkImport, sanitizePhrase } from './Validators';
import type { NewPhrase, Phrase } from '@/types/types';

interface BulkImportResult {
  success: boolean;
  message: string;
  newIds?: number[];
}

interface ImportedPhrase extends NewPhrase {
  id: number;
}

/**
 * Handles bulk import of phrases
 */
export const handleBulkImport = async (text: string): Promise<BulkImportResult> => {
  try {
    // Validate the input format
    const validation = validateBulkImport(text);
    if (!validation.isValid) {
      return {
        success: false,
        message: validation.errors.join('\n')
      };
    }

    // Parse and process the data
    const rows = text.trim().split('\n').map((row, index) => {
      const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = 
        row.split(',').map(field => field.trim());

      const newPhrase: NewPhrase = {
        phrase,
        category,
        difficulty,
        subcategory,
        tags,
        hint,
        part_of_speech
      };

      return sanitizePhrase(newPhrase) as NewPhrase;
    });

    // Insert the data
    const { data, error } = await supabase
      .from('phrases')
      .insert(rows)
      .select('id');

    if (error) {
      throw new Error(error.message);
    }

    const newIds = (data as ImportedPhrase[]).map(phrase => phrase.id);

    return {
      success: true,
      message: `Successfully imported ${rows.length} phrases.`,
      newIds
    };
  } catch (err) {
    console.error('Bulk import error:', err);
    return {
      success: false,
      message: err instanceof Error 
        ? err.message 
        : 'An error occurred during import'
    };
  }
};

/**
 * Validates a CSV file before import
 */
export const validateCSVFile = (file: File): Promise<{ isValid: boolean; message: string }> => {
  return new Promise((resolve, reject) => {
    // Check file type
    if (!file.name.endsWith('.csv')) {
      resolve({ 
        isValid: false, 
        message: 'File must be a CSV document' 
      });
      return;
    }

    // Check file size (e.g., 5MB limit)
    const maxSize = 5 * 1024 * 1024; // 5MB in bytes
    if (file.size > maxSize) {
      resolve({ 
        isValid: false, 
        message: 'File size must be less than 5MB' 
      });
      return;
    }

    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const validation = validateBulkImport(text);
        
        resolve({
          isValid: validation.isValid,
          message: validation.isValid 
            ? 'File is valid' 
            : validation.errors.join('\n')
        });
      } catch (err) {
        resolve({
          isValid: false,
          message: 'Error reading file content'
        });
      }
    };

    reader.onerror = () => {
      resolve({
        isValid: false,
        message: 'Error reading file'
      });
    };

    reader.readAsText(file);
  });
};

/**
 * Processes a CSV file and returns structured data
 */
export const processCSVFile = async (file: File): Promise<NewPhrase[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const phrases = text
          .trim()
          .split('\n')
          .map((row) => {
            const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = 
              row.split(',').map(field => field.trim());

            return sanitizePhrase({
              phrase,
              category,
              difficulty,
              subcategory,
              tags,
              hint,
              part_of_speech
            }) as NewPhrase;
          });

        resolve(phrases);
      } catch (err) {
        reject(new Error('Error processing CSV file'));
      }
    };

    reader.onerror = () => {
      reject(new Error('Error reading CSV file'));
    };

    reader.readAsText(file);
  });
};

/**
 * Downloads current phrases as CSV
 */
export const exportToCSV = async (): Promise<string> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*')
      .order('id');

    if (error) throw error;
    if (!data || data.length === 0) {
      throw new Error('No data to export');
    }

    // Create CSV header
    const headers = ['phrase', 'category', 'difficulty', 'subcategory', 'tags', 'hint', 'part_of_speech'];
    
    // Convert data to CSV rows
    const rows = data.map((phrase: Phrase) =>
      headers
        .map(header => phrase[header as keyof Phrase] || '')
        .map(field => `"${String(field).replace(/"/g, '""')}"`) // Escape quotes
        .join(',')
    );

    // Combine header and rows
    const csv = [headers.join(','), ...rows].join('\n');
    
    return csv;
  } catch (err) {
    console.error('Export error:', err);
    throw err;
  }
};


============================================================

FILE: .\lib\utils\databaseMaintenance.ts
SIZE: 5.37 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { supabase } from '@/lib/services/supabase';
import type { Phrase } from '@/types/types';

interface MaintenanceResult {
  success: boolean;
  message: string;
  details?: Record<string, any>;
}

interface PhraseTag {
  id: number;
  tags: string;
}

interface PhraseCategory {
  category: string;
}

/**
 * Updates existing tags format
 */
export const updateExistingTags = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('id, tags');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const updates = data.map((phrase: PhraseTag) => ({
      id: phrase.id,
      tags: phrase.tags
        .split(/[,\s]+/) // Split by comma or whitespace
        .map((tag: string) => tag.trim())
        .filter(Boolean)
        .join(',')
    }));

    const { error: updateError } = await supabase
      .from('phrases')
      .upsert(updates);

    if (updateError) throw updateError;

    return {
      success: true,
      message: `Successfully updated tags for ${updates.length} phrases.`,
      details: { updatedCount: updates.length }
    };
  } catch (err) {
    console.error('Error updating tags:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while updating tags'
    };
  }
};

/**
 * Cleans up unused categories
 */
export const cleanupCategories = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('category');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const categories = new Set(data.map((p: PhraseCategory) => p.category).filter(Boolean));
    const unusedCategories = Array.from(categories).filter(category => 
      !data.some((p: PhraseCategory) => p.category === category)
    );

    if (unusedCategories.length === 0) {
      return {
        success: true,
        message: 'No unused categories found.',
        details: { unusedCount: 0 }
      };
    }

    const { error: deleteError } = await supabase
      .from('phrases')
      .update({ category: 'Uncategorized' })
      .in('category', unusedCategories);

    if (deleteError) throw deleteError;

    return {
      success: true,
      message: `Cleaned up ${unusedCategories.length} unused categories.`,
      details: {
        unusedCount: unusedCategories.length,
        categories: unusedCategories
      }
    };
  } catch (err) {
    console.error('Error cleaning categories:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while cleaning categories'
    };
  }
};

/**
 * Validates all phrases in the database
 */
export const validateDatabase = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const issues: Array<{ id: number; issues: string[] }> = [];

    data.forEach((phrase: Phrase) => {
      const phraseIssues: string[] = [];

      if (!phrase.phrase?.trim()) {
        phraseIssues.push('Missing phrase text');
      }
      if (!phrase.category?.trim()) {
        phraseIssues.push('Missing category');
      }
      if (!['Easy', 'Medium', 'Hard'].includes(phrase.difficulty)) {
        phraseIssues.push('Invalid difficulty level');
      }
      if (!phrase.tags?.trim()) {
        phraseIssues.push('Missing tags');
      }

      if (phraseIssues.length > 0) {
        issues.push({ id: phrase.id, issues: phraseIssues });
      }
    });

    return {
      success: true,
      message: `Validation complete. Found ${issues.length} phrases with issues.`,
      details: { issues }
    };
  } catch (err) {
    console.error('Error validating database:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while validating the database'
    };
  }
};

/**
 * Performs database backup
 */
export const backupDatabase = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    // Convert to CSV
    const headers = Object.keys(data[0]);
    const csv = [
      headers.join(','),
      ...data.map((row: Record<string, any>) =>
        headers
          .map(header => {
            const cell = row[header]?.toString() ?? '';
            return `"${cell.replace(/"/g, '""')}"`;
          })
          .join(',')
      )
    ].join('\n');

    // Create backup timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `phrases-backup-${timestamp}.csv`;

    return {
      success: true,
      message: 'Backup created successfully.',
      details: {
        filename,
        content: csv,
        timestamp,
        recordCount: data.length
      }
    };
  } catch (err) {
    console.error('Error creating backup:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while creating backup'
    };
  }
};


============================================================

FILE: .\lib\utils\formatters.ts
SIZE: 4.56 KB
LAST MODIFIED: 02/09/2025 10:16:11

/**
 * Formats a number with commas for thousands
 */
export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('en-US').format(num);
};

/**
 * Formats a number as a percentage
 */
export const formatPercent = (num: number, decimals: number = 0): string => {
  return `${num.toFixed(decimals)}%`;
};

/**
 * Formats a date in a localized format
 */
export const formatDate = (date: Date | string | null): string => {
  if (!date) return 'Never';
  
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

/**
 * Formats a date relative to now (e.g., "2 days ago")
 */
export const formatRelativeDate = (date: Date | string | null): string => {
  if (!date) return 'Never';

  const now = new Date();
  const then = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - then.getTime()) / 1000);
  
  if (diffInSeconds < 60) {
    return 'just now';
  }
  
  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes} minute${diffInMinutes === 1 ? '' : 's'} ago`;
  }
  
  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours} hour${diffInHours === 1 ? '' : 's'} ago`;
  }
  
  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 30) {
    return `${diffInDays} day${diffInDays === 1 ? '' : 's'} ago`;
  }
  
  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) {
    return `${diffInMonths} month${diffInMonths === 1 ? '' : 's'} ago`;
  }
  
  const diffInYears = Math.floor(diffInMonths / 12);
  return `${diffInYears} year${diffInYears === 1 ? '' : 's'} ago`;
};

/**
 * Formats difficulty level with color class
 */
export const formatDifficulty = (difficulty: string): { text: string; colorClass: string } => {
  const normalized = difficulty.toLowerCase();
  switch (normalized) {
    case 'easy':
      return { text: 'Easy', colorClass: 'text-green-400' };
    case 'medium':
      return { text: 'Medium', colorClass: 'text-yellow-400' };
    case 'hard':
      return { text: 'Hard', colorClass: 'text-red-400' };
    default:
      return { text: difficulty, colorClass: 'text-gray-400' };
  }
};

/**
 * Formats tags as an array with optional truncation
 */
export const formatTags = (tags: string, maxTags?: number): string[] => {
  const tagArray = tags.split(',').map(tag => tag.trim()).filter(Boolean);
  if (maxTags && tagArray.length > maxTags) {
    return [...tagArray.slice(0, maxTags), `+${tagArray.length - maxTags} more`];
  }
  return tagArray;
};

/**
 * Formats file size in bytes to human readable format
 */
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
};

/**
 * Formats a string to title case
 */
export const formatTitleCase = (str: string): string => {
  return str
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

/**
 * Formats text with ellipsis if it exceeds max length
 */
export const formatTruncate = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength)}...`;
};

/**
 * Formats category for display
 */
export const formatCategory = (category: string): { text: string; icon: string } => {
  const normalized = category.toLowerCase();
  switch (normalized) {
    case 'movies':
      return { text: 'Movies', icon: 'ðŸŽ¬' };
    case 'tv':
      return { text: 'TV Shows', icon: 'ðŸ“º' };
    case 'books':
      return { text: 'Books', icon: 'ðŸ“š' };
    case 'music':
      return { text: 'Music', icon: 'ðŸŽµ' };
    case 'games':
      return { text: 'Games', icon: 'ðŸŽ®' };
    default:
      return { text: formatTitleCase(category), icon: 'ðŸ“' };
  }
};

/**
 * Formats CSV data into a downloadable string
 */
export const formatCSV = (data: Record<string, any>[]): string => {
  if (data.length === 0) return '';

  const headers = Object.keys(data[0]);
  const rows = data.map(row => 
    headers
      .map(header => {
        const cell = row[header]?.toString() ?? '';
        return `"${cell.replace(/"/g, '""')}"`;
      })
      .join(',')
  );

  return [headers.join(','), ...rows].join('\n');
};

============================================================

FILE: .\lib\utils\phraseUtils.ts
SIZE: 6.53 KB
LAST MODIFIED: 02/09/2025 10:18:26

import type { Phrase, NewPhrase, TagValidationResult } from '@/types/types';

/**
 * Validates and formats tags
 */
export const validateTags = (tags: string): TagValidationResult => {
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  const errors: string[] = [];
  
  if (tagArray.length === 0) {
    errors.push('At least one tag is required');
  }
  
  if (tagArray.some(tag => tag.length < 2)) {
    errors.push('Tags must be at least 2 characters long');
  }
  
  if (tagArray.some(tag => !/^[a-zA-Z0-9\s]+$/.test(tag))) {
    errors.push('Tags can only contain letters, numbers, and spaces');
  }

  const formattedTags = tagArray.join(',');

  return {
    isValid: errors.length === 0,
    formattedTags,
    errors
  };
};

/**
 * Formats and sanitizes a phrase object
 */
export const sanitizePhrase = (phrase: Partial<Phrase | NewPhrase>): Partial<Phrase | NewPhrase> => {
  return {
    ...phrase,
    phrase: phrase.phrase?.trim(),
    category: phrase.category?.trim(),
    difficulty: phrase.difficulty?.trim(),
    subcategory: phrase.subcategory?.trim(),
    tags: phrase.tags?.split(',').map(t => t.trim()).filter(Boolean).join(','),
    hint: phrase.hint?.trim(),
    part_of_speech: phrase.part_of_speech?.trim()
  };
};

/**
 * Groups phrases by category
 */
export const groupPhrasesByCategory = (phrases: Phrase[]): Record<string, Phrase[]> => {
  return phrases.reduce((acc, phrase) => {
    const category = phrase.category || 'Uncategorized';
    acc[category] = acc[category] || [];
    acc[category].push(phrase);
    return acc;
  }, {} as Record<string, Phrase[]>);
};

/**
 * Filters phrases based on search criteria
 */
export const filterPhrases = (
  phrases: Phrase[],
  filters: {
    searchTerm?: string;
    category?: string;
    difficulty?: string;
    subcategory?: string;
    part_of_speech?: string;
  }
): Phrase[] => {
  return phrases.filter(phrase => {
    const searchTermMatch = !filters.searchTerm || 
      phrase.phrase.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
      phrase.tags.toLowerCase().includes(filters.searchTerm.toLowerCase());

    const categoryMatch = !filters.category || 
      phrase.category.toLowerCase() === filters.category.toLowerCase();

    const difficultyMatch = !filters.difficulty || 
      phrase.difficulty.toLowerCase() === filters.difficulty.toLowerCase();

    const subcategoryMatch = !filters.subcategory || 
      phrase.subcategory.toLowerCase() === filters.subcategory.toLowerCase();

    const partOfSpeechMatch = !filters.part_of_speech || 
      phrase.part_of_speech.toLowerCase() === filters.part_of_speech.toLowerCase();

    return searchTermMatch && categoryMatch && difficultyMatch && 
           subcategoryMatch && partOfSpeechMatch;
  });
};

/**
 * Sorts phrases by specified criteria
 */
export const sortPhrases = (
  phrases: Phrase[],
  sortKey: keyof Phrase,
  sortDirection: 'asc' | 'desc'
): Phrase[] => {
  return [...phrases].sort((a, b) => {
    const aVal = a[sortKey];
    const bVal = b[sortKey];

    if (aVal === bVal) return 0;
    
    if (aVal === null || aVal === undefined) return 1;
    if (bVal === null || bVal === undefined) return -1;

    const comparison = aVal < bVal ? -1 : 1;
    return sortDirection === 'asc' ? comparison : -comparison;
  });
};

/**
 * Checks if a phrase needs review (hasn't been used in a while)
 */
export const needsReview = (phrase: Phrase, daysThreshold: number = 30): boolean => {
  if (!phrase.last_used) return true;
  
  const lastUsed = new Date(phrase.last_used);
  const now = new Date();
  const diffTime = Math.abs(now.getTime() - lastUsed.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  return diffDays > daysThreshold;
};

/**
 * Gets phrases that haven't been used in a while
 */
export const getPhrasesNeedingReview = (
  phrases: Phrase[],
  daysThreshold: number = 30
): Phrase[] => {
  return phrases.filter(phrase => needsReview(phrase, daysThreshold));
};

/**
 * Gets phrases by difficulty level
 */
export const getPhrasesByDifficulty = (
  phrases: Phrase[],
  difficulty: string
): Phrase[] => {
  return phrases.filter(
    phrase => phrase.difficulty.toLowerCase() === difficulty.toLowerCase()
  );
};

/**
 * Gets related phrases based on tags
 */
export const getRelatedPhrases = (
  phrases: Phrase[],
  currentPhrase: Phrase,
  maxResults: number = 5
): Phrase[] => {
  const currentTags = new Set(currentPhrase.tags.split(',').map(t => t.trim()));
  
  return phrases
    .filter(phrase => phrase.id !== currentPhrase.id)
    .map(phrase => {
      const phraseTags = new Set(phrase.tags.split(',').map(t => t.trim()));
      const commonTags = new Set(
        [...currentTags].filter(tag => phraseTags.has(tag))
      );
      return {
        phrase,
        commonTagCount: commonTags.size
      };
    })
    .filter(({ commonTagCount }) => commonTagCount > 0)
    .sort((a, b) => b.commonTagCount - a.commonTagCount)
    .slice(0, maxResults)
    .map(({ phrase }) => phrase);
};

/**
 * Gets phrase usage statistics
 */
export const getPhraseUsageStats = (phrases: Phrase[]) => {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.setDate(now.getDate() - 30));
  
  return phrases.reduce((stats, phrase) => {
    if (!phrase.last_used) {
      stats.neverUsed++;
    } else {
      const lastUsed = new Date(phrase.last_used);
      if (lastUsed < thirtyDaysAgo) {
        stats.notRecentlyUsed++;
      } else {
        stats.recentlyUsed++;
      }
    }
    return stats;
  }, {
    neverUsed: 0,
    notRecentlyUsed: 0,
    recentlyUsed: 0
  });
};

/**
 * Gets the most used tags across all phrases
 */
export const getMostUsedTags = (
  phrases: Phrase[],
  limit: number = 10
): Array<{ tag: string; count: number }> => {
  const tagCounts = phrases.reduce((acc, phrase) => {
    phrase.tags.split(',').forEach(tag => {
      const trimmedTag = tag.trim();
      acc[trimmedTag] = (acc[trimmedTag] || 0) + 1;
    });
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(tagCounts)
    .map(([tag, count]) => ({ tag, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, limit);
};

export default {
  validateTags,
  sanitizePhrase,
  groupPhrasesByCategory,
  filterPhrases,
  sortPhrases,
  needsReview,
  getPhrasesNeedingReview,
  getPhrasesByDifficulty,
  getRelatedPhrases,
  getPhraseUsageStats,
  getMostUsedTags
};

============================================================

FILE: .\lib\utils\safeStorage.ts
SIZE: 0.79 KB
LAST MODIFIED: 03/05/2025 15:17:36

// Add this utility function somewhere in your utils folder
// utils/safeStorage.ts

export const safeStorage = {
  getItem: (key: string): string | null => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        return localStorage.getItem(key);
      }
      return null;
    } catch (error) {
      console.warn('Unable to access localStorage:', error);
      return null;
    }
  },
    
    setItem: (key: string, value: string): boolean => {
      try {
        if (typeof window !== 'undefined' && window.localStorage) {
          localStorage.setItem(key, value);
          return true;
        }
        return false;
      } catch (error) {
        console.warn('Unable to access localStorage:', error);
        return false;
      }
    }
  };

============================================================

FILE: .\lib\utils\statsUtils.ts
SIZE: 4.29 KB
LAST MODIFIED: 02/09/2025 10:15:14

import { SupabaseClient } from '@supabase/supabase-js';
import type { Stats, Phrase } from '@/types/types';

interface StatsResult {
  data: Stats | null;
  error: string | null;
}

/**
 * Calculates statistics from phrase data
 */
export const calculateStats = async (supabase: SupabaseClient): Promise<StatsResult> => {
  try {
    const { data: phrases, error, count } = await supabase
      .from('phrases')
      .select('*', { count: 'exact' });

    if (error) throw error;
    if (!phrases || phrases.length === 0) {
      return {
        data: {
          total: 0,
          uniqueCategories: 0,
          difficultyBreakdown: { easy: 0, medium: 0, hard: 0 }
        },
        error: null
      };
    }

    // Calculate unique categories
    const uniqueCategories = new Set(phrases.map(p => p.category)).size;

    // Calculate difficulty breakdown
    const difficultyCount = phrases.reduce((acc, phrase) => {
      const difficulty = phrase.difficulty.toLowerCase();
      acc[difficulty] = (acc[difficulty] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const total = count || phrases.length;

    // Calculate percentages with rounding adjustments
    let easy = Math.round((difficultyCount['easy'] || 0) / total * 100);
    let medium = Math.round((difficultyCount['medium'] || 0) / total * 100);
    let hard = Math.round((difficultyCount['hard'] || 0) / total * 100);

    // Adjust for rounding errors to ensure sum is 100
    const sum = easy + medium + hard;
    if (sum !== 100) {
      const diff = 100 - sum;
      if (easy >= medium && easy >= hard) {
        easy += diff;
      } else if (medium >= easy && medium >= hard) {
        medium += diff;
      } else {
        hard += diff;
      }
    }

    return {
      data: {
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard
        }
      },
      error: null
    };
  } catch (err) {
    console.error('Error calculating stats:', err);
    return {
      data: null,
      error: err instanceof Error ? err.message : 'An unknown error occurred'
    };
  }
};

/**
 * Calculates usage statistics for phrases
 */
export const calculateUsageStats = (phrases: Phrase[]) => {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.setDate(now.getDate() - 30));

  return phrases.reduce((stats, phrase) => {
    if (!phrase.last_used) {
      stats.neverUsed++;
    } else {
      const lastUsed = new Date(phrase.last_used);
      if (lastUsed < thirtyDaysAgo) {
        stats.notRecentlyUsed++;
      } else {
        stats.recentlyUsed++;
      }
    }
    return stats;
  }, {
    neverUsed: 0,
    notRecentlyUsed: 0,
    recentlyUsed: 0
  });
};

/**
 * Calculates category distribution
 */
export const calculateCategoryStats = (phrases: Phrase[]) => {
  const categoryCount = phrases.reduce((acc, phrase) => {
    acc[phrase.category] = (acc[phrase.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Convert to percentages
  const total = phrases.length;
  const categoryPercentages = Object.entries(categoryCount).map(([category, count]) => ({
    category,
    percentage: Math.round((count / total) * 100)
  }));

  // Sort by percentage descending
  return categoryPercentages.sort((a, b) => b.percentage - a.percentage);
};

/**
 * Calculates difficulty distribution over time
 */
export const calculateDifficultyTrends = (phrases: Phrase[]) => {
  // Group by month
  const monthlyStats = phrases.reduce((acc, phrase) => {
    const date = phrase.last_used 
      ? new Date(phrase.last_used)
      : new Date();
    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    
    if (!acc[monthKey]) {
      acc[monthKey] = { easy: 0, medium: 0, hard: 0 };
    }
    
    const difficulty = phrase.difficulty.toLowerCase();
    acc[monthKey][difficulty as 'easy' | 'medium' | 'hard']++;
    
    return acc;
  }, {} as Record<string, Record<'easy' | 'medium' | 'hard', number>>);

  // Convert to array and sort by date
  return Object.entries(monthlyStats)
    .map(([month, stats]) => ({
      month,
      ...stats
    }))
    .sort((a, b) => a.month.localeCompare(b.month));
};

============================================================

FILE: .\lib\utils\validators.ts
SIZE: 3.81 KB
LAST MODIFIED: 02/09/2025 10:13:27

import type { TagValidationResult, Phrase, NewPhrase } from '@/types/types';

/**
 * Validates tags input
 */
export const validateTags = (tags: string): TagValidationResult => {
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  const errors: string[] = [];
  
  if (tagArray.length === 0) {
    errors.push('At least one tag is required');
  }
  
  if (tagArray.some(tag => tag.length < 2)) {
    errors.push('Tags must be at least 2 characters long');
  }
  
  if (tagArray.some(tag => !/^[a-zA-Z0-9\s]+$/.test(tag))) {
    errors.push('Tags can only contain letters, numbers, and spaces');
  }

  return {
    isValid: errors.length === 0,
    formattedTags: tagArray.join(','),
    errors
  };
};

/**
 * Validates a complete phrase object
 */
export const validatePhrase = (phrase: Partial<Phrase | NewPhrase>): {
  isValid: boolean;
  errors: Record<string, string>;
} => {
  const errors: Record<string, string> = {};

  // Required fields
  if (!phrase.phrase?.trim()) {
    errors.phrase = 'Phrase is required';
  }

  if (!phrase.category?.trim()) {
    errors.category = 'Category is required';
  }

  if (!phrase.difficulty?.trim()) {
    errors.difficulty = 'Difficulty is required';
  }

  if (!phrase.part_of_speech?.trim()) {
    errors.part_of_speech = 'Part of speech is required';
  }

  // Length validations
  if (phrase.phrase && phrase.phrase.length < 2) {
    errors.phrase = 'Phrase must be at least 2 characters long';
  }

  if (phrase.subcategory && phrase.subcategory.length < 2) {
    errors.subcategory = 'Subcategory must be at least 2 characters long';
  }

  // Validate difficulty values
  if (
    phrase.difficulty &&
    !['Easy', 'Medium', 'Hard'].includes(phrase.difficulty)
  ) {
    errors.difficulty = 'Invalid difficulty value';
  }

  // Validate tags
  if (phrase.tags) {
    const tagValidation = validateTags(phrase.tags);
    if (!tagValidation.isValid) {
      errors.tags = tagValidation.errors?.[0] || 'Invalid tags';
    }
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

/**
 * Validates bulk import data format
 */
export const validateBulkImport = (
  data: string
): { isValid: boolean; errors: string[] } => {
  const errors: string[] = [];
  const lines = data.trim().split('\n');

  if (lines.length === 0) {
    errors.push('No data provided');
    return { isValid: false, errors };
  }

  lines.forEach((line, index) => {
    const fields = line.split(',').map(field => field.trim());

    if (fields.length !== 7) {
      errors.push(
        `Line ${index + 1}: Expected 7 fields but got ${fields.length}`
      );
      return;
    }

    const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = fields;

    if (!phrase) {
      errors.push(`Line ${index + 1}: Phrase is required`);
    }

    if (!category) {
      errors.push(`Line ${index + 1}: Category is required`);
    }

    if (!['Easy', 'Medium', 'Hard'].includes(difficulty)) {
      errors.push(`Line ${index + 1}: Invalid difficulty value`);
    }

    const tagValidation = validateTags(tags);
    if (!tagValidation.isValid) {
      errors.push(`Line ${index + 1}: ${tagValidation.errors?.[0]}`);
    }
  });

  return {
    isValid: errors.length === 0,
    errors
  };
};

/**
 * Formats and sanitizes phrase data
 */
export const sanitizePhrase = (phrase: Partial<Phrase | NewPhrase>): Partial<Phrase | NewPhrase> => {
  return {
    ...phrase,
    phrase: phrase.phrase?.trim(),
    category: phrase.category?.trim(),
    subcategory: phrase.subcategory?.trim(),
    tags: phrase.tags?.split(',').map(t => t.trim()).filter(Boolean).join(','),
    hint: phrase.hint?.trim(),
    part_of_speech: phrase.part_of_speech?.trim()
  };
};

============================================================

FILE: .\providers\ThemeProvider.tsx
SIZE: 0.77 KB
LAST MODIFIED: 03/06/2025 21:02:46

"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

/**
 * Hook for using the theme
 * @returns Theme utilities including theme, setTheme, and systemTheme
 */
export function useTheme() {
  const { theme, setTheme, systemTheme } = React.useContext(
    // @ts-ignore - This context does exist in next-themes
    require("next-themes").ThemeContext
  )
  
  return { 
    theme, 
    setTheme, 
    systemTheme,
    toggleTheme: () => setTheme(theme === "dark" ? "light" : "dark")
  }
}

============================================================

FILE: .\services\dashboard-data-service.ts
SIZE: 10.85 KB
LAST MODIFIED: 03/21/2025 18:39:36

// src/services/dashboard-data-service.ts
import { supabase } from '@/lib/services/supabase';

export interface DashboardStats {
  newPhrases: {
    value: number;
    trend: number;
    sparkline: number[];
  };
  reviewedPhrases: {
    value: number;
    trend: number;
    sparkline: number[];
  };
  activeReviewers: {
    value: number;
    trend: number;
  };
  topReviewer: {
    name: string;
    count: number;
    streak: number;
  };
}

export const DashboardDataService = {
  // Fetch dashboard stats
  fetchDashboardStats: async (dateRange = 30): Promise<DashboardStats | null> => {
    try {
      // Calculate date ranges for current period and previous period
      const currentStart = new Date();
      currentStart.setDate(currentStart.getDate() - dateRange);
      
      const previousStart = new Date(currentStart);
      previousStart.setDate(previousStart.getDate() - dateRange);
      
      const currentStartStr = currentStart.toISOString();
      const previousStartStr = previousStart.toISOString();
      const now = new Date().toISOString();
      
      // 1. New Phrases in the Last Month
      const { data: newPhrasesData, error: newPhrasesError } = await supabase
        .from('phrases')
        .select('id, created_at')
        .gte('created_at', currentStartStr)
        .order('created_at', { ascending: true });
      
      if (newPhrasesError) {
        console.error("New phrases query error:", newPhrasesError);
        throw newPhrasesError;
      }
      
      // 2. Calculate previous period for trend
      const { count: previousNewPhrasesCount, error: previousNewPhrasesError } = await supabase
        .from('phrases')
        .select('id', { count: 'exact', head: true })
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousNewPhrasesError) {
        console.error("Previous phrases query error:", previousNewPhrasesError);
        throw previousNewPhrasesError;
      }
      
      // 3. Phrases Reviewed in the Last Month
      const { data: reviewedPhrasesData, error: reviewedPhrasesError } = await supabase
        .from('votes')
        .select('id, created_at')
        .gte('created_at', currentStartStr)
        .order('created_at', { ascending: true });
      
      if (reviewedPhrasesError) {
        console.error("Reviewed phrases query error:", reviewedPhrasesError);
        throw reviewedPhrasesError;
      }
      
      // 4. Calculate previous period for trend
      const { count: previousReviewedCount, error: previousReviewedError } = await supabase
        .from('votes')
        .select('id', { count: 'exact', head: true })
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousReviewedError) {
        console.error("Previous reviewed query error:", previousReviewedError);
        throw previousReviewedError;
      }
      
      // 5. Active Reviewers Count
      const { data: activeReviewers, error: activeReviewersError } = await supabase
        .from('votes')
        .select('reviewer_id')
        .gte('created_at', currentStartStr);
      
      if (activeReviewersError) {
        console.error("Active reviewers query error:", activeReviewersError);
        throw activeReviewersError;
      }
      
      // Get unique reviewer IDs
      const uniqueReviewerIds = [...new Set(activeReviewers?.map(item => item.reviewer_id))];
      
      // 6. Calculate previous period for trend
      const { data: previousActiveReviewers, error: previousActiveReviewersError } = await supabase
        .from('votes')
        .select('reviewer_id')
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousActiveReviewersError) {
        console.error("Previous active reviewers query error:", previousActiveReviewersError);
        throw previousActiveReviewersError;
      }
      
      const previousUniqueReviewerIds = [...new Set(previousActiveReviewers?.map(item => item.reviewer_id))];
      
      // 7. Top Reviewer - Use a different approach for this query
      // First get counts for each reviewer
      const { data: reviewCounts, error: reviewCountsError } = await supabase
        .rpc('get_reviewer_counts', { start_date: currentStartStr });
        
      if (reviewCountsError) {
        console.error("Review counts query error:", reviewCountsError);
        // Fallback approach if RPC doesn't exist
        console.log("Falling back to manual aggregation...");
        // Get all reviewer_ids and manually count them
        const { data: allVotes, error: allVotesError } = await supabase
          .from('votes')
          .select('reviewer_id')
          .gte('created_at', currentStartStr);
          
        if (allVotesError) {
          console.error("All votes query error:", allVotesError);
          throw allVotesError;
        }
        
        // Create a counts object
        const counts = {};
        allVotes?.forEach(vote => {
          if (vote.reviewer_id) {
            counts[vote.reviewer_id] = (counts[vote.reviewer_id] || 0) + 1;
          }
        });
        
        // Convert to array and sort
        const reviewerCounts = Object.entries(counts).map(([reviewer_id, count]) => ({
          reviewer_id,
          count
        })).sort((a, b) => b.count - a.count);
        
        // Get top reviewer
        const topReviewerId = reviewerCounts.length > 0 ? reviewerCounts[0].reviewer_id : null;
        const topReviewerCount = reviewerCounts.length > 0 ? reviewerCounts[0].count : 0;
        
        // 8. Get reviewer details
        let topReviewer = { name: 'N/A', count: 0, streak: 0 };
        
        if (topReviewerId) {
          const { data: reviewerData, error: reviewerError } = await supabase
            .from('reviewers')
            .select('id, name, current_streak')
            .eq('id', topReviewerId)
            .single();
          
          if (reviewerError) {
            console.error("Reviewer details query error:", reviewerError);
          } else if (reviewerData) {
            topReviewer = {
              name: reviewerData.name || 'Unknown',
              count: typeof topReviewerCount === 'number' ? topReviewerCount : 0,
              streak: reviewerData.current_streak || 0
            };
          }
        }
        
        // Calculate sparkline data by grouping by day
        const newPhrasesByDay = groupByDay(newPhrasesData || []);
        const reviewsByDay = groupByDay(reviewedPhrasesData || []);
        
        // Calculate trends
        const newPhrasesTrend = calculateTrend(newPhrasesData?.length || 0, previousNewPhrasesCount || 0);
        const reviewedPhrasesTrend = calculateTrend(reviewedPhrasesData?.length || 0, previousReviewedCount || 0);
        const activeReviewersTrend = calculateTrend(uniqueReviewerIds.length, previousUniqueReviewerIds.length);
        
        return {
          newPhrases: {
            value: newPhrasesData?.length || 0,
            trend: newPhrasesTrend,
            sparkline: Object.values(newPhrasesByDay)
          },
          reviewedPhrases: {
            value: reviewedPhrasesData?.length || 0,
            trend: reviewedPhrasesTrend,
            sparkline: Object.values(reviewsByDay)
          },
          activeReviewers: {
            value: uniqueReviewerIds.length,
            trend: activeReviewersTrend
          },
          topReviewer
        };
      }
      
      // If RPC approach succeeded
      const topReviewerData = reviewCounts && reviewCounts.length > 0 ? reviewCounts[0] : null;
      
      // 8. Get reviewer details
      let topReviewer = { name: 'N/A', count: 0, streak: 0 };
      
      if (topReviewerData) {
        const { data: reviewerData, error: reviewerError } = await supabase
          .from('reviewers')
          .select('id, name, current_streak')
          .eq('id', topReviewerData.reviewer_id)
          .single();
        
        if (reviewerError) {
          console.error("Reviewer details query error:", reviewerError);
        } else if (reviewerData) {
          topReviewer = {
            name: reviewerData.name || 'Unknown',
            count: typeof topReviewerData.count === 'number' ? topReviewerData.count : parseInt(topReviewerData.count) || 0,
            streak: reviewerData.current_streak || 0
          };
        }
      }
      
      // Calculate sparkline data by grouping by day
      const newPhrasesByDay = groupByDay(newPhrasesData || []);
      const reviewsByDay = groupByDay(reviewedPhrasesData || []);
      
      // Calculate trends
      const newPhrasesTrend = calculateTrend(newPhrasesData?.length || 0, previousNewPhrasesCount || 0);
      const reviewedPhrasesTrend = calculateTrend(reviewedPhrasesData?.length || 0, previousReviewedCount || 0);
      const activeReviewersTrend = calculateTrend(uniqueReviewerIds.length, previousUniqueReviewerIds.length);
      
      return {
        newPhrases: {
          value: newPhrasesData?.length || 0,
          trend: newPhrasesTrend,
          sparkline: Object.values(newPhrasesByDay)
        },
        reviewedPhrases: {
          value: reviewedPhrasesData?.length || 0,
          trend: reviewedPhrasesTrend,
          sparkline: Object.values(reviewsByDay)
        },
        activeReviewers: {
          value: uniqueReviewerIds.length,
          trend: activeReviewersTrend
        },
        topReviewer
      };
    } catch (error) {
      console.error('Error fetching dashboard stats:', error);
      // Add detailed error information
      if (error instanceof Error) {
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
      }
      return null;
    }
  },
  
  // Other methods remain the same...
};

// Helper function to calculate percentage trend
function calculateTrend(current: number, previous: number): number {
  if (previous === 0) return current > 0 ? 100 : 0;
  const trend = ((current - previous) / previous) * 100;
  return Math.round(trend);
}

// Helper function to group data by day for sparklines
function groupByDay(data: any[]): Record<string, number> {
  const result: Record<string, number> = {};
  
  // Initialize all days in the period with 0
  const today = new Date();
  for (let i = 30; i >= 0; i--) {
    const date = new Date();
    date.setDate(today.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    result[dateStr] = 0;
  }
  
  // Fill in actual counts
  data.forEach(item => {
    if (item && item.created_at) {
      const dateStr = new Date(item.created_at).toISOString().split('T')[0];
      if (result[dateStr] !== undefined) {
        result[dateStr]++;
      }
    }
  });
  
  return result;
}
