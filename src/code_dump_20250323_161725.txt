PROJECT ANALYSIS
Generated: 03/23/2025 16:17:25
Directory: C:\_websites\phrase\src
===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: 5.1.19041.5607
OS: Microsoft Windows 10 Pro
Computer Name: OFFICE

============================================================

FILE CONTENTS:

============================================================

FILE: .\app\globals.css
SIZE: 6.09 KB
LAST MODIFIED: 03/23/2025 15:59:13

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Base colors */
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;

    /* Chart colors */
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;

    /* Animation tokens */
    --animation-duration-fast: 150ms;
    --animation-duration-normal: 300ms;
    --animation-duration-slow: 500ms;
    --animation-easing-linear: linear;
    --animation-easing-in: cubic-bezier(0.4, 0, 1, 1);
    --animation-easing-out: cubic-bezier(0, 0, 0.2, 1);
    --animation-easing-in-out: cubic-bezier(0.4, 0, 0.2, 1);

    /* Spacing and layout tokens */
    --layout-gutter: 1rem;
    --layout-margin: 2rem;
    
    /* Border radius */
    --radius: 0.5rem;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;

    /* Chart colors for dark mode */
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }

  /* Accent colors - default (grayscale) */
  [data-accent="default"] {
    --accent-hue: 220;
    --accent-saturation: 0%;
    --accent-color: hsl(0 0% 50%);
    --accent-foreground: hsl(0 0% 95%);
    --accent-muted: hsl(0 0% 30%);
    
    /* Update chart colors for grayscale accent */
    --chart-1: 0 0% 50%;
    --chart-2: 0 0% 45%;
    --chart-3: 0 0% 40%;
    --chart-4: 0 0% 35%;
    --chart-5: 0 0% 30%;
  }

  /* Blue accent */
  [data-accent="blue"] {
    --accent-hue: 220;
    --accent-saturation: 70%;
    --accent-color: hsl(var(--accent-hue) var(--accent-saturation) 50%);
    --accent-foreground: hsl(var(--accent-hue) var(--accent-saturation) 95%);
    --accent-muted: hsl(var(--accent-hue) var(--accent-saturation) 30%);
    
    /* Update chart colors for blue accent */
    --chart-1: var(--accent-hue) var(--accent-saturation) 50%;
    --chart-2: calc(var(--accent-hue) + 30) var(--accent-saturation) 45%;
    --chart-3: calc(var(--accent-hue) + 60) var(--accent-saturation) 40%;
    --chart-4: calc(var(--accent-hue) + 90) var(--accent-saturation) 45%;
    --chart-5: calc(var(--accent-hue) + 120) var(--accent-saturation) 50%;
  }

  /* Green accent */
  [data-accent="green"] {
    --accent-hue: 160;
    --accent-saturation: 60%;
    --accent-color: hsl(var(--accent-hue) var(--accent-saturation) 45%);
    --accent-foreground: hsl(var(--accent-hue) var(--accent-saturation) 95%);
    --accent-muted: hsl(var(--accent-hue) var(--accent-saturation) 25%);
    
    /* Update chart colors for green accent */
    --chart-1: var(--accent-hue) var(--accent-saturation) 45%;
    --chart-2: calc(var(--accent-hue) + 30) var(--accent-saturation) 40%;
    --chart-3: calc(var(--accent-hue) + 60) var(--accent-saturation) 35%;
    --chart-4: calc(var(--accent-hue) + 90) var(--accent-saturation) 40%;
    --chart-5: calc(var(--accent-hue) + 120) var(--accent-saturation) 45%;
  }

  /* Purple accent */
  [data-accent="purple"] {
    --accent-hue: 270;
    --accent-saturation: 60%;
    --accent-color: hsl(var(--accent-hue) var(--accent-saturation) 50%);
    --accent-foreground: hsl(var(--accent-hue) var(--accent-saturation) 95%);
    --accent-muted: hsl(var(--accent-hue) var(--accent-saturation) 30%);
    
    /* Update chart colors for purple accent */
    --chart-1: var(--accent-hue) var(--accent-saturation) 50%;
    --chart-2: calc(var(--accent-hue) + 30) var(--accent-saturation) 45%;
    --chart-3: calc(var(--accent-hue) + 60) var(--accent-saturation) 40%;
    --chart-4: calc(var(--accent-hue) + 90) var(--accent-saturation) 45%;
    --chart-5: calc(var(--accent-hue) + 120) var(--accent-saturation) 50%;
  }

  /* Orange accent */
  [data-accent="orange"] {
    --accent-hue: 30;
    --accent-saturation: 80%;
    --accent-color: hsl(var(--accent-hue) var(--accent-saturation) 50%);
    --accent-foreground: hsl(var(--accent-hue) var(--accent-saturation) 95%);
    --accent-muted: hsl(var(--accent-hue) var(--accent-saturation) 30%);
    
    /* Update chart colors for orange accent */
    --chart-1: var(--accent-hue) var(--accent-saturation) 50%;
    --chart-2: calc(var(--accent-hue) + 30) var(--accent-saturation) 40%;
    --chart-3: calc(var(--accent-hue) + 60) var(--accent-saturation) 35%;
    --chart-4: calc(var(--accent-hue) + 90) var(--accent-saturation) 40%;
    --chart-5: calc(var(--accent-hue) + 120) var(--accent-saturation) 45%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Animation keyframes */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes slideIn {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes slideOut {
  from { transform: translateY(0); opacity: 1; }
  to { transform: translateY(10px); opacity: 0; }
}

@keyframes zoomIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

@keyframes zoomOut {
  from { transform: scale(1); opacity: 1; }
  to { transform: scale(0.95); opacity: 0; }
}

============================================================

FILE: .\app\layout.tsx
SIZE: 0.58 KB
LAST MODIFIED: 03/23/2025 12:54:11

import type { Metadata } from "next";
import "./globals.css";
import { ThemeProvider } from "@/providers/ThemeContext";

export const metadata: Metadata = {
  title: "Catch Phrase Admin",
  description: "Manage your catch phrases",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="font-sans antialiased">
        <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

============================================================

FILE: .\app\page.tsx
SIZE: 0.23 KB
LAST MODIFIED: 02/07/2025 09:27:36

'use client'
 
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
 
export default function Home() {
  const router = useRouter()
  
  useEffect(() => {
    router.push('/admin')
  }, [router])
  
  return null
}

============================================================

FILE: .\app\admin\page.tsx
SIZE: 0.46 KB
LAST MODIFIED: 03/20/2025 23:01:08

// src/app/admin/page.tsx
'use client'

import dynamic from 'next/dynamic';
import { PhrasesListContainer } from '@/features/phrases/components/PhrasesList';

// If you're currently using this pattern:
const Dashboard = dynamic(() => import('@/features/dashboard/Dashboard'), {
  ssr: false
});

export default function AdminPage() {
  // If you have a tab system in your Dashboard component,
  // you'll need to pass the PhrasesListContainer to it
  return <Dashboard />;
}

============================================================

FILE: .\app\api\claude\route.ts
SIZE: 1.41 KB
LAST MODIFIED: 03/01/2025 15:23:07

import { NextResponse } from 'next/server';

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';

export async function POST(req: Request) {
  if (!CLAUDE_API_KEY) {
    console.error('Claude API key is not configured');
    return NextResponse.json(
      { error: 'Claude API key is not configured' },
      { status: 500 }
    );
  }

  try {
    const body = await req.json();
    
    const claudeResponse = await fetch(CLAUDE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-7-sonnet-20250219', // Updated model
        max_tokens: 150,
        messages: body.messages
      })
    });

    if (!claudeResponse.ok) {
      const errorText = await claudeResponse.text();
      console.error('Claude API error:', errorText);
      return NextResponse.json(
        { error: `Claude API error: ${claudeResponse.statusText}` },
        { status: claudeResponse.status }
      );
    }

    const data = await claudeResponse.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

============================================================

FILE: .\app\api\dashboard\stats\route.ts
SIZE: 0.69 KB
LAST MODIFIED: 03/21/2025 16:56:07

// app/api/dashboard/stats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { DashboardDataService } from '@/services/dashboard-data-service';

export async function POST(request: NextRequest) {
  try {
    const { dateRange = 30 } = await request.json();
    
    const stats = await DashboardDataService.fetchDashboardStats(dateRange);
    
    if (!stats) {
      return NextResponse.json({ error: 'Failed to fetch stats' }, { status: 500 });
    }
    
    return NextResponse.json(stats);
  } catch (error) {
    console.error('Error in stats API route:', error);
    return NextResponse.json({ error: 'Failed to process request' }, { status: 500 });
  }
}

============================================================

FILE: .\components\ui\alert.tsx
SIZE: 2.23 KB
LAST MODIFIED: 02/09/2025 10:34:20

import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-gray-800 border-gray-700 text-white",
        destructive: "border-red-700 bg-red-900/50 text-red-100 [&>svg]:text-red-100",
        success: "border-green-700 bg-green-900/50 text-green-100 [&>svg]:text-green-100",
        warning: "border-yellow-700 bg-yellow-900/50 text-yellow-100 [&>svg]:text-yellow-100",
        info: "border-blue-700 bg-blue-900/50 text-blue-100 [&>svg]:text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> &
    VariantProps<typeof alertVariants> & {
      onClose?: () => void;
    }
>(({ className, variant, children, onClose, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  >
    {children}
    {onClose && (
      <button
        onClick={onClose}
        className="absolute top-4 right-4 p-1 rounded-full hover:bg-gray-700/50 transition-colors"
        aria-label="Close alert"
      >
        <X className="h-4 w-4" />
      </button>
    )}
  </div>
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

============================================================

FILE: .\components\ui\button.tsx
SIZE: 1.69 KB
LAST MODIFIED: 02/09/2025 10:32:42

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-blue-500 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-blue-600 text-white hover:bg-blue-700",
        destructive: "bg-red-600 text-white hover:bg-red-700",
        outline: "border border-gray-600 bg-transparent hover:bg-gray-700 hover:text-white",
        secondary: "bg-gray-600 text-white hover:bg-gray-700",
        ghost: "hover:bg-gray-700 hover:text-white",
        link: "text-blue-500 underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };

============================================================

FILE: .\components\ui\card.tsx
SIZE: 1.79 KB
LAST MODIFIED: 03/21/2025 18:41:24

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-md border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


============================================================

FILE: .\components\ui\chart.tsx
SIZE: 6.91 KB
LAST MODIFIED: 03/23/2025 16:11:35

// components/ui/chart.tsx
"use client"

import * as React from "react"
import { Line, LineChart, ResponsiveContainer, Tooltip, BarChart, Bar, XAxis, YAxis, CartesianGrid } from "recharts"
import { useTheme } from "@/providers/ThemeContext"

export type ChartConfig = {
  [key: string]: {
    label: string
    color?: string
  }
}

interface ChartContainerProps {
  config: ChartConfig
  children: React.ReactNode
  className?: string
  [key: string]: any
}

export function ChartContainer({
  config,
  children,
  className,
  ...props
}: ChartContainerProps) {
  const { accent } = useTheme();
  
  // Get colors based on current accent
  const getChartColors = () => {
    const colorKeys = Object.keys(config);
    
    // Generate accent-specific colors
    let colors: Record<string, string> = {};
    
    switch (accent) {
      case 'blue':
        colors = colorKeys.reduce((obj, key, index) => ({
          ...obj,
          [key]: `hsl(${220 + (index * 30)}, 70%, ${50 - (index * 5)}%)`
        }), {});
        break;
      case 'green':
        colors = colorKeys.reduce((obj, key, index) => ({
          ...obj,
          [key]: `hsl(${160 + (index * 30)}, 60%, ${45 - (index * 5)}%)`
        }), {});
        break;
      case 'purple':
        colors = colorKeys.reduce((obj, key, index) => ({
          ...obj,
          [key]: `hsl(${270 + (index * 30)}, 60%, ${50 - (index * 5)}%)`
        }), {});
        break;
      case 'orange':
        colors = colorKeys.reduce((obj, key, index) => ({
          ...obj,
          [key]: `hsl(${30 + (index * 30)}, 80%, ${50 - (index * 5)}%)`
        }), {});
        break;
      default: // grayscale
        colors = colorKeys.reduce((obj, key, index) => ({
          ...obj,
          [key]: `hsl(0, 0%, ${50 - (index * 5)}%)`
        }), {});
        break;
    }
    
    // Override with manual colors if specified in config
    colorKeys.forEach(key => {
      if (config[key].color) {
        colors[key] = config[key].color!;
      }
    });
    
    return colors;
  };

  const chartColors = getChartColors();

  const createCSSVariable = (obj: Record<string, string>) => {
    return Object.entries(obj).reduce((vars, [key, value]) => {
      return {
        ...vars,
        [`--color-${key}`]: value,
      }
    }, {})
  }

  const cssVars = createCSSVariable(chartColors)

  return (
    <div style={cssVars} className={className} {...props}>
      {children}
    </div>
  )
}

interface ChartTooltipContentProps {
  active?: boolean
  payload?: any[]
  label?: string
  config?: ChartConfig
  indicator?: "circle" | "line"
}

export function ChartTooltipContent({
  active,
  payload,
  label,
  config,
  indicator = "circle",
}: ChartTooltipContentProps) {
  const { accent } = useTheme();
  
  const TypeIndicator = ({ name }: { name: string }) =>
    indicator === "circle" ? (
      <circle
        cx="6.5"
        cy="6.5"
        r="3.5"
        fill={`var(--color-${name})`}
      />
    ) : (
      <line
        x1="1"
        y1="6.5"
        x2="9"
        y2="6.5"
        stroke={`var(--color-${name})`}
        strokeWidth={2}
        strokeLinecap="round"
      />
    )

  if (!active || !payload) return null

  // Get accent-specific background
  const getTooltipBackground = () => {
    switch (accent) {
      case 'blue':
        return 'bg-blue-950/90 border-blue-700';
      case 'green':
        return 'bg-emerald-950/90 border-emerald-700';
      case 'purple':
        return 'bg-purple-950/90 border-purple-700';
      case 'orange':
        return 'bg-orange-950/90 border-orange-700';
      default: // grayscale
        return 'bg-gray-950/90 border-gray-700';
    }
  };

  return (
    <div className={`rounded-lg border ${getTooltipBackground()} p-2 shadow-sm`}>
      <div className="grid grid-cols-2 gap-2">
        <div className="flex flex-col">
          <span className="text-[0.70rem] uppercase text-muted-foreground">
            {label}
          </span>
        </div>
        <div className="flex flex-col gap-1">
          {payload.map(({ value, name }) => (
            <div key={name} className="flex items-center justify-end gap-1">
              <span className="text-[0.70rem] text-muted-foreground">
                {config?.[name]?.label ?? name}
              </span>
              <span className="font-bold tabular-nums">{value}</span>
              {config?.[name] && (
                <svg
                  width="13"
                  height="13"
                  viewBox="0 0 13 13"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <TypeIndicator name={name} />
                </svg>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

export function ChartTooltip({
  content,
  ...props
}: {
  content?: React.JSXElementConstructor<any>
  [key: string]: any
}) {
  return <Tooltip {...props} content={content} />
}

export function SimpleAreaChart({
  data,
  dataKey,
  height = 200,
  className,
}: {
  data: any[]
  dataKey: string
  height?: number
  className?: string
}) {
  const { accent } = useTheme();
  
  // Get accent-specific color
  const getStrokeColor = () => {
    switch (accent) {
      case 'blue': return "#3B82F6";
      case 'green': return "#10B981";
      case 'purple': return "#8B5CF6";
      case 'orange': return "#F97316";
      default: return "#6B7280"; // grayscale
    }
  };
  
  return (
    <div className={className}>
      <ResponsiveContainer width="100%" height={height}>
        <LineChart data={data}>
          <Line
            type="monotone"
            dataKey={dataKey}
            stroke={getStrokeColor()}
            strokeWidth={2}
            dot={false}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}

export function SimpleBarChart({
  data,
  dataKey,
  height = 200,
  className,
}: {
  data: any[]
  dataKey: string
  categoryKey?: string
  height?: number
  className?: string
}) {
  const { accent } = useTheme();
  
  // Get accent-specific fill color
  const getFillColor = () => {
    switch (accent) {
      case 'blue': return "#3B82F6";
      case 'green': return "#10B981";
      case 'purple': return "#8B5CF6";
      case 'orange': return "#F97316";
      default: return "#6B7280"; // grayscale
    }
  };
  
  return (
    <div className={className}>
      <ResponsiveContainer width="100%" height={height}>
        <BarChart data={data}>
          <CartesianGrid strokeDasharray="3 3" opacity={0.2} />
          <XAxis dataKey="name" />
          <YAxis />
          <Tooltip />
          <Bar dataKey={dataKey} fill={getFillColor()} radius={[4, 4, 0, 0]} />
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}

============================================================

FILE: .\components\ui\checkbox.tsx
SIZE: 1.07 KB
LAST MODIFIED: 03/07/2025 17:11:30

"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

============================================================

FILE: .\components\ui\dialog.tsx
SIZE: 4.78 KB
LAST MODIFIED: 02/09/2025 15:31:45

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-700 bg-gray-800 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-gray-800 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-gray-700 data-[state=open]:text-gray-400">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-400", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

/* Example usage:
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function DialogDemo() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="outline">Edit Profile</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit profile</DialogTitle>
          <DialogDescription>
            Make changes to your profile here.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          Form content here
        </div>
        <DialogFooter>
          <Button type="submit">Save changes</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
*/

============================================================

FILE: .\components\ui\difficulty-indicator.tsx
SIZE: 2 KB
LAST MODIFIED: 03/23/2025 16:06:36

import React from 'react';
import { cn } from '@/lib/utils';
import { useTheme } from '@/providers/ThemeContext';

interface DifficultyIndicatorProps extends React.HTMLAttributes<HTMLDivElement> {
  difficulty: number;
}

const DifficultyIndicator = React.forwardRef<HTMLDivElement, DifficultyIndicatorProps>(
  ({ difficulty, className, ...props }, ref) => {
    const { accent } = useTheme();
    
    // Get accent-specific background colors
    const getAccentBackground = () => {
      switch (accent) {
        case 'blue':
          return 'bg-blue-500';
        case 'green':
          return 'bg-emerald-500';
        case 'purple':
          return 'bg-purple-500';
        case 'orange':
          return 'bg-orange-500';
        default: // grayscale
          return 'bg-gray-500';
      }
    };
    
    // Get intensity-based styles for difficulty
    const getDifficultyStyle = () => {
      const baseColor = getAccentBackground();
      
      switch (difficulty) {
        case 1: 
          return {
            width: 'w-1/3',
            opacity: 'opacity-50'
          };
        case 2: 
          return {
            width: 'w-2/3',
            opacity: 'opacity-75'
          };
        case 3: 
          return {
            width: 'w-full',
            opacity: 'opacity-100'
          };
        default:
          return {
            width: 'w-0',
            opacity: 'opacity-0'
          };
      }
    };
    
    const diffStyle = getDifficultyStyle();
    
    return (
      <div 
        ref={ref} 
        className={cn("w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700", className)}
        {...props}
      >
        <div className={cn(
          diffStyle.width,
          diffStyle.opacity,
          "h-2.5 rounded-full transition-all duration-300",
          getAccentBackground()
        )} />
      </div>
    );
  }
);

DifficultyIndicator.displayName = "DifficultyIndicator";

export { DifficultyIndicator };

============================================================

FILE: .\components\ui\dropdown-menu.tsx
SIZE: 7.37 KB
LAST MODIFIED: 03/07/2025 08:43:08

// components/ui/dropdown-menu.tsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

============================================================

FILE: .\components\ui\input.tsx
SIZE: 0.75 KB
LAST MODIFIED: 03/04/2025 21:21:03

import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


============================================================

FILE: .\components\ui\label.tsx
SIZE: 0.71 KB
LAST MODIFIED: 03/04/2025 21:21:19

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


============================================================

FILE: .\components\ui\pagination.tsx
SIZE: 2.34 KB
LAST MODIFIED: 03/21/2025 09:25:13

// components/ui/pagination.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '@/lib/utils';

export interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  className?: string;
}

export function Pagination({
  currentPage,
  totalPages,
  onPageChange,
  className,
}: PaginationProps) {
  const pages = [];
  
  // Calculate which page numbers to display
  const maxPages = 5;
  let startPage: number, endPage: number;
  
  if (totalPages <= maxPages) {
    // Less than max pages, show all
    startPage = 1;
    endPage = totalPages;
  } else {
    // More than max pages, calculate which to show
    const maxPagesBeforeCurrentPage = Math.floor(maxPages / 2);
    const maxPagesAfterCurrentPage = Math.ceil(maxPages / 2) - 1;
    
    if (currentPage <= maxPagesBeforeCurrentPage) {
      // Near the start
      startPage = 1;
      endPage = maxPages;
    } else if (currentPage + maxPagesAfterCurrentPage >= totalPages) {
      // Near the end
      startPage = totalPages - maxPages + 1;
      endPage = totalPages;
    } else {
      // Middle
      startPage = currentPage - maxPagesBeforeCurrentPage;
      endPage = currentPage + maxPagesAfterCurrentPage;
    }
  }
  
  // Generate page numbers
  for (let i = startPage; i <= endPage; i++) {
    pages.push(i);
  }
  
  return (
    <div className={cn("flex justify-center items-center space-x-2", className)}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
      >
        <ChevronLeft className="h-4 w-4" />
      </Button>
      
      {pages.map((page) => (
        <Button
          key={page}
          variant={currentPage === page ? "default" : "outline"}
          size="sm"
          onClick={() => onPageChange(page)}
          disabled={currentPage === page}
        >
          {page}
        </Button>
      ))}
      
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
      >
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
}

============================================================

FILE: .\components\ui\pill-tabs.tsx
SIZE: 6 KB
LAST MODIFIED: 03/23/2025 16:11:55

'use client';

import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import { cn } from '@/lib/utils';
import { useTheme } from '@/providers/ThemeContext';

interface PillTabsProps {
  tabs: Array<{
    value: string;
    label: string;
  }>;
  activeTab: string;
  onTabChange: (value: string) => void;
  className?: string;
}

export function PillTabs({ tabs, activeTab, onTabChange, className }: PillTabsProps) {
  const { accent } = useTheme();
  
  // Get accent-specific colors
  const getAccentStyles = () => {
    switch (accent) {
      case 'blue':
        return {
          active: 'bg-blue-100 text-blue-900 dark:bg-blue-800/30 dark:text-blue-100',
          inactive: 'text-muted-foreground hover:text-blue-900 dark:hover:text-blue-300'
        };
      case 'green':
        return {
          active: 'bg-emerald-100 text-emerald-900 dark:bg-emerald-800/30 dark:text-emerald-100',
          inactive: 'text-muted-foreground hover:text-emerald-900 dark:hover:text-emerald-300'
        };
      case 'purple':
        return {
          active: 'bg-purple-100 text-purple-900 dark:bg-purple-800/30 dark:text-purple-100',
          inactive: 'text-muted-foreground hover:text-purple-900 dark:hover:text-purple-300'
        };
      case 'orange':
        return {
          active: 'bg-orange-100 text-orange-900 dark:bg-orange-800/30 dark:text-orange-100',
          inactive: 'text-muted-foreground hover:text-orange-900 dark:hover:text-orange-300'
        };
      default: // grayscale
        return {
          active: 'bg-muted text-foreground',
          inactive: 'text-muted-foreground hover:text-foreground'
        };
    }
  };
  
  const styles = getAccentStyles();

  return (
    <div className={cn("relative overflow-auto", className)}>
      <div className="flex items-center">
        {tabs.map((tab) => (
          <button
            key={tab.value}
            onClick={() => onTabChange(tab.value)}
            className={cn(
              "flex h-9 items-center justify-center rounded-full px-4 text-center text-sm font-medium transition-colors",
              activeTab === tab.value
                ? styles.active
                : styles.inactive
            )}
          >
            {tab.label}
          </button>
        ))}
      </div>
    </div>
  );
}

interface PillTabsContentProps {
  value: string;
  activeTab: string;
  children: React.ReactNode;
  className?: string;
}

export function PillTabsContent({ value, activeTab, children, className }: PillTabsContentProps) {
  if (value !== activeTab) return null;
  
  return (
    <div className={cn("mt-4", className)}>
      {children}
    </div>
  );
}

// Standard tabs component with accent colors
export function Tabs({ defaultValue, value, onValueChange, className, children, ...props }: TabsPrimitive.TabsProps) {
  return (
    <TabsPrimitive.Root
      defaultValue={defaultValue}
      value={value}
      onValueChange={onValueChange}
      className={cn("w-full", className)}
      {...props}
    >
      {children}
    </TabsPrimitive.Root>
  );
}

export function TabsList({ className, children, ...props }: TabsPrimitive.TabsListProps) {
  const { accent } = useTheme();
  
  // Get accent-specific background
  const getBackgroundClass = () => {
    switch (accent) {
      case 'blue':
        return 'bg-blue-100/50 dark:bg-blue-900/20';
      case 'green':
        return 'bg-emerald-100/50 dark:bg-emerald-900/20';
      case 'purple':
        return 'bg-purple-100/50 dark:bg-purple-900/20';
      case 'orange':
        return 'bg-orange-100/50 dark:bg-orange-900/20';
      default: // grayscale
        return 'bg-muted';
    }
  };

  return (
    <TabsPrimitive.List
      className={cn(
        "inline-flex h-10 items-center justify-center rounded-md p-1 text-muted-foreground",
        getBackgroundClass(),
        className
      )}
      {...props}
    >
      {children}
    </TabsPrimitive.List>
  );
}

export function TabsTrigger({ className, children, ...props }: TabsPrimitive.TabsTriggerProps) {
  const { accent } = useTheme();
  
  // Get accent-specific active state
  const getActiveClass = () => {
    switch (accent) {
      case 'blue':
        return 'data-[state=active]:bg-white data-[state=active]:text-blue-700 dark:data-[state=active]:bg-gray-800 dark:data-[state=active]:text-blue-400';
      case 'green':
        return 'data-[state=active]:bg-white data-[state=active]:text-emerald-700 dark:data-[state=active]:bg-gray-800 dark:data-[state=active]:text-emerald-400';
      case 'purple':
        return 'data-[state=active]:bg-white data-[state=active]:text-purple-700 dark:data-[state=active]:bg-gray-800 dark:data-[state=active]:text-purple-400';
      case 'orange':
        return 'data-[state=active]:bg-white data-[state=active]:text-orange-700 dark:data-[state=active]:bg-gray-800 dark:data-[state=active]:text-orange-400';
      default: // grayscale
        return 'data-[state=active]:bg-background data-[state=active]:text-foreground';
    }
  };

  return (
    <TabsPrimitive.Trigger
      className={cn(
        "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
        getActiveClass(),
        "data-[state=active]:shadow-sm",
        className
      )}
      {...props}
    >
      {children}
    </TabsPrimitive.Trigger>
  );
}

export function TabsContent({ className, children, ...props }: TabsPrimitive.TabsContentProps) {
  return (
    <TabsPrimitive.Content
      className={cn(
        "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
        className
      )}
      {...props}
    >
      {children}
    </TabsPrimitive.Content>
  );
}

============================================================

FILE: .\components\ui\select.tsx
SIZE: 5.51 KB
LAST MODIFIED: 03/04/2025 21:25:38

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


============================================================

FILE: .\components\ui\stat-card.tsx
SIZE: 1.61 KB
LAST MODIFIED: 03/04/2025 21:07:38

// components/ui/stat-card.tsx
import React from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { cn } from "@/lib/utils"

interface StatCardProps extends React.HTMLAttributes<HTMLDivElement> {
  title: string
  value: string | number
  description?: string
  icon?: React.ReactNode
  trend?: {
    value: number
    label: string
    direction: "up" | "down" | "neutral"
  }
}

export function StatCard({
  title,
  value,
  description,
  icon,
  trend,
  className,
  ...props
}: StatCardProps) {
  const trendColors = {
    up: "text-green-500",
    down: "text-red-500",
    neutral: "text-gray-500",
  }

  return (
    <Card className={cn("overflow-hidden", className)} {...props}>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        {icon && <div className="h-4 w-4 text-muted-foreground">{icon}</div>}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground">{description}</p>
        )}
        {trend && (
          <div className={cn("flex items-center text-xs mt-1", trendColors[trend.direction])}>
            {trend.direction === "up" ? "â†‘" : trend.direction === "down" ? "â†“" : "â†’"}
            <span className="ml-1">{trend.value}%</span>
            <span className="ml-1 text-muted-foreground">{trend.label}</span>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

============================================================

FILE: .\components\ui\table.tsx
SIZE: 2.79 KB
LAST MODIFIED: 03/04/2025 21:21:35

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


============================================================

FILE: .\components\ui\tabs.tsx
SIZE: 1.88 KB
LAST MODIFIED: 03/12/2025 09:01:44

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

============================================================

FILE: .\components\ui\tags.tsx
SIZE: 1.97 KB
LAST MODIFIED: 03/23/2025 16:06:56

import React from 'react';
import { cn } from '@/lib/utils';
import { useTheme } from '@/providers/ThemeContext';

interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
  className?: string;
}

const TagDisplay: React.FC<TagDisplayProps> = ({ 
  tags, 
  onClick,
  className
}) => {
  const { accent } = useTheme();
  
  // Skip rendering if no tags
  if (!tags) return null;
  
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  if (tagArray.length === 0) return null;
  
  // Get accent-specific tag colors
  const getTagColors = () => {
    switch (accent) {
      case 'blue':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300 hover:bg-blue-200 dark:hover:bg-blue-800';
      case 'green':
        return 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300 hover:bg-green-200 dark:hover:bg-green-800';
      case 'purple':
        return 'bg-purple-100 text-purple-800 dark:bg-purple-900/30 dark:text-purple-300 hover:bg-purple-200 dark:hover:bg-purple-800';
      case 'orange':
        return 'bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-300 hover:bg-orange-200 dark:hover:bg-orange-800';
      default: // grayscale
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600';
    }
  };
  
  const tagColors = getTagColors();
  
  return (
    <div className={cn("flex flex-wrap gap-1", className)}>
      {tagArray.map((tag, idx) => (
        <button
          key={`${tag}-${idx}`}
          onClick={() => onClick?.(tag)}
          className={cn(
            "px-2 py-0.5 text-xs rounded-full",
            tagColors,
            onClick ? "cursor-pointer" : "cursor-default",
            "transition-colors duration-150",
            className
          )}
        >
          {tag}
        </button>
      ))}
    </div>
  );
};

export default TagDisplay;

============================================================

FILE: .\components\ui\toast.tsx
SIZE: 4.88 KB
LAST MODIFIED: 03/22/2025 23:31:45

import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border-gray-700 bg-gray-800 text-white",
        destructive: "destructive group border-red-700 bg-red-900 text-red-100",
        success: "border-green-700 bg-green-900 text-green-100",
        warning: "border-yellow-700 bg-yellow-900 text-yellow-100",
        info: "border-blue-700 bg-blue-900 text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-gray-700 bg-transparent px-3 text-sm font-medium transition-colors hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-red-700 group-[.destructive]:hover:border-red-600 group-[.destructive]:hover:bg-red-600 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-white/50 opacity-0 transition-opacity hover:text-white focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

============================================================

FILE: .\components\ui\toaster.tsx
SIZE: 1.3 KB
LAST MODIFIED: 02/09/2025 10:39:36

import {
    Toast,
    ToastClose,
    ToastDescription,
    ToastProvider,
    ToastTitle,
    ToastViewport,
  } from "@/components/ui/toast";
  import { useToast } from "@/hooks/useToast";
  
  export function Toaster() {
    const { toasts } = useToast();
  
    return (
      <ToastProvider>
        {toasts.map(function ({ id, title, description, action, ...props }) {
          return (
            <Toast key={id} {...props}>
              <div className="grid gap-1">
                {title && <ToastTitle>{title}</ToastTitle>}
                {description && (
                  <ToastDescription>{description}</ToastDescription>
                )}
              </div>
              {action}
              <ToastClose />
            </Toast>
          );
        })}
        <ToastViewport />
      </ToastProvider>
    );
  }
  
  // Example usage:
  /*
  import { useToast } from '@/hooks/useToast';
  
  function MyComponent() {
    const { toast } = useToast();
    
    const showToast = () => {
      toast({
        title: "Success!",
        description: "Your action was completed successfully.",
        variant: "success", // or "default", "destructive", "warning", "info"
      });
    };
  
    return <button onClick={showToast}>Show Toast</button>;
  }
  */

============================================================

FILE: .\components\ui\theme\AccentDemo.tsx
SIZE: 3.37 KB
LAST MODIFIED: 03/23/2025 16:13:08

// components/ui/theme/AccentDemo.tsx
'use client';

import React from 'react';
import { useTheme } from '@/providers/ThemeContext';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { cn } from '@/lib/utils';

export function AccentDemo() {
  const { accent } = useTheme();
  
  const accentLabels = {
    'default': 'Grayscale',
    'blue': 'Blue',
    'green': 'Green',
    'purple': 'Purple',
    'orange': 'Orange'
  };
  
  return (
    <Card className="mt-4">
      <CardHeader>
        <CardTitle>Accent Color Demo - {accentLabels[accent]}</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div 
            className="h-16 rounded flex items-center justify-center text-white font-medium"
            style={{ backgroundColor: 'var(--accent-color)' }}
          >
            Accent Color
          </div>
          <div 
            className="h-16 rounded flex items-center justify-center text-accent-foreground font-medium"
            style={{ backgroundColor: 'var(--accent-muted)' }}
          >
            Accent Muted
          </div>
          <div 
            className="h-16 rounded bg-background flex items-center justify-center border"
            style={{ color: 'var(--accent-color)' }}
          >
            Text in Accent
          </div>
          <div 
            className="h-16 rounded flex items-center justify-center text-white font-medium"
            style={{ 
              background: 'linear-gradient(to right, var(--accent-muted), var(--accent-color))' 
            }}
          >
            Accent Gradient
          </div>
        </div>
        
        <div className="mt-4">
          <h3 className="font-medium mb-2">Chart Colors:</h3>
          <div className="grid grid-cols-5 gap-2 h-8">
            {[1, 2, 3, 4, 5].map((i) => (
              <div 
                key={i}
                className="rounded"
                style={{ backgroundColor: `hsl(var(--chart-${i}))` }}
              />
            ))}
          </div>
        </div>
        
        <button 
          className="px-4 py-2 rounded text-white"
          style={{ backgroundColor: 'var(--accent-color)' }}
        >
          Accent Button
        </button>
        
        <div className="grid grid-cols-5 gap-4 mt-4">
          <Card className={cn("p-4 text-center border-2", accent === 'default' ? 'border-gray-500' : '')}>
            <div className="font-medium">Default</div>
          </Card>
          <Card className={cn("p-4 text-center border-2", accent === 'blue' ? 'border-blue-500' : '')}>
            <div className="font-medium">Blue</div>
          </Card>
          <Card className={cn("p-4 text-center border-2", accent === 'green' ? 'border-green-500' : '')}>
            <div className="font-medium">Green</div>
          </Card>
          <Card className={cn("p-4 text-center border-2", accent === 'purple' ? 'border-purple-500' : '')}>
            <div className="font-medium">Purple</div>
          </Card>
          <Card className={cn("p-4 text-center border-2", accent === 'orange' ? 'border-orange-500' : '')}>
            <div className="font-medium">Orange</div>
          </Card>
        </div>
      </CardContent>
    </Card>
  );
}

export default AccentDemo;

============================================================

FILE: .\components\ui\theme\ThemeSwitcher.tsx
SIZE: 3.72 KB
LAST MODIFIED: 03/23/2025 16:00:08

// components/ui/theme/ThemeSwitcher.tsx
'use client';

import React from 'react';
import { Button } from '@/components/ui/button';
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuTrigger, 
  DropdownMenuSeparator 
} from '@/components/ui/dropdown-menu';
import { Moon, Sun, Monitor, Palette } from 'lucide-react';
import { useTheme } from '@/providers/ThemeContext';

interface ThemeSwitcherProps {
  showAccentColors?: boolean;
}

export function ThemeSwitcher({ showAccentColors = false }: ThemeSwitcherProps) {
  const { theme, setTheme, accent, setAccent } = useTheme();
  
  console.log('Current theme state:', { theme, accent });
  
  const handleThemeChange = (newTheme: string) => {
    console.log('Setting theme to:', newTheme);
    setTheme(newTheme);
  };
  
  // Fix the type to match the ColorAccent type
  const handleAccentChange = (newAccent: 'default' | 'blue' | 'green' | 'purple' | 'orange') => {
    console.log('Setting accent to:', newAccent);
    setAccent(newAccent);
  };
  
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon" className="h-9 w-9 rounded-md">
          {theme === 'dark' ? (
            <Moon className="h-4 w-4" />
          ) : theme === 'light' ? (
            <Sun className="h-4 w-4" />
          ) : (
            <Monitor className="h-4 w-4" />
          )}
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => handleThemeChange('light')}>
          <Sun className="mr-2 h-4 w-4" />
          <span>Light</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleThemeChange('dark')}>
          <Moon className="mr-2 h-4 w-4" />
          <span>Dark</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleThemeChange('system')}>
          <Monitor className="mr-2 h-4 w-4" />
          <span>System</span>
        </DropdownMenuItem>
        
        {showAccentColors && (
          <>
            <DropdownMenuSeparator />
            <DropdownMenuItem disabled>
              <Palette className="mr-2 h-4 w-4" />
              <span>Accent Colors</span>
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => handleAccentChange('default')}
              className="pl-8"
            >
              <div className="mr-2 h-4 w-4 rounded-full bg-gray-500" />
              <span>Grayscale (Default)</span>
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => handleAccentChange('blue')}
              className="pl-8"
            >
              <div className="mr-2 h-4 w-4 rounded-full bg-blue-500" />
              <span>Blue</span>
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => handleAccentChange('green')}
              className="pl-8"
            >
              <div className="mr-2 h-4 w-4 rounded-full bg-green-500" />
              <span>Green</span>
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => handleAccentChange('purple')}
              className="pl-8"
            >
              <div className="mr-2 h-4 w-4 rounded-full bg-purple-500" />
              <span>Purple</span>
            </DropdownMenuItem>
            <DropdownMenuItem 
              onClick={() => handleAccentChange('orange')}
              className="pl-8"
            >
              <div className="mr-2 h-4 w-4 rounded-full bg-orange-500" />
              <span>Orange</span>
            </DropdownMenuItem>
          </>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export default ThemeSwitcher;

============================================================

FILE: .\features\auth\PinPad.tsx
SIZE: 2.47 KB
LAST MODIFIED: 03/17/2025 09:58:57

'use client';

import * as React from 'react';
import { Button } from '@/components/ui/button';

interface PinPadProps {
  onSubmit: (pin: string) => void;
  onCancel: () => void;
}

export default function PinPad({ onSubmit, onCancel }: PinPadProps) {
  const [pin, setPin] = React.useState('');
  const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'X', '0', 'â†'];

  function handleClick(num: string) {
    if (num === 'â†') {
      setPin((prev) => prev.slice(0, -1));
    } else if (num === 'X') {
      onCancel();
    } else if (pin.length < 4 && /\d/.test(num)) {
      setPin((prev) => prev + num);
    }
  }

  React.useEffect(() => {
    if (pin.length === 4) {
      onSubmit(pin);
      setPin('');
    }
  }, [pin, onSubmit]);

  return (
    <div className="flex flex-col items-center gap-8 w-full max-w-[320px] py-4">
      <div className="flex gap-3 justify-center">
        {[...Array(4)].map((_, i) => (
          <div
            key={i}
            className={`w-5 h-5 rounded-full ${
              pin.length > i ? 'bg-white' : 'bg-neutral-700'
            }`}
          />
        ))}
      </div>
      
      <div className="grid grid-cols-3 gap-4 w-full">
        {numbers.map((num, idx) => {
          // Special styling for cancel (X) and backspace buttons
          if (num === 'X' || num === 'â†') {
            return (
              <Button
                key={idx}
                variant="ghost"
                className={`h-14 text-xl ${
                  num === 'X' 
                    ? 'text-neutral-400 hover:text-white hover:bg-neutral-800' 
                    : 'text-neutral-300 hover:text-white hover:bg-neutral-800'
                }`}
                onClick={() => handleClick(num)}
              >
                {num}
              </Button>
            );
          }
          
          // Number buttons
          return (
            <Button
              key={idx}
              variant="ghost"
              className="h-14 text-xl font-medium text-neutral-200 hover:bg-neutral-800 hover:text-white"
              onClick={() => handleClick(num)}
            >
              {num}
            </Button>
          );
        })}
      </div>
      
      <Button 
        variant="outline" 
        className="mt-4 border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white"
        onClick={onCancel}
      >
        Back
      </Button>
    </div>
  );
}

============================================================

FILE: .\features\auth\ReviewerLoginButton.tsx
SIZE: 1.01 KB
LAST MODIFIED: 03/22/2025 22:17:12

'use client';

import * as React from 'react';
import { Button } from '@/components/ui/button';
import { ReviewerLoginModal } from './ReviewerLoginModal';


interface ReviewerLoginButtonProps {
  onLoginSuccess?: (reviewer: Reviewer) => void;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  className?: string;
}

export function ReviewerLoginButton({ 
  onLoginSuccess, 
  variant = 'outline',
  className = '' 
}: ReviewerLoginButtonProps) {
  const [open, setOpen] = React.useState(false);

  const handleLoginSuccess = (reviewer: Reviewer) => {
    setOpen(false);
    if (onLoginSuccess) {
      onLoginSuccess(reviewer);
    }
  };

  return (
    <>
      <Button 
        onClick={() => setOpen(true)} 
        variant={variant} 
        className={className}
      >
        Login
      </Button>
      <ReviewerLoginModal
        open={open}
        onClose={() => setOpen(false)}
        onLoginSuccess={handleLoginSuccess}
      />
    </>
  );
}

============================================================

FILE: .\features\auth\ReviewerLoginModal.tsx
SIZE: 4.96 KB
LAST MODIFIED: 03/22/2025 22:17:43

'use client';

import * as React from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { supabase } from '@/lib/services/supabase';
import PinPad from './PinPad';


interface ReviewerLoginModalProps {
  open: boolean;
  onClose: () => void;
  onLoginSuccess: (reviewer: Reviewer) => void;
}

// Avatar icons for reviewers - desaturated colors
const AVATAR_EMOJIS = ['ðŸ™', 'ðŸˆ', 'ðŸ•', 'ðŸ’', 'ðŸ¢', 'ðŸ£', 'ðŸ¦Š', 'ðŸ¼'];
const AVATAR_COLORS = [
  'from-orange-400/80 to-amber-400/80', // Desaturated Orange/Gold
  'from-red-500/80 to-red-600/80',      // Desaturated Red
  'from-emerald-400/80 to-teal-400/80', // Desaturated Green
  'from-purple-500/80 to-blue-400/80',  // Desaturated Purple/Blue
  'from-blue-400/80 to-cyan-300/80',    // Desaturated Blue
  'from-rose-400/80 to-pink-400/80',    // Desaturated Pink
  'from-amber-300/80 to-yellow-200/80', // Desaturated Yellow
  'from-slate-500/80 to-slate-700/80',  // Desaturated Gray
];

export function ReviewerLoginModal({
  open,
  onClose,
  onLoginSuccess
}: ReviewerLoginModalProps) {
  const [reviewers, setReviewers] = React.useState<Reviewer[]>([]);
  const [selectedReviewer, setSelectedReviewer] = React.useState<Reviewer | null>(null);
  const [error, setError] = React.useState<string | null>(null);
  const [showPinPad, setShowPinPad] = React.useState(false);

  React.useEffect(() => {
    if (open) {
      fetchReviewers();
      setError(null);
      setSelectedReviewer(null);
      setShowPinPad(false);
    }
  }, [open]);

  async function fetchReviewers() {
    try {
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });
      if (error) throw error;
      if (data) setReviewers(data);
    } catch (err: any) {
      console.error('Error fetching reviewers:', err);
      setError('Failed to load reviewers');
    }
  }

  async function handleSelectReviewer(reviewer: Reviewer) {
    setSelectedReviewer(reviewer);
    setShowPinPad(true);
    setError(null);
  }

  async function handlePinSubmit(pin: string) {
    if (!selectedReviewer) return;
    setError(null);

    const { data, error } = await supabase
      .from('reviewers')
      .select('*')
      .eq('id', selectedReviewer.id)
      .eq('pin', pin)
      .maybeSingle();

    if (error) {
      setError('Database error checking PIN');
      return;
    }
    if (!data) {
      setError('Incorrect PIN');
      return;
    }

    onLoginSuccess(selectedReviewer);
    onClose();
  }

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[700px] bg-black border-neutral-800">
        <DialogHeader className="mb-6">
          <DialogTitle className="text-3xl font-medium text-center text-white">
            {!showPinPad ? "Who's reviewing?" : `Enter PIN for ${selectedReviewer?.name}`}
          </DialogTitle>
        </DialogHeader>

        {error && (
          <div className="mb-6 rounded bg-neutral-900 text-neutral-300 p-3 text-center border border-neutral-700">
            {error}
          </div>
        )}

        {!showPinPad ? (
          <div className="flex flex-col items-center">
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-6 mb-8">
              {reviewers.map((rev, index) => (
                <button
                  key={rev.id}
                  onClick={() => handleSelectReviewer(rev)}
                  className="flex flex-col items-center gap-3 transition-transform hover:scale-110 focus:outline-none"
                >
                  <div 
                    className={`w-28 h-28 rounded-md flex items-center justify-center overflow-hidden bg-gradient-to-b ${AVATAR_COLORS[index % AVATAR_COLORS.length]}`}
                  >
                    <div className="text-[3rem] transform scale-150">
                      {AVATAR_EMOJIS[index % AVATAR_EMOJIS.length]}
                    </div>
                  </div>
                  <span className="text-neutral-300 text-sm">{rev.name}</span>
                </button>
              ))}
            </div>
            
            <Button 
              variant="outline" 
              className="border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white mt-4"
              onClick={onClose}
            >
              Cancel
            </Button>
          </div>
        ) : (
          <div className="flex flex-col items-center">
            <PinPad
              onSubmit={handlePinSubmit}
              onCancel={() => {
                setShowPinPad(false);
                setError(null);
                setSelectedReviewer(null);
              }}
            />
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}

============================================================

FILE: .\features\auth\ReviewerProfileDropdown.tsx
SIZE: 3.32 KB
LAST MODIFIED: 03/22/2025 22:17:23

'use client';

import * as React from 'react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ChevronDown, LogOut, FileDownIcon, Plus, CheckSquare } from "lucide-react";

// Avatar icons for reviewers (should match those in ReviewerLoginModal)
const AVATAR_EMOJIS = ['ðŸ™', 'ðŸˆ', 'ðŸ•', 'ðŸ’', 'ðŸ¢', 'ðŸ£', 'ðŸ¦Š', 'ðŸ¼'];
const AVATAR_COLORS = [
  'from-orange-400/80 to-amber-400/80', // Desaturated Orange/Gold
  'from-red-500/80 to-red-600/80',      // Desaturated Red
  'from-emerald-400/80 to-teal-400/80', // Desaturated Green
  'from-purple-500/80 to-blue-400/80',  // Desaturated Purple/Blue
  'from-blue-400/80 to-cyan-300/80',    // Desaturated Blue
  'from-rose-400/80 to-pink-400/80',    // Desaturated Pink
  'from-amber-300/80 to-yellow-200/80', // Desaturated Yellow
  'from-slate-500/80 to-slate-700/80',  // Desaturated Gray
];

interface ReviewerProfileDropdownProps {
  reviewer: Reviewer;
  reviewerIndex: number; // To determine the emoji and color
  onLogout: () => void;
  onExportClick: () => void;
  onAddWordsClick: () => void;
  onReviewWordsClick: () => void;
}

export function ReviewerProfileDropdown({
  reviewer,
  reviewerIndex = 0,
  onLogout,
  onExportClick,
  onAddWordsClick,
  onReviewWordsClick
}: ReviewerProfileDropdownProps) {
  const avatarEmoji = AVATAR_EMOJIS[reviewerIndex % AVATAR_EMOJIS.length];
  const avatarColor = AVATAR_COLORS[reviewerIndex % AVATAR_COLORS.length];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger className="flex items-center gap-2 outline-none">
        <div className={`w-9 h-9 rounded-full flex items-center justify-center overflow-hidden bg-gradient-to-b ${avatarColor}`}>
          <div className="text-2xl transform scale-150 translate-y-1">
            {avatarEmoji}
          </div>
        </div>
        <span className="text-sm text-white hidden sm:inline-block">{reviewer.name}</span>
        <ChevronDown className="h-4 w-4 text-muted-foreground" />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col">
            <span>{reviewer.name}</span>
            <span className="text-xs text-muted-foreground">{reviewer.total_reviews || 0} reviews</span>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem className="cursor-pointer" onClick={onAddWordsClick}>
          <Plus className="mr-2 h-4 w-4" />
          <span>Add Words</span>
        </DropdownMenuItem>
        <DropdownMenuItem className="cursor-pointer" onClick={onReviewWordsClick}>
          <CheckSquare className="mr-2 h-4 w-4" />
          <span>Review Words</span>
        </DropdownMenuItem>
        <DropdownMenuItem className="cursor-pointer" onClick={onExportClick}>
          <FileDownIcon className="mr-2 h-4 w-4" />
          <span>Export</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem className="cursor-pointer" onClick={onLogout}>
          <LogOut className="mr-2 h-4 w-4" />
          <span>Logout</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

============================================================

FILE: .\features\dashboard\Dashboard.tsx
SIZE: 5.64 KB
LAST MODIFIED: 03/23/2025 16:15:54

'use client';

import React from 'react';
import { useRouter } from 'next/navigation';

// Components
import { DashboardHeader } from '@/features/dashboard/components/DashboardHeader';
import { StatsCards } from '@/features/dashboard/components/StatsCards';
import { Toaster } from '@/components/ui/toaster';
import { ToastProvider } from '@/providers/ToastProvider';
import { PillTabs, PillTabsContent } from '@/components/ui/pill-tabs';
import FilterModal from '@/features/filters/FilterModal';
import ExportModal from '@/features/dashboard/components/ExportModal';
import WordCreatorModal from '@/features/phrases/WordCreatorModal';
import ReviewModal from '@/features/phrases/ReviewModal';
import AnalyticsSection from '@/features/dashboard/components/AnalyticsSection';
import { PhrasesSection } from './components/PhrasesSection';
import { AccentDemo } from '@/components/ui/theme/AccentDemo';

// Hooks
import { useTheme } from 'next-themes';
import { useDashboardState } from '@/features/dashboard/hooks/useDashboardState';
import { usePhraseMetadata } from '@/features/data/hooks/usePhraseMetadata';
import { useExport, type ExportOptions } from '@/features/dashboard/hooks/useExport';
import { useToast } from '@/hooks/useToast';

// Types
import type { Reviewer } from '@/types/types';

const Dashboard: React.FC = () => {
  const router = useRouter();
  const { theme, setTheme } = useTheme();
  
  // Use dashboard state hook for centralized state management
  const {
    activeTab, 
    setActiveTab,
    showWordCreatorModal, 
    setShowWordCreatorModal,
    showReviewModal, 
    setShowReviewModal,
    showFilterModal, 
    setShowFilterModal,
    showExportModal, 
    setShowExportModal,
    selectedPhraseId,
    setSelectedPhraseId,
    newIds, 
    setNewIds,
    currentReviewer,
    setCurrentReviewer, 
    isExporting: dashboardExporting,
    setIsExporting: setDashboardExporting,
    handleLoginSuccess,
    handleLogout,
    handleWordAdded
  } = useDashboardState();
  
  // Get metadata for filters
  const { categories, difficulties, partsOfSpeech } = usePhraseMetadata();

  /**
   * Handle adding words action
   */
  const handleAddWordsClick = () => {
    setShowWordCreatorModal(true);
  };
  
  /**
   * Handle review words action
   */
  const handleReviewWordsClick = () => {
    setShowReviewModal(true);
  };

  // Use the export hook for handling exports
  const { 
    exportPhrases, 
    downloadExport, 
    isExporting 
  } = useExport();
  
  /**
   * Handle exporting data
   */
  const handleExport = async (options: ExportOptions) => {
    const exportData = await exportPhrases(options);
    
    if (exportData) {
      downloadExport(exportData, options);
      return exportData;
    }
    
    return null;
  };

  return (
    <ToastProvider>
      <div className="container mx-auto py-6 space-y-6">
        {/* Header Component */}
      <DashboardHeader
        theme={theme}
        setTheme={setTheme}
        onExportClick={() => setShowExportModal(true)}
        currentReviewer={currentReviewer}
        onLoginSuccess={handleLoginSuccess}
        onLogout={handleLogout}
        onAddWordsClick={handleAddWordsClick}
        onReviewWordsClick={handleReviewWordsClick}
      />

      {/* Stats Cards */}
      <StatsCards />

      <div className="mb-6">
        {/* Modals */}
        {currentReviewer && (
          <>
            {/* Word Creator Modal */}
            <WordCreatorModal
              isOpen={showWordCreatorModal}
              onClose={() => setShowWordCreatorModal(false)}
              reviewer={currentReviewer}
              onWordAdded={handleWordAdded}
            />

            {/* Review Modal */}
            <ReviewModal
              isOpen={showReviewModal}
              onClose={() => {
                setShowReviewModal(false);
                setSelectedPhraseId(null);
              }}
              reviewer={currentReviewer}
              selectedPhraseId={selectedPhraseId}
            />
          </>
        )}

        {/* Main Tabs */}
        <PillTabs
          tabs={[
            { value: 'phrases', label: 'Phrases' },
            { value: 'analytics', label: 'Analytics' }
          ]}
          activeTab={activeTab}
          onTabChange={setActiveTab}
          className="py-3 border-dashed border-y"
        />

        {/* Phrases Tab */}
        <PillTabsContent value="phrases" activeTab={activeTab}>
          <PhrasesSection 
            newIds={newIds}
            onEdit={(id: number) => {
              setSelectedPhraseId(id);
              setShowReviewModal(true);
            }}
          />
        </PillTabsContent>

        {/* Analytics Tab */}
        <PillTabsContent value="analytics" activeTab={activeTab}>
          <AnalyticsSection />
        </PillTabsContent>
      </div>

      {/* Additional Modals */}
      <FilterModal
        isOpen={showFilterModal}
        onClose={() => setShowFilterModal(false)}
        filters={{
          searchTerm: '',
          category: '',
          difficulty: '',
          subcategory: '',
          part_of_speech: ''
        }}
        onChange={() => {}}
        onReset={() => {}}
        categories={categories}
        difficulties={difficulties}
        partsOfSpeech={partsOfSpeech}
        subcategories={[]}
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        onExport={handleExport}
        isLoading={isExporting}
      />
      
      </div>
    </ToastProvider>
  );
};

export default Dashboard;


============================================================

FILE: .\features\dashboard\Dashboard.tsx.bak
SIZE: 5.58 KB
LAST MODIFIED: 03/22/2025 23:54:27

'use client';

import React from 'react';
import { useRouter } from 'next/navigation';

// Components
import { DashboardHeader } from '@/features/dashboard/components/DashboardHeader';
import { StatsCards } from '@/features/dashboard/components/StatsCards';
import { Toaster } from '@/components/ui/toaster';
import { ToastProvider } from '@/providers/ToastProvider';
import { PillTabs, PillTabsContent } from '@/components/ui/pill-tabs';
import FilterModal from '@/features/filters/FilterModal';
import ExportModal from '@/features/dashboard/components/ExportModal';
import WordCreatorModal from '@/features/phrases/WordCreatorModal';
import ReviewModal from '@/features/phrases/ReviewModal';
import AnalyticsSection from '@/features/dashboard/components/AnalyticsSection';
import { PhrasesSection } from './components/PhrasesSection';

// Hooks
import { useTheme } from 'next-themes';
import { useDashboardState } from '@/features/dashboard/hooks/useDashboardState';
import { usePhraseMetadata } from '@/features/data/hooks/usePhraseMetadata';
import { useExport, type ExportOptions } from '@/features/dashboard/hooks/useExport';
import { useToast } from '@/hooks/useToast';

// Types
import type { Reviewer } from '@/types/types';

const Dashboard: React.FC = () => {
  const router = useRouter();
  const { theme, setTheme } = useTheme();
  
  // Use dashboard state hook for centralized state management
  const {
    activeTab, 
    setActiveTab,
    showWordCreatorModal, 
    setShowWordCreatorModal,
    showReviewModal, 
    setShowReviewModal,
    showFilterModal, 
    setShowFilterModal,
    showExportModal, 
    setShowExportModal,
    selectedPhraseId,
    setSelectedPhraseId,
    newIds, 
    setNewIds,
    currentReviewer,
    setCurrentReviewer, 
    isExporting: dashboardExporting,
    setIsExporting: setDashboardExporting,
    handleLoginSuccess,
    handleLogout,
    handleWordAdded
  } = useDashboardState();
  
  // Get metadata for filters
  const { categories, difficulties, partsOfSpeech } = usePhraseMetadata();

  /**
   * Handle adding words action
   */
  const handleAddWordsClick = () => {
    setShowWordCreatorModal(true);
  };
  
  /**
   * Handle review words action
   */
  const handleReviewWordsClick = () => {
    setShowReviewModal(true);
  };

  // Use the export hook for handling exports
  const { 
    exportPhrases, 
    downloadExport, 
    isExporting 
  } = useExport();
  
  /**
   * Handle exporting data
   */
  const handleExport = async (options: ExportOptions) => {
    const exportData = await exportPhrases(options);
    
    if (exportData) {
      downloadExport(exportData, options);
      return exportData;
    }
    
    return null;
  };

  return (
    <ToastProvider>
      <div className="container mx-auto py-6 space-y-6">
        {/* Header Component */}
      <DashboardHeader
        theme={theme}
        setTheme={setTheme}
        onExportClick={() => setShowExportModal(true)}
        currentReviewer={currentReviewer}
        onLoginSuccess={handleLoginSuccess}
        onLogout={handleLogout}
        onAddWordsClick={handleAddWordsClick}
        onReviewWordsClick={handleReviewWordsClick}
      />
    
      {/* Stats Cards */}
      <StatsCards />

      <div className="mb-6">
        {/* Modals */}
        {currentReviewer && (
          <>
            {/* Word Creator Modal */}
            <WordCreatorModal
              isOpen={showWordCreatorModal}
              onClose={() => setShowWordCreatorModal(false)}
              reviewer={currentReviewer}
              onWordAdded={handleWordAdded}
            />

            {/* Review Modal */}
            <ReviewModal
              isOpen={showReviewModal}
              onClose={() => {
                setShowReviewModal(false);
                setSelectedPhraseId(null);
              }}
              reviewer={currentReviewer}
              selectedPhraseId={selectedPhraseId}
            />
          </>
        )}

        {/* Main Tabs */}
        <PillTabs
          tabs={[
            { value: 'phrases', label: 'Phrases' },
            { value: 'analytics', label: 'Analytics' }
          ]}
          activeTab={activeTab}
          onTabChange={setActiveTab}
          className="py-3 border-dashed border-y"
        />

        {/* Phrases Tab */}
        <PillTabsContent value="phrases" activeTab={activeTab}>
          <PhrasesSection 
            newIds={newIds}
            onEdit={(id: number) => {
              setSelectedPhraseId(id);
              setShowReviewModal(true);
            }}
          />
        </PillTabsContent>

        {/* Analytics Tab */}
        <PillTabsContent value="analytics" activeTab={activeTab}>
          <AnalyticsSection />
        </PillTabsContent>
      </div>

      {/* Additional Modals */}
      <FilterModal
        isOpen={showFilterModal}
        onClose={() => setShowFilterModal(false)}
        filters={{
          searchTerm: '',
          category: '',
          difficulty: '',
          subcategory: '',
          part_of_speech: ''
        }}
        onChange={() => {}}
        onReset={() => {}}
        categories={categories}
        difficulties={difficulties}
        partsOfSpeech={partsOfSpeech}
        subcategories={[]}
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        onExport={handleExport}
        isLoading={isExporting}
      />
      
      </div>
    </ToastProvider>
  );
};

export default Dashboard;

============================================================

FILE: .\features\dashboard\types.ts
SIZE: 1.07 KB
LAST MODIFIED: 03/23/2025 00:00:23

// features/dashboard/types.ts
import type { Reviewer } from '@/types/types';
export interface DashboardStateHook {
  // Tab and Modal States
  activeTab: string;
  setActiveTab: (tab: string) => void;
  showWordCreatorModal: boolean;
  setShowWordCreatorModal: (show: boolean) => void;
  showReviewModal: boolean;
  setShowReviewModal: (show: boolean) => void;
  showFilterModal: boolean;
  setShowFilterModal: (show: boolean) => void;
  showExportModal: boolean;
  setShowExportModal: (show: boolean) => void;
  
  // Data States
  selectedPhraseId: number | null;
  setSelectedPhraseId: (id: number | null) => void;
  newIds: number[];
  setNewIds: (ids: number[]) => void;
  dateRange: number;
  updateDateRange: (days: number) => void;
  currentReviewer: Reviewer | null;
  isExporting: boolean;
  setIsExporting: (isExporting: boolean) => void;
  
  // Loading States
  isLoading: boolean;
  error: string | null;
  
  // Handlers
  handleLoginSuccess: (reviewer: Reviewer) => void;
  handleLogout: () => void;
  handleWordAdded: (id: number) => void;
}

============================================================

FILE: .\features\dashboard\components\AnalyticsSection.tsx
SIZE: 13.83 KB
LAST MODIFIED: 03/23/2025 16:13:35

// features/dashboard/components/AnalyticsSection/AnalyticsSection.tsx
import React, { useState, useEffect } from 'react';
import { useTheme } from '@/providers/ThemeContext';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import {
  PieChart, Pie, Cell, BarChart, Bar, 
  ResponsiveContainer, Tooltip, Legend, XAxis, YAxis, CartesianGrid
} from 'recharts';
import { supabase } from '@/lib/services/supabase';
import { cn } from '@/lib/utils';

export const AnalyticsSection = () => {
  const [categoryData, setCategoryData] = useState([]);
  const [difficultyData, setDifficultyData] = useState([]);
  const [phrasesAdded, setPhrasesAdded] = useState(0);
  const [reviewsCompleted, setReviewsCompleted] = useState(0);
  const [loading, setLoading] = useState(true);
  const { accent } = useTheme();

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        // Fetch categories data
        const { data: categoriesData, error: categoriesError } = await supabase
          .from('phrases')
          .select('category_id, categories:category_id(name)');

        if (categoriesError) throw categoriesError;

        // Count frequency of each category
        const categoryCounts = {};
        categoriesData.forEach(item => {
          const categoryName = item.categories?.name || 'Uncategorized';
          categoryCounts[categoryName] = (categoryCounts[categoryName] || 0) + 1;
        });

        // Convert to array format for Bar Chart and sort by value (descending)
        const categoryDataArray = Object.entries(categoryCounts)
          .map(([name, value]) => ({ name, value }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 10); // Take top 10 categories for better visualization

        setCategoryData(categoryDataArray);

        // Fetch difficulty data
        const { data: difficultyRawData, error: difficultyError } = await supabase
          .from('phrases')
          .select('difficulty');

        if (difficultyError) throw difficultyError;

        // Count frequency of each difficulty level
        const difficultyCounts = { 'Easy': 0, 'Medium': 0, 'Hard': 0 };
        difficultyRawData.forEach(item => {
          const diffLevel = item.difficulty === 1 ? 'Easy' : 
                           item.difficulty === 2 ? 'Medium' : 
                           item.difficulty === 3 ? 'Hard' : 'Unknown';
          difficultyCounts[diffLevel] = (difficultyCounts[diffLevel] || 0) + 1;
        });

        // Convert to array format for PieChart
        const difficultyDataArray = Object.entries(difficultyCounts).map(([name, value]) => ({
          name,
          value
        }));

        setDifficultyData(difficultyDataArray);

        // Get phrases added this month
        const firstDayOfMonth = new Date();
        firstDayOfMonth.setDate(1);
        firstDayOfMonth.setHours(0, 0, 0, 0);

        const { data: phrasesThisMonth, error: phrasesError } = await supabase
          .from('phrases')
          .select('id')
          .gte('created_at', firstDayOfMonth.toISOString());

        if (phrasesError) throw phrasesError;
        setPhrasesAdded(phrasesThisMonth?.length || 0);

        // Get reviews completed this month
        const { data: reviewsThisMonth, error: reviewsError } = await supabase
          .from('votes')
          .select('id')
          .gte('created_at', firstDayOfMonth.toISOString());

        if (reviewsError) throw reviewsError;
        setReviewsCompleted(reviewsThisMonth?.length || 0);

      } catch (error) {
        console.error('Error fetching stats data:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  // Get colors based on the current accent
  const getChartColors = () => {
    switch (accent) {
      case 'blue':
        return ['#3B82F6', '#60A5FA', '#93C5FD', '#BFDBFE', '#DBEAFE'];
      case 'green':
        return ['#10B981', '#34D399', '#6EE7B7', '#A7F3D0', '#D1FAE5'];
      case 'purple':
        return ['#8B5CF6', '#A78BFA', '#C4B5FD', '#DDD6FE', '#EDE9FE'];
      case 'orange':
        return ['#F97316', '#FB923C', '#FDBA74', '#FED7AA', '#FFEDD5'];
      default: // grayscale
        return ['#4B5563', '#6B7280', '#9CA3AF', '#D1D5DB', '#E5E7EB'];
    }
  };

  // Generate accent-specific chart colors
  const COLORS = getChartColors();

  // Get the appropriate border color for cards
  const getCardBorderClass = () => {
    switch (accent) {
      case 'blue': return 'border-blue-500/30';
      case 'green': return 'border-emerald-500/30';
      case 'purple': return 'border-purple-500/30';
      case 'orange': return 'border-orange-500/30';
      default: return 'border-gray-500/30';
    }
  };

  // If loading, show skeleton state
  if (loading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {[1, 2, 3, 4].map((i) => (
          <Card key={i} className="animate-pulse">
            <CardHeader className="pb-2">
              <div className="h-6 w-1/3 bg-gray-200 dark:bg-gray-700 rounded"></div>
            </CardHeader>
            <CardContent>
              <div className="h-[250px] w-full bg-gray-100 dark:bg-gray-800 rounded"></div>
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  // Calculate percentage for gauges
  const phrasesPercentage = Math.min(100, Math.round((phrasesAdded / 100) * 100));
  const reviewsPercentage = Math.min(100, Math.round((reviewsCompleted / 100) * 100));

  // Gauge chart needle renderer
  const renderNeedle = (value, data, cx, cy, iRadius, oRadius, color) => {
    const angle = 180 - value * 1.8; // Convert percentage to angle (180 to 0)
    const length = oRadius * 0.8; // Length of the needle
    const sin = Math.sin(-angle * Math.PI / 180);
    const cos = Math.cos(-angle * Math.PI / 180);
    const r = 5; // Needle base radius
    const x0 = cx;
    const y0 = cy;
    const xba = x0 + r * sin;
    const yba = y0 - r * cos;
    const xbb = x0 - r * sin;
    const ybb = y0 + r * cos;
    const xp = x0 + length * sin;
    const yp = y0 - length * cos;

    // Use the first color from the COLORS array
    const needleColor = COLORS[0];

    return [
      <circle cx={x0} cy={y0} r={r + 2} fill={needleColor} stroke="none" key="needle-center" />,
      <path d={`M${xba} ${yba}L${xbb} ${ybb}L${xp} ${yp}Z`} fill={needleColor} key="needle-path" />
    ];
  };

  // Get accent-specific empty gauge color
  const getEmptyGaugeColor = () => {
    return accent === 'default' ? '#E5E7EB' : '#E5E7EB';
  };

  // Get accent-specific filled gauge color
  const getFilledGaugeColor = () => {
    return COLORS[0];
  };

  const cardBorderClass = getCardBorderClass();

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {/* Category Bar Chart - horizontal layout for better category name display */}
      <Card className={cn("border rounded-md border-2", cardBorderClass)}>
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Category Distribution</CardTitle>
          <CardDescription>Top categories by phrase count</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                layout="vertical"
                data={categoryData}
                margin={{ top: 5, right: 30, left: 75, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#555" opacity={0.2} />
                <XAxis type="number" />
                <YAxis 
                  type="category" 
                  dataKey="name" 
                  width={75}
                  tick={{ fontSize: 11 }}
                />
                <Tooltip
                  formatter={(value) => [`${value} phrases`, 'Count']}
                  contentStyle={{ backgroundColor: '#333', border: '1px solid #444' }}
                />
                <Bar dataKey="value" fill={COLORS[0]}>
                  {categoryData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Difficulty Pie Chart */}
      <Card className={cn("border rounded-md border-2", cardBorderClass)}>
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Difficulty Distribution</CardTitle>
          <CardDescription>Breakdown by difficulty level</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={difficultyData}
                  cx="50%"
                  cy="50%"
                  labelLine={true}
                  innerRadius={60}
                  outerRadius={90}
                  fill="#8884d8"
                  dataKey="value"
                  stroke="#000"
                  label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                >
                  {difficultyData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip 
                  formatter={(value) => [`${value} phrases`, 'Count']}
                  contentStyle={{ backgroundColor: '#333', border: '1px solid #444' }}
                />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Monthly Phrases Goal Gauge */}
      <Card className={cn("border rounded-md border-2", cardBorderClass)}>
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Words Added This Month</CardTitle>
          <CardDescription>Progress towards the goal of 100 words</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  startAngle={180}
                  endAngle={0}
                  data={[
                    { name: 'Empty', value: 100 - phrasesPercentage, fill: getEmptyGaugeColor() },
                    { name: 'Progress', value: phrasesPercentage, fill: getFilledGaugeColor() }
                  ]}
                  cx="50%"
                  cy="80%"
                  innerRadius={70}
                  outerRadius={90}
                  fill="#8884d8"
                  paddingAngle={0}
                  dataKey="value"
                  stroke="none"
                >
                </Pie>
                {renderNeedle(phrasesPercentage, null, '50%', '80%', 70, 90, COLORS[0])}
                <text
                  x="50%"
                  y="50%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground font-bold"
                  fontSize="24"
                >
                  {phrasesPercentage}%
                </text>
                <text
                  x="50%"
                  y="75%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground"
                  fontSize="14"
                >
                  {phrasesAdded}/100 words
                </text>
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Monthly Reviews Goal Gauge */}
      <Card className={cn("border rounded-md border-2", cardBorderClass)}>
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Reviews Completed This Month</CardTitle>
          <CardDescription>Progress towards 100 reviews this month</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  startAngle={180}
                  endAngle={0}
                  data={[
                    { name: 'Empty', value: 100 - reviewsPercentage, fill: getEmptyGaugeColor() },
                    { name: 'Progress', value: reviewsPercentage, fill: getFilledGaugeColor() }
                  ]}
                  cx="50%"
                  cy="80%"
                  innerRadius={70}
                  outerRadius={90}
                  fill="#8884d8"
                  paddingAngle={0}
                  dataKey="value"
                  stroke="none"
                >
                </Pie>
                {renderNeedle(reviewsPercentage, null, '50%', '80%', 70, 90, COLORS[0])}
                <text
                  x="50%"
                  y="50%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground font-bold"
                  fontSize="24"
                >
                  {reviewsPercentage}%
                </text>
                <text
                  x="50%"
                  y="75%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground"
                  fontSize="14"
                >
                  {reviewsCompleted}/100 reviews
                </text>
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default AnalyticsSection;

============================================================

FILE: .\features\dashboard\components\DashboardHeader.tsx
SIZE: 1.71 KB
LAST MODIFIED: 03/23/2025 12:55:45

'use client';

import React from 'react';
import { Button } from "@/components/ui/button";
import { ThemeSwitcher } from "@/components/ui/theme/ThemeSwitcher";
import { ReviewerLoginButton } from '@/features/auth/ReviewerLoginButton';
import { ReviewerProfileDropdown } from '@/features/auth/ReviewerProfileDropdown';
import { Reviewer } from '@/types/types'; // Make sure to import the Reviewer type

// Define the props interface
interface DashboardHeaderProps {
  onExportClick: () => void;
  currentReviewer: Reviewer | null;
  onLoginSuccess: (reviewer: Reviewer) => void;
  onLogout: () => void;
  onAddWordsClick: () => void;
  onReviewWordsClick: () => void;
}

export function DashboardHeader({ 
  onExportClick,
  currentReviewer,
  onLoginSuccess,
  onLogout,
  onAddWordsClick,
  onReviewWordsClick
}: DashboardHeaderProps) {
  return (
    <div className="flex justify-between items-center">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground">Manage your catch phrases</p>
      </div>

      <div className="flex items-center gap-3">
        <ThemeSwitcher showAccentColors={true} />

        {currentReviewer ? (
          <ReviewerProfileDropdown 
            reviewer={currentReviewer} 
            reviewerIndex={0} 
            onLogout={onLogout}
            onExportClick={onExportClick}
            onAddWordsClick={onAddWordsClick}
            onReviewWordsClick={onReviewWordsClick}
          />
        ) : (
          <ReviewerLoginButton 
            variant="secondary"
            className="text-black bg-white hover:bg-gray-100 rounded-md border-0"
            onLoginSuccess={onLoginSuccess}
          />
        )}
      </div>
    </div>
  );
}


============================================================

FILE: .\features\dashboard\components\DashboardHeader.tsx.bak
SIZE: 2.06 KB
LAST MODIFIED: 03/22/2025 22:58:57

'use client';

import React from 'react';
import { Button } from "@/components/ui/button";
import { Moon, Sun } from "lucide-react";
import { ReviewerLoginButton } from '@/features/auth/ReviewerLoginButton';
import { ReviewerProfileDropdown } from '@/features/auth/ReviewerProfileDropdown';
import { Reviewer } from '@/types/types'; // Make sure to import the Reviewer type

// Define the props interface
interface DashboardHeaderProps {
  theme?: string;
  setTheme: (theme: string) => void;
  onExportClick: () => void;
  currentReviewer: Reviewer | null;
  onLoginSuccess: (reviewer: Reviewer) => void;
  onLogout: () => void;
  onAddWordsClick: () => void;
  onReviewWordsClick: () => void;
}

export function DashboardHeader({ 
  theme, 
  setTheme, 
  onExportClick,
  currentReviewer,
  onLoginSuccess,
  onLogout,
  onAddWordsClick,
  onReviewWordsClick
}: DashboardHeaderProps) {
  return (
    <div className="flex justify-between items-center">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground">Manage your catch phrases</p>
      </div>

      <div className="flex items-center gap-3">
        <Button
          variant="outline"
          size="icon"
          onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
          className="h-9 w-9 rounded-md"
        >
          {theme === 'dark' ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />}
        </Button>

        {currentReviewer ? (
          <ReviewerProfileDropdown 
            reviewer={currentReviewer} 
            reviewerIndex={0} 
            onLogout={onLogout}
            onExportClick={onExportClick}
            onAddWordsClick={onAddWordsClick}
            onReviewWordsClick={onReviewWordsClick}
          />
        ) : (
          <ReviewerLoginButton 
            variant="secondary"
            className="text-black bg-white hover:bg-gray-100 rounded-md border-0"
            onLoginSuccess={onLoginSuccess}
          />
        )}
      </div>
    </div>
  );
}

============================================================

FILE: .\features\dashboard\components\ExportModal.tsx
SIZE: 4.29 KB
LAST MODIFIED: 03/17/2025 21:35:28

// src/components/common/ExportModal.tsx

import React, { useState } from 'react';
import { saveAs } from 'file-saver';
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogFooter, 
  DialogHeader, 
  DialogTitle
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

interface ExportModalProps {
  isOpen: boolean;
  onClose: () => void;
  onExport: (options: ExportOptions) => Promise<ExportResult | null>;
  isLoading: boolean;
}

interface ExportOptions {
  exportJson: boolean;
  exportHeader: boolean;
  optimizeForESP32: boolean;
}

interface ExportResult {
  jsonData: any;
  headerContent: string;
}

const ExportModal: React.FC<ExportModalProps> = ({ 
  isOpen, 
  onClose, 
  onExport,
  isLoading
}) => {
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    exportJson: true,
    exportHeader: true,
    optimizeForESP32: true
  });

  const handleOptionChange = (option: keyof ExportOptions) => {
    setExportOptions(prev => ({
      ...prev,
      [option]: !prev[option]
    }));
  };

  const handleExport = async () => {
    const data = await onExport(exportOptions);
    
    if (!data) return;

    // Download files based on options
    if (exportOptions.exportJson) {
      const jsonBlob = new Blob(
        [JSON.stringify(data.jsonData, null, 2)], 
        { type: 'application/json' }
      );
      saveAs(jsonBlob, 'phrases_esp32.json');
    }
    
    if (exportOptions.exportHeader) {
      const headerBlob = new Blob(
        [data.headerContent], 
        { type: 'text/plain' }
      );
      saveAs(headerBlob, 'phrases.h');
    }

    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md bg-black border-neutral-800">
        <DialogHeader>
          <DialogTitle className="text-white">Export Phrases for ESP32</DialogTitle>
          <DialogDescription className="text-neutral-400">
            Choose export options for your ESP32 catch phrase game
          </DialogDescription>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-json" 
              checked={exportOptions.exportJson} 
              onCheckedChange={() => handleOptionChange('exportJson')}
            />
            <Label htmlFor="export-json" className="text-neutral-300">Export JSON file (for SPIFFS)</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-header" 
              checked={exportOptions.exportHeader} 
              onCheckedChange={() => handleOptionChange('exportHeader')}
            />
            <Label htmlFor="export-header" className="text-neutral-300">Export Arduino header file</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="optimize" 
              checked={exportOptions.optimizeForESP32} 
              onCheckedChange={() => handleOptionChange('optimizeForESP32')}
            />
            <Label htmlFor="optimize" className="text-neutral-300">Optimize for ESP32 memory usage</Label>
          </div>
        </div>
        
        <DialogFooter>
          <Button 
            type="button" 
            variant="outline" 
            onClick={onClose}
            className="border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white"
          >
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleExport}
            disabled={isLoading}
            className="bg-neutral-100 text-black hover:bg-white"
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Exporting...
              </>
            ) : (
              'Export'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default ExportModal;

============================================================

FILE: .\features\dashboard\components\ImportSection.tsx
SIZE: 0.49 KB
LAST MODIFIED: 03/21/2025 10:05:40

// features/dashboard/components/ImportSection.tsx
import React from 'react';
import BulkImportForm from '@/features/import/BulkImportForm';

interface ImportSectionProps {
  onSuccess?: () => void;
}

export const ImportSection: React.FC<ImportSectionProps> = ({ onSuccess }) => {
  const handleError = (error: string) => {
    console.error('Import error:', error);
  };

  return (
    <BulkImportForm 
      onSuccess={onSuccess} 
      onError={handleError} 
    />
  );
};

============================================================

FILE: .\features\dashboard\components\PhrasesSection.tsx
SIZE: 2.86 KB
LAST MODIFIED: 03/22/2025 23:59:24

import React, { useEffect } from 'react';
import { PhrasesTable } from '@/features/phrases/phrasesTable';
import { FilterProvider } from '@/features/phrases/stores/filterContext';
import { useDeletePhrase } from '@/features/phrases/hooks/useDeletePhrase';
import { usePhrases } from '@/features/data/hooks/usePhrases';
import { useToast } from '@/hooks/useToast';

interface PhrasesSectionProps {
  newIds: number[];
  onEdit: (id: number) => void;
}

export const PhrasesSection: React.FC<PhrasesSectionProps> = ({ 
  newIds,
  onEdit
}) => {
  const { toast } = useToast();
  
  const {
    phrases,
    loading: phrasesLoading,
    filters,
    pagination,
    sortConfig,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    fetchPhrases
  } = usePhrases();

  // Initialize the delete phrase mutation
  const deletePhraseMutation = useDeletePhrase();
  
  // Watch for errors from the delete mutation
  useEffect(() => {
    if (deletePhraseMutation.error) {
      toast({
        title: "Error",
        description: "Failed to delete phrase",
        variant: "destructive"
      });
    }
  }, [deletePhraseMutation.error, toast]);
  
  // Handle delete phrase
  const handleDelete = (id: number) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      deletePhraseMutation.mutate(id, {
        onSuccess: () => {
          toast({
            title: "Success",
            description: "Phrase deleted successfully",
            variant: "success"
          });
          fetchPhrases();
        }
      });
    }
  };

  // Create a tableState object from the hook's state
  const tableState = {
    sortConfig,
    pagination,
    filters
  };

  // Function to update the table state
  const handleTableStateChange = (updates: any) => {
    if (updates.filters) {
      Object.entries(updates.filters).forEach(([key, value]) => {
        if (value !== undefined) {
          handleFilterChange(key, value as string);
        }
      });
    }
    
    if (updates.sortConfig?.key) {
      handleSort(updates.sortConfig.key);
    }
    
    if (updates.pagination) {
      if (updates.pagination.rowsPerPage) {
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
      
      if (updates.pagination.currentPage) {
        handlePageChange(updates.pagination.currentPage);
      }
    }
  };

  return (
    <div className="flex flex-col space-y-4">
      <FilterProvider>
        <PhrasesTable
          phrases={phrases}
          loading={phrasesLoading}
          tableState={tableState}
          onTableStateChange={handleTableStateChange}
          onEdit={onEdit}
          onDelete={handleDelete}
          newIds={newIds}
        />
      </FilterProvider>
    </div>
  );
};

export default PhrasesSection;

============================================================

FILE: .\features\dashboard\components\StatsCards.tsx
SIZE: 7.93 KB
LAST MODIFIED: 03/23/2025 16:16:28

// features/dashboard/components/StatsCards.tsx
import React, { useEffect, useState } from 'react';
import { Card } from '@/components/ui/card';
import { useDashboardState } from '../hooks/useDashboardState';
import { useTheme } from '@/providers/ThemeContext';
import { TrendingUp, TrendingDown, Minus, Award, Users, BookOpen, Clock } from 'lucide-react';
import { cn } from '@/lib/utils';

// Type for each stat card
type StatCardProps = {
  title: string;
  value: string | number;
  description: string;
  trend?: number;
  trendDirection?: 'up' | 'down' | 'neutral';
  timeframe: string;
  icon?: React.ReactNode;
  loading?: boolean;
  sparklineData?: number[];
};

// Individual stat card component
const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  trend = 0,
  trendDirection = 'neutral',
  timeframe,
  icon,
  loading = false,
  sparklineData = [],
}) => {
  const { accent } = useTheme();
  
  // Get accent-specific border style
  const getBorderStyle = () => {
    switch (accent) {
      case 'blue':
        return 'border-blue-500/30';
      case 'green':
        return 'border-emerald-500/30';
      case 'purple':
        return 'border-purple-500/30';
      case 'orange':
        return 'border-orange-500/30';
      default: // grayscale
        return 'border-gray-500/30';
    }
  };

  // Determine color and icon based on trend direction
  // These always stay the same regardless of accent
  const getTrendColor = () => {
    if (trendDirection === 'up') return 'text-green-500';
    if (trendDirection === 'down') return 'text-red-500';
    return 'text-gray-500';
  };

  const getTrendIcon = () => {
    if (trendDirection === 'up') return <TrendingUp className="w-4 h-4 ml-1" />;
    if (trendDirection === 'down') return <TrendingDown className="w-4 h-4 ml-1" />;
    return <Minus className="w-4 h-4 ml-1" />;
  };

  // Get accent-specific icon background
  const getIconBackground = () => {
    switch (accent) {
      case 'blue':
        return 'bg-blue-950 text-blue-400';
      case 'green':
        return 'bg-emerald-950 text-emerald-400';
      case 'purple':
        return 'bg-purple-950 text-purple-400';
      case 'orange':
        return 'bg-orange-950 text-orange-400';
      default: // grayscale
        return 'bg-gray-900 text-gray-400';
    }
  };

  // Render sparkline if data is provided
  const renderSparkline = () => {
    if (!sparklineData.length) return null;
    
    const max = Math.max(...sparklineData);
    const min = Math.min(...sparklineData);
    const range = max - min || 1;

    // Get accent-specific sparkline color
    const getSparklineColor = () => {
      // For trend directions, use fixed colors
      if (trendDirection === 'up') return '#10B981'; // Green
      if (trendDirection === 'down') return '#EF4444'; // Red
      
      // For neutral trend, use accent color
      switch (accent) {
        case 'blue': return '#3B82F6';
        case 'green': return '#10B981';
        case 'purple': return '#8B5CF6';
        case 'orange': return '#F97316';
        default: return '#6B7280'; // grayscale
      }
    };
    
    return (
      <div className="h-8 mt-2">
        <svg width="100%" height="100%" viewBox={`0 0 ${sparklineData.length} 50`} preserveAspectRatio="none">
          {sparklineData.map((value, index) => {
            const height = ((value - min) / range) * 40 + 10;
            const x = index;
            const y = 50 - height;
            
            return (
              <rect 
                key={index} 
                x={x} 
                y={y} 
                width="0.8" 
                height={height}
                fill={getSparklineColor()}
                rx="1"
              />
            );
          })}
        </svg>
      </div>
    );
  };

  return (
    <Card className={cn(
      "p-6 text-white shadow border-2",
      getBorderStyle()
    )}>
      <div className="flex justify-between items-start">
        <div className="space-y-2">
          <h3 className="text-gray-400 text-sm uppercase font-medium">{title}</h3>
          <div className="flex items-baseline">
            <h2 className="text-2xl font-bold">{loading ? '...' : value}</h2>
            {trend !== 0 && (
              <span className={`text-sm ml-2 flex items-center ${getTrendColor()}`}>
                {trend > 0 ? '+' : ''}{trend}% {getTrendIcon()}
              </span>
            )}
          </div>
        </div>
        {icon && (
          <div className={cn("rounded-full p-2", getIconBackground())}>
            {icon}
          </div>
        )}
      </div>
      
      <p className="text-gray-400 text-sm mt-1">{description}</p>
      
      {renderSparkline()}
      
      <div className="mt-2 text-xs text-gray-500">
        {timeframe}
      </div>
    </Card>
  );
};

// Main StatsCards component
export const StatsCards: React.FC = () => {
  const { dateRange } = useDashboardState();
  const [stats, setStats] = useState({
    newPhrases: { value: 0, trend: 0, sparkline: [] },
    reviewedPhrases: { value: 0, trend: 0, sparkline: [] },
    activeReviewers: { value: 0, trend: 0 },
    topReviewer: { name: '', count: 0, streak: 0 }
  });
  const [loading, setLoading] = useState(true);
  const { accent } = useTheme();

  useEffect(() => {
    const fetchStats = async () => {
      setLoading(true);
      try {
        const response = await fetch('/api/dashboard/stats', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ dateRange }),
        });
        
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        setStats(data);
      } catch (error) {
        console.error('Error fetching dashboard stats:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchStats();
  }, [dateRange]);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
      <StatCard
        title="NEW PHRASES"
        value={stats.newPhrases.value}
        description="Phrases added in the last month"
        trend={stats.newPhrases.trend}
        trendDirection={stats.newPhrases.trend > 0 ? 'up' : stats.newPhrases.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<BookOpen className="w-5 h-5" />}
        loading={loading}
        sparklineData={stats.newPhrases.sparkline}
      />
      
      <StatCard
        title="PHRASES REVIEWED"
        value={stats.reviewedPhrases.value}
        description="Total reviews in the last month"
        trend={stats.reviewedPhrases.trend}
        trendDirection={stats.reviewedPhrases.trend > 0 ? 'up' : stats.reviewedPhrases.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<Clock className="w-5 h-5" />}
        loading={loading}
        sparklineData={stats.reviewedPhrases.sparkline}
      />
      
      <StatCard
        title="ACTIVE REVIEWERS"
        value={stats.activeReviewers.value}
        description="Unique reviewers this month"
        trend={stats.activeReviewers.trend}
        trendDirection={stats.activeReviewers.trend > 0 ? 'up' : stats.activeReviewers.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<Users className="w-5 h-5" />}
        loading={loading}
      />
      
      <StatCard
        title="TOP REVIEWER"
        value={stats.topReviewer.name || 'N/A'}
        description={`${stats.topReviewer.count} reviews (${stats.topReviewer.streak} day streak)`}
        timeframe={`Last ${dateRange} days`}
        icon={<Award className="w-5 h-5" />}
        loading={loading}
      />
    </div>
  );
};

export default StatsCards;

============================================================

FILE: .\features\dashboard\hooks\useDashboardState.ts
SIZE: 3.55 KB
LAST MODIFIED: 03/22/2025 23:49:38

// features/dashboard/hooks/useDashboardState.ts
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Reviewer } from '@/types/types';
import { useToast } from '@/hooks/useToast';

export const useDashboardState = () => {
  const { toast } = useToast();
  
  // Tab and Modal States
  const [activeTab, setActiveTab] = useState<string>('phrases');
  const [showWordCreatorModal, setShowWordCreatorModal] = useState<boolean>(false);
  const [showReviewModal, setShowReviewModal] = useState<boolean>(false);
  const [showFilterModal, setShowFilterModal] = useState<boolean>(false);
  const [showExportModal, setShowExportModal] = useState<boolean>(false);
  
  // Data States
  const [selectedPhraseId, setSelectedPhraseId] = useState<number | null>(null); 
  const [newIds, setNewIds] = useState<number[]>([]);
  const [dateRange, setDateRange] = useState<number>(30);
  const [currentReviewer, setCurrentReviewer] = useState<Reviewer | null>(null);
  const [isExporting, setIsExporting] = useState(false);
  
  // Loading States
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Initialize current reviewer from localStorage
  useEffect(() => {
    const initializeReviewer = () => {
      const savedReviewer = localStorage.getItem('currentReviewer');
      if (savedReviewer) {
        try {
          setCurrentReviewer(JSON.parse(savedReviewer));
        } catch (e) {
          console.error("Error parsing saved reviewer:", e);
          localStorage.removeItem('currentReviewer');
          toast({
            title: "Error",
            description: "Your login session was corrupted and has been reset",
            variant: "destructive"
          });
        }
      }
      
      setIsLoading(false);
    };
    
    initializeReviewer();
  }, []);

  // Function to update date range
  const updateDateRange = useCallback((days: number) => {
    setDateRange(days);
  }, []);
  
  // Login/Logout handlers
  const handleLoginSuccess = useCallback((reviewer: Reviewer) => {
    setCurrentReviewer(reviewer);
    localStorage.setItem('currentReviewer', JSON.stringify(reviewer));
    
    toast({
      title: "Welcome back!",
      description: `You're now logged in as ${reviewer.name}`,
      variant: "success",
    });
  }, [toast]);
  
  const handleLogout = useCallback(() => {
    setCurrentReviewer(null);
    localStorage.removeItem('currentReviewer');
    
    toast({
      title: "Logged out",
      description: "You've been logged out successfully",
      variant: "info",
    });
  }, [toast]);

  // Word Creator handlers
  const handleWordAdded = useCallback((id?: number) => {
    // Only add to newIds if an id is provided
    if (id !== undefined) {
      setNewIds(prev => [...prev, id]);
    }
    
    toast({
      title: "Success",
      description: "New phrase added successfully",
      variant: "success",
    });
  }, [toast]);

  return {
    // Tab and Modal States
    activeTab, 
    setActiveTab,
    showWordCreatorModal, 
    setShowWordCreatorModal,
    showReviewModal, 
    setShowReviewModal,
    showFilterModal, 
    setShowFilterModal,
    showExportModal, 
    setShowExportModal,
    
    // Data States
    selectedPhraseId,
    setSelectedPhraseId,
    newIds, 
    setNewIds,
    dateRange,
    updateDateRange,
    currentReviewer,
    setCurrentReviewer,
    isExporting,
    setIsExporting,
    
    // Loading States
    isLoading,
    error,
    
    // Handlers
    handleLoginSuccess,
    handleLogout,
    handleWordAdded
  };
};

============================================================

FILE: .\features\dashboard\hooks\useExport.ts
SIZE: 5.82 KB
LAST MODIFIED: 03/22/2025 23:26:11

// features/dashboard/hooks/useExport.ts
import { useState } from 'react';
import { supabase } from '@/lib/services/supabase';
import { saveAs } from 'file-saver';

export interface ExportOptions {
  exportJson: boolean;
  exportHeader: boolean;
  optimizeForESP32: boolean;
}

export interface ExportResult {
  jsonData: any;
  headerContent: string;
}

export const useExport = () => {
  const [isExporting, setIsExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * Export phrases data according to options
   */
  const exportPhrases = async (options: ExportOptions): Promise<ExportResult | null> => {
    setIsExporting(true);
    setError(null);
    
    try {
      // Fetch phrases with all related data
      const { data: phrases, error: phrasesError } = await supabase
        .from('phrases')
        .select(`
          id,
          phrase,
          part_of_speech,
          hint,
          category_id,
          subcategory_id,
          difficulty,
          categories:category_id(name),
          subcategories:subcategory_id(name)
        `);
      
      if (phrasesError) throw phrasesError;
      
      // Fetch phrase tags
      const { data: phraseTags, error: tagsError } = await supabase
        .from('phrase_tags')
        .select(`
          phrase_id,
          tags:tag_id(tag)
        `);
        
      if (tagsError) throw tagsError;
      
      // Process data
      const tagsByPhraseId: Record<string, string[]> = {};
      phraseTags.forEach((item: any) => {
        if (!tagsByPhraseId[item.phrase_id]) {
          tagsByPhraseId[item.phrase_id] = [];
        }
        tagsByPhraseId[item.phrase_id].push(item.tags.tag);
      });
      
      const categorizedPhrases: Record<string, any[]> = {};
      phrases.forEach((phrase: any) => {
        const categoryName = phrase.categories ? phrase.categories.name : 'Uncategorized';
        if (!categorizedPhrases[categoryName]) {
          categorizedPhrases[categoryName] = [];
        }
        
        categorizedPhrases[categoryName].push({
          text: phrase.phrase,
          pos: phrase.part_of_speech,
          hint: phrase.hint || '',
          difficulty: phrase.difficulty || 1,
          subcategory: phrase.subcategories ? phrase.subcategories.name : null,
          tags: tagsByPhraseId[phrase.id] || [],
        });
      });
      
      // Format data according to export options
      const esp32Data: Record<string, any[]> = {};
      Object.keys(categorizedPhrases).forEach(cat => {
        if (options.optimizeForESP32) {
          esp32Data[cat] = categorizedPhrases[cat].map(p => ({
            t: p.text,
            h: p.hint || '',
            d: p.difficulty || 1
          }));
        } else {
          esp32Data[cat] = categorizedPhrases[cat];
        }
      });
      
      // Generate Arduino header if requested
      const headerContent = options.exportHeader ? generateArduinoHeader(esp32Data) : '';
      
      return { jsonData: esp32Data, headerContent };
    } catch (err) {
      console.error('Export error:', err);
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
      return null;
    } finally {
      setIsExporting(false);
    }
  };

  /**
   * Download export files based on options
   */
  const downloadExport = (data: ExportResult, options: ExportOptions) => {
    try {
      // Download files based on options
      if (options.exportJson) {
        const jsonBlob = new Blob(
          [JSON.stringify(data.jsonData, null, 2)], 
          { type: 'application/json' }
        );
        saveAs(jsonBlob, 'phrases_esp32.json');
      }
      
      if (options.exportHeader) {
        const headerBlob = new Blob(
          [data.headerContent], 
          { type: 'text/plain' }
        );
        saveAs(headerBlob, 'phrases.h');
      }
      
      return true;
    } catch (err) {
      console.error('Download error:', err);
      setError(err instanceof Error ? err.message : 'Failed to download files');
      return false;
    }
  };

  /**
   * Generate Arduino header file
   */
  const generateArduinoHeader = (data: Record<string, any[]>): string => {
    let headerContent = `// Auto-generated phrases header file
#ifndef PHRASES_H
#define PHRASES_H

#include <Arduino.h>

struct Phrase {
  const char* text;
  const char* hint;
  uint8_t difficulty;
};
`;
    Object.keys(data).forEach(category => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      const phrases = data[category];
      headerContent += `// ${category} phrases
constexpr Phrase ${categoryVar}_phrases[] PROGMEM = {
`;
      phrases.forEach(phrase => {
        const text = phrase.t || phrase.text;
        const hint = phrase.h || phrase.hint || '';
        const difficulty = phrase.d || phrase.difficulty || 1;
        headerContent += `  {"${escapeString(text)}", "${escapeString(hint)}", ${difficulty}},
`;
      });
      headerContent += `};

constexpr size_t ${categoryVar}_count = ${phrases.length};

`;
    });
    headerContent += `// Category index
struct PhraseCategory {
  const char* name;
  const Phrase* phrases;
  size_t count;
};

constexpr PhraseCategory phrase_categories[] PROGMEM = {
`;
    Object.keys(data).forEach(category => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      headerContent += `  {"${escapeString(category)}", ${categoryVar}_phrases, ${categoryVar}_count},
`;
    });
    headerContent += `};

constexpr size_t category_count = ${Object.keys(data).length};

#endif // PHRASES_H
`;
    return headerContent;
  };

  /**
   * Escape strings for C++ code
   */
  const escapeString = (str: string): string => {
    if (!str) return "";
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
  };

  return {
    exportPhrases,
    downloadExport,
    isExporting,
    error,
    setError
  };
};

============================================================

FILE: .\features\dashboard\styles\dashboard.css
SIZE: 1.53 KB
LAST MODIFIED: 03/06/2025 22:07:22

@keyframes flash {
  0%, 100% {
    background-color: transparent;
  }
  50% {
    background-color: var(--accent);
  }
}

.animate-flash {
  animation: flash 1.5s ease-in-out;
}

/* Table row hover effect */
.table-row-hover {
  transition: background-color 0.15s ease;
}

.table-row-hover:hover {
  background-color: var(--muted);
}

/* Ensure top margin for pie labels */
.recharts-pie-label-text {
  margin-top: 5px; /* Fix for cut-off text */
}

/* Chart hover effects */
.recharts-wrapper {
  margin-top: 5px;
}

/* Chart style updates */
.recharts-bar-rectangle:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

.recharts-pie-sector:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

/* Custom grayscale palette for charts */
.chart-gray-100 {
  fill: #f5f5f5;
}

.chart-gray-200 {
  fill: #e0e0e0;
}

.chart-gray-300 {
  fill: #cccccc;
}

.chart-gray-400 {
  fill: #bbbbbb;
}

.chart-gray-500 {
  fill: #999999;
}

.chart-gray-600 {
  fill: #777777;
}

.chart-gray-700 {
  fill: #555555;
}

.chart-gray-800 {
  fill: #333333;
}

/* Tooltip styling */
.custom-tooltip {
  background-color: var(--background);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  padding: 0.5rem;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Login button styling */
.login-button {
  background-color: white;
  color: black;
  border: 1px solid var(--border);
}

.login-button:hover {
  background-color: #f0f0f0;
}

============================================================

FILE: .\features\data\hooks\usePhraseMetadata.ts
SIZE: 2.39 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';

interface PhraseMetadata {
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
  error: string | null;
}

interface CategoryRecord {
  name: string;
}

interface PartOfSpeechRecord {
  part_of_speech: string;
}

export const usePhraseMetadata = (): PhraseMetadata => {
  const [categories, setCategories] = useState<string[]>([]);
  const [difficulties, setDifficulties] = useState<string[]>([]);
  const [partsOfSpeech, setPartsOfSpeech] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchMetadata = async () => {
      setLoading(true);
      setError(null);
      
      try {
        // Fetch categories
        const { data: categoryData, error: categoryError } = await supabase
          .from('categories')
          .select('name')
          .order('name');

        if (categoryError) throw categoryError;

        // Fetch parts of speech from phrases
        const { data: posData, error: posError } = await supabase
          .from('phrases')
          .select('part_of_speech')
          .not('part_of_speech', 'is', null);

        if (posError) throw posError;

        // Process categories
        const uniqueCategories = Array.from(
          new Set((categoryData as CategoryRecord[]).map(record => record.name))
        );

        // Process parts of speech
        const uniquePartsOfSpeech = Array.from(
          new Set((posData as PartOfSpeechRecord[])
            .map(record => record.part_of_speech)
            .filter(Boolean))
        ).sort();

        // Set predefined difficulties
        const difficultyLevels = ['Easy', 'Medium', 'Hard'];

        setCategories(uniqueCategories);
        setDifficulties(difficultyLevels);
        setPartsOfSpeech(uniquePartsOfSpeech);
      } catch (err) {
        console.error('Error fetching metadata:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch metadata');
      } finally {
        setLoading(false);
      }
    };

    fetchMetadata();
  }, []);

  return {
    categories,
    difficulties,
    partsOfSpeech,
    loading,
    error
  };
};

export default usePhraseMetadata;


============================================================

FILE: .\features\data\hooks\usePhrases.ts
SIZE: 6.12 KB
LAST MODIFIED: 03/17/2025 21:29:25

// hooks/usePhrases.ts

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase'
import type { Phrase, PaginationState, SortConfig, Filters } from '@/types/types';

export const usePhrases = () => {
  const [phrases, setPhrases] = useState<Phrase[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    rowsPerPage: 10,  // Default to 10 rows per page
    totalPages: 1,
    totalItems: 0
  });

  const [sortConfig, setSortConfig] = useState<SortConfig>({
    key: '',
    direction: 'asc'
  });

  const [filters, setFilters] = useState<Filters>({
    searchTerm: '',
    category: '',
    difficulty: '',
    subcategory: '',
    part_of_speech: ''
  });

  const fetchPhrases = useCallback(async () => {
    try {
      setLoading(true);
      let query = supabase
      .from('phrases')
      .select(`
        *,
        categories:category_id(id, name),
        subcategories:subcategory_id(id, name),
        phrase_tags!inner(
          tags(id, tag)
        )
      `, { count: 'exact' });
      // Apply filters
      if (filters.category) {
        // First get the category id
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          query = query.eq('category_id', categoryData.id);
        }
      }

      if (filters.difficulty) {
        query = query.eq('difficulty', filters.difficulty);
      }

      if (filters.subcategory) {
        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('id')
          .eq('name', filters.subcategory)
          .single();

        if (subcategoryData) {
          query = query.eq('subcategory_id', subcategoryData.id);
        }
      }

      if (filters.part_of_speech) {
        query = query.eq('part_of_speech', filters.part_of_speech);
      }

      if (filters.searchTerm) {
        query = query.or(`phrase.ilike.%${filters.searchTerm}%`);
      }

      // Apply sorting
      if (sortConfig.key) {
        query = query.order(sortConfig.key, {
          ascending: sortConfig.direction === 'asc',
          nullsFirst: false
        });
      } else {
        // Default sort
        query = query.order('id', { ascending: false });
      }

      // Apply pagination
      console.log('Pagination values:', {
        currentPage: pagination.currentPage,
        rowsPerPage: pagination.rowsPerPage,
        calculatedStart: (pagination.currentPage - 1) * pagination.rowsPerPage,
        calculatedEnd: (pagination.currentPage - 1) * pagination.rowsPerPage + pagination.rowsPerPage - 1
      });
      const start = (pagination.currentPage - 1) * pagination.rowsPerPage;
      const end = start + pagination.rowsPerPage - 1;
      query = query.range(start, end);

      const { data, error: supabaseError, count } = await query as SupabaseQueryResponse<PhraseWithRelations>;

    if (supabaseError) throw supabaseError;

      // Transform the data
      const transformedData = data?.map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      setPhrases(transformedData || []);
      
      if (count !== null) {
        const totalPages = Math.ceil(count / pagination.rowsPerPage);
        setPagination(prev => ({
          ...prev,
          totalItems: count,
          totalPages: totalPages,
          // Ensure currentPage doesn't exceed total pages
          currentPage: Math.min(prev.currentPage, totalPages || 1)
        }));
      }
  
      setPhrases(transformedData || []);
    } catch (err) {
      // ... Error handling ...
    } finally {
      setLoading(false);
    }
  }, [filters, sortConfig, pagination.currentPage, pagination.rowsPerPage]);

  // Fetch categories for the filter
  const fetchCategories = async () => {
    try {
      const { data, error } = await supabase
        .from('categories')
        .select('name')
        .order('name');
        
      if (error) {
        console.error('Supabase error fetching categories:', error);
        return [];
      }
      
      return data.map(category => category.name);
    } catch (error) {
      console.error('Error fetching categories:', error);
      return [];
    }
  };

  const handleFilterChange = (name: string, value: string) => {
    setFilters(prev => ({ ...prev, [name]: value }));
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const resetFilters = () => {
    setFilters({
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    });
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const handleSort = (key: keyof Phrase) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };

  const handlePageChange = (page: number) => {
    setPagination(prev => ({
      ...prev,
      currentPage: page
    }));
  };

  const handleRowsPerPageChange = (rowsPerPage: number) => {
    setPagination(prev => ({
      ...prev,
      rowsPerPage,
      currentPage: 1,  // Reset to page 1 when changing rows per page
      totalPages: Math.ceil((prev.totalItems || 0) / rowsPerPage)
    }));
  };

  useEffect(() => {
    fetchPhrases();
  }, [fetchPhrases, pagination.currentPage, pagination.rowsPerPage, filters, sortConfig]);

  return {
    phrases,
    loading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    resetFilters,
    fetchCategories,
    fetchPhrases,
    setError
  };
};

============================================================

FILE: .\features\data\hooks\useReviewers.ts
SIZE: 0.9 KB
LAST MODIFIED: 03/22/2025 22:17:43

// hooks/useReviewers.ts
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';


export const useReviewers = () => {
  const [reviewers, setReviewers] = useState<Reviewer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchReviewers = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });

      if (error) throw error;
      setReviewers(data || []);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to fetch reviewers'));
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchReviewers();
  }, []);

  return { reviewers, loading, error, refetch: fetchReviewers };
};


============================================================

FILE: .\features\data\hooks\useStats.ts
SIZE: 2.84 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Stats, Phrase } from '@/types/types';

interface UseStatsReturn {
  stats: Stats;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const useStats = (): UseStatsReturn => {
  const [stats, setStats] = useState<Stats>({
    total: 0,
    uniqueCategories: 0,
    difficultyBreakdown: {
      easy: 0,
      medium: 0,
      hard: 0,
    },
  });

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const calculateStats = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const { data: phrases, error: fetchError, count } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id (name)
        `, { count: 'exact' });

      if (fetchError) throw fetchError;
      if (!phrases) throw new Error('No data received');

      // Calculate unique categories
      const uniqueCategories = new Set(phrases.map((p) => p.categories?.name)).size;

      // Map difficulty numbers to labels
      const difficultyLabels = {
        1: 'easy',
        2: 'medium',
        3: 'hard',
      };

      // Calculate difficulty breakdown
      const difficultyCount = phrases.reduce((acc: Record<string, number>, phrase) => {
        const difficultyLabel = difficultyLabels[phrase.difficulty] || 'unknown';
        acc[difficultyLabel] = (acc[difficultyLabel] || 0) + 1;
        return acc;
      }, {});

      const total = count || phrases.length;

      // Calculate percentages
      let easy = Math.round(((difficultyCount['easy'] || 0) / total) * 100);
      let medium = Math.round(((difficultyCount['medium'] || 0) / total) * 100);
      let hard = Math.round(((difficultyCount['hard'] || 0) / total) * 100);

      // Adjust for rounding errors
      const sum = easy + medium + hard;
      if (sum !== 100) {
        const diff = 100 - sum;
        if (easy >= medium && easy >= hard) {
          easy += diff;
        } else if (medium >= easy && medium >= hard) {
          medium += diff;
        } else {
          hard += diff;
        }
      }

      setStats({
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard,
        },
      });
    } catch (err) {
      console.error('Error calculating stats:', err);
      setError(err instanceof Error ? err.message : 'Failed to calculate stats');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    calculateStats();
  }, [calculateStats]);

  return {
    stats,
    loading,
    error,
    refetch: calculateStats,
  };
};

export default useStats;


============================================================

FILE: .\features\filters\FilterModal.tsx
SIZE: 5.5 KB
LAST MODIFIED: 03/05/2025 16:59:06

// components/common/FilterModal.tsx
import React from 'react';
import { X, Search } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface FilterModalProps {
  isOpen: boolean;
  onClose: () => void;
  filters: {
    searchTerm: string;
    category: string;
    difficulty: string;
    subcategory: string;
    part_of_speech: string;
  };
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  subcategories: string[];
}

const FilterModal: React.FC<FilterModalProps> = ({
  isOpen,
  onClose,
  filters,
  onChange,
  onReset,
  categories,
  difficulties,
  partsOfSpeech,
  subcategories = []
}) => {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Filter Phrases</DialogTitle>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          {/* Search */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Search</label>
            <div className="relative">
              <Search className="absolute left-3 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                value={filters.searchTerm}
                onChange={(e) => onChange('searchTerm', e.target.value)}
                placeholder="Search phrases or tags..."
                className="pl-9"
              />
            </div>
          </div>
          
          {/* Category */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Category</label>
            <Select
              value={filters.category}
              onValueChange={(value) => onChange('category', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Categories</SelectItem>
                {categories.map(category => (
                  <SelectItem key={category} value={category}>
                    {category}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Subcategory */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Subcategory</label>
            <Select
              value={filters.subcategory}
              onValueChange={(value) => onChange('subcategory', value)}
              disabled={!filters.category}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Subcategories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Subcategories</SelectItem>
                {subcategories.map(subcategory => (
                  <SelectItem key={subcategory} value={subcategory}>
                    {subcategory}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Difficulty */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Difficulty</label>
            <Select
              value={filters.difficulty}
              onValueChange={(value) => onChange('difficulty', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Difficulties" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Difficulties</SelectItem>
                {difficulties.map(difficulty => (
                  <SelectItem key={difficulty} value={difficulty}>
                    {difficulty}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Part of Speech */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Part of Speech</label>
            <Select
              value={filters.part_of_speech}
              onValueChange={(value) => onChange('part_of_speech', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Parts of Speech" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Parts of Speech</SelectItem>
                {partsOfSpeech.map(pos => (
                  <SelectItem key={pos} value={pos}>
                    {pos}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
        
        <DialogFooter className="flex justify-between">
          <Button 
            variant="outline" 
            onClick={onReset}
            className="flex items-center gap-1"
          >
            <X className="h-4 w-4" />
            Reset Filters
          </Button>
          <Button type="submit" onClick={onClose}>Apply Filters</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default FilterModal;

============================================================

FILE: .\features\import\BulkImportForm.tsx
SIZE: 3.89 KB
LAST MODIFIED: 03/06/2025 22:11:26

import React, { useState, useRef } from 'react';
import { Upload } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import type { BulkImportFormProps, NewPhrase } from '@/types/types';
import { supabase } from '@/lib/services/supabase';
import Papa from 'papaparse';

const BulkImportForm: React.FC<BulkImportFormProps> = ({
  onSuccess,
  onError
}) => {
  const [bulkImportText, setBulkImportText] = useState('');
  const [loading, setLoading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Existing handleBulkImport code and other processing functions

  const handleFileSelect = async (file: File) => {
    try {
      const text = await file.text();
      setBulkImportText(text);
    } catch (err) {
      console.error('File reading error:', err);
      onError('Failed to read file');
    }
  };

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(e.type === 'dragenter' || e.type === 'dragover');
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    const file = e.dataTransfer.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Bulk Import</CardTitle>
      </CardHeader>
      <CardContent>
        <div
          className={`relative border-2 border-dashed rounded-lg p-6 mb-4
            ${dragActive 
              ? 'border-blue-500 bg-blue-500/10' 
              : 'border-gray-600'
            }`}
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          <input
            ref={fileInputRef}
            type="file"
            onChange={handleFileInput}
            accept=".csv"
            className="hidden"
          />
          
          <div className="text-center">
            <Upload className="mx-auto h-12 w-12 text-gray-400" />
            <p className="mt-2 text-sm text-gray-400">
              Drag and drop a CSV file, or{' '}
              <button
                type="button"
                onClick={() => fileInputRef.current?.click()}
                className="text-blue-500 hover:text-blue-400"
              >
                browse
              </button>
            </p>
          </div>
        </div>

        <textarea
          value={bulkImportText}
          onChange={(e) => setBulkImportText(e.target.value)}
          className="w-full h-32 p-2 mb-4 border rounded bg-background focus:ring-2 focus:ring-blue-500"
          placeholder="phrase,category,difficulty,subcategory,tags,hint,part_of_speech"
        />

        <p className="text-sm text-muted-foreground mb-4">
          Format: phrase,category,difficulty,subcategory,tags,hint,part_of_speech
        </p>

        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => setBulkImportText('')}
            disabled={loading || !bulkImportText.trim()}
          >
            Clear
          </Button>
          <Button
            onClick={() => handleBulkImport(bulkImportText)}
            disabled={loading || !bulkImportText.trim()}
            className="bg-white text-black hover:bg-gray-100"
          >
            {loading ? 'Importing...' : 'Import Phrases'}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default BulkImportForm;

============================================================

FILE: .\features\phrases\ReviewModal.tsx
SIZE: 22.43 KB
LAST MODIFIED: 03/22/2025 22:17:43

'use client';

import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { ChevronLeft, ChevronRight, Flag } from 'lucide-react';
import { supabase } from '@/lib/services/supabase';
import { usePhrases } from '@/features/data/hooks/usePhrases';
import { generateTags, generateHint } from '@/lib/services/claudeService';


interface ReviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  reviewer: Reviewer;
  selectedPhraseId?: number | null;
}

interface EditedPhrase {
  id: number;
  category: string | undefined;
  hint?: string | undefined;
  difficulty?: number | undefined;
  tags?: string[] | undefined;
}

const ReviewModal: React.FC<ReviewModalProps> = ({
  isOpen,
  onClose,
  reviewer,
  selectedPhraseId 
}) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [selectedCategory, setSelectedCategory] = useState<string>('all');
  const [categories, setCategories] = useState<string[]>([]);
  const [isFlagged, setIsFlagged] = useState(false);
  const [isApproved, setIsApproved] = useState(false);
  const [isApproving, setIsApproving] = useState(false);
  const [isGeneratingTags, setIsGeneratingTags] = useState(false);
  const [isGeneratingHint, setIsGeneratingHint] = useState(false);
  const [streak, setStreak] = useState(0);
  const [showCelebration, setShowCelebration] = useState(false);
  const [editedPhrase, setEditedPhrase] = useState<EditedPhrase>({
    id: -1,
    category: undefined,
    hint: undefined,
    difficulty: undefined,
    tags: undefined
  });
  const [hasChanges, setHasChanges] = useState(false);
  
  const {
    phrases,
    loading: phrasesLoading,
    handleFilterChange,
    fetchCategories: fetchCategoriesFromHook,
    fetchPhrases
  } = usePhrases();

  // Fetch categories on load
  useEffect(() => {
    const loadCategories = async () => {
      const fetchedCategories = await fetchCategoriesFromHook();
      if (fetchedCategories) {
        setCategories(fetchedCategories);
      }
    };
    loadCategories();
  }, [fetchCategoriesFromHook]);

  // Reset current index when modal opens or filter changes
  useEffect(() => {
    if (isOpen) {
      setCurrentIndex(0);
      setIsFlagged(false);
      setHasChanges(false);
      
      // Get the reviewer's streak from local storage or set it to 0
      const savedStreak = localStorage.getItem(`reviewer-streak-${reviewer.id}`);
      if (savedStreak) {
        setStreak(parseInt(savedStreak));
      } else {
        setStreak(0);
      }
    }
  }, [isOpen, selectedCategory, reviewer.id]);

  useEffect(() => {
    if (isOpen && selectedPhraseId && phrases.length > 0) {
      const index = phrases.findIndex(p => p.id === selectedPhraseId);
      if (index !== -1) {
        setCurrentIndex(index);
      }
    }
  }, [isOpen, selectedPhraseId, phrases]);
  // Check if current phrase is flagged
  useEffect(() => {
    const checkFlagged = async () => {
      if (!phrases[currentIndex] || !reviewer) return;
      
      try {
        const { data, error } = await supabase
          .from('votes')
          .select('*')
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', false)
          .maybeSingle();
          
        setIsFlagged(!!data);
      } catch (err) {
        console.error('Error checking flag status:', err);
      }
    };
    
    checkFlagged();
  }, [phrases, currentIndex, reviewer]);

  // Check if phrase is already approved
  useEffect(() => {
    const checkApprovalStatus = async () => {
      if (!phrases[currentIndex] || !reviewer) return;
      
      try {
        const { data, error } = await supabase
          .from('votes')
          .select('*')
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', true)
          .maybeSingle();
          
        setIsApproved(!!data);
      } catch (err) {
        console.error('Error checking approval status:', err);
      }
    };
    
    checkApprovalStatus();
  }, [phrases, currentIndex, reviewer]);

  // Load current phrase data
  useEffect(() => {
    const loadPhraseData = async () => {
      if (!phrases[currentIndex]) return;
      
      const currentPhrase = phrases[currentIndex];
      
      if (currentPhrase) {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('name')
          .eq('id', currentPhrase.category_id)
          .single();

        // Get tags as array
        let tagsArray: string[] = [];
        if (currentPhrase.tags) {
          tagsArray = currentPhrase.tags.split(',').map(tag => tag.trim());
        }

        setEditedPhrase({
          id: currentPhrase.id,
          category: categoryData?.name || undefined,
          hint: currentPhrase.hint || undefined,
          difficulty: currentPhrase.difficulty || undefined,
          tags: tagsArray
        });
        
        setHasChanges(false);
      }
    };

    loadPhraseData();
  }, [phrases, currentIndex]);

  const handleCategorySelect = (category: string) => {
    setSelectedCategory(category);
    // If "all" is selected, pass empty string to filter function
    handleFilterChange('category', category === 'all' ? '' : category);
    setCurrentIndex(0);
  };

  const handleNext = () => {
    if (currentIndex < phrases.length - 1) {
      setCurrentIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentIndex(prev => prev - 1);
    }
  };

  // Increment and manage streak
  const incrementStreak = () => {
    const newStreak = streak + 1;
    setStreak(newStreak);
    localStorage.setItem(`reviewer-streak-${reviewer.id}`, newStreak.toString());
    
    // Check if we've hit a milestone (10)
    if (newStreak >= 10) {
      setShowCelebration(true);
      
      // Reset streak after celebration
      setTimeout(() => {
        setStreak(0);
        localStorage.setItem(`reviewer-streak-${reviewer.id}`, '0');
        setShowCelebration(false);
      }, 3000);
    }
    
    // Update reviewer streak in database
    supabase
      .from('reviewers')
      .update({
        current_streak: newStreak % 10, // Keep it within 0-9
        last_review_at: new Date().toISOString()
      })
      .eq('id', reviewer.id)
      .then(() => {})
      .catch(err => console.error('Error updating streak:', err));
  };

  const handleFlag = async () => {
    if (!reviewer || !phrases[currentIndex]) return;
    
    const newFlagState = !isFlagged;
    setIsFlagged(newFlagState);
    
    try {
      if (newFlagState) {
        const { error } = await supabase
          .from('votes')
          .insert({
            reviewer_id: reviewer.id,
            phrase_id: phrases[currentIndex].id,
            category: 'phrase',
            vote: false,
            created_at: new Date().toISOString()
          });
          
        if (error) {
          setIsFlagged(!newFlagState);
          throw error;
        }
      } else {
        const { error } = await supabase
          .from('votes')
          .delete()
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', false);
          
        if (error) {
          setIsFlagged(!newFlagState);
          throw error;
        }
      }
    } catch (err) {
      console.error('Error toggling flag:', err);
    }
  };

  const handleFieldChange = (field: keyof EditedPhrase, value: any) => {
    setEditedPhrase(prev => ({ ...prev, [field]: value }));
    setHasChanges(true);
  };

  const handleTagChange = (index: number, value: string) => {
    const newTags = [...(editedPhrase.tags || ['', '', ''])];
    while (newTags.length < 3) newTags.push('');
    
    newTags[index] = value.trim();
    handleFieldChange('tags', newTags);
  };

  const handleGenerateTags = async () => {
    if (!phrases[currentIndex]?.phrase) return;

    setIsGeneratingTags(true);
    try {
      const result = await generateTags(phrases[currentIndex].phrase);
      if (result.tags.length > 0) {
        const newTags = result.tags.slice(0, 3);
        while (newTags.length < 3) newTags.push('');
        handleFieldChange('tags', newTags);
      }
    } catch (error) {
      console.error('Error generating tags:', error);
    } finally {
      setIsGeneratingTags(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!phrases[currentIndex]?.phrase) return;
  
    setIsGeneratingHint(true);
    try {
      const result = await generateHint(phrases[currentIndex].phrase);
      if (result.hint) {
        handleFieldChange('hint', result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
    } finally {
      setIsGeneratingHint(false);
    }
  };

  const handleApprove = async () => {
    if (!reviewer || !phrases[currentIndex]) return;
    
    setIsApproving(true);
    
    try {
      // Save any changes first if needed
      if (hasChanges) {
        await handleSave();
      }
      
      // Add or update the approval vote
      const { error } = await supabase
        .from('votes')
        .upsert({
          reviewer_id: reviewer.id,
          phrase_id: phrases[currentIndex].id,
          category: 'phrase',
          vote: true,
          created_at: new Date().toISOString()
        });
        
      if (error) throw error;
      
      // Set as approved
      setIsApproved(true);
      
      // Increment streak
      incrementStreak();
      
      // Move to next phrase if not at the end
      if (currentIndex < phrases.length - 1) {
        setCurrentIndex(prev => prev + 1);
      }
    } catch (err) {
      console.error('Error approving phrase:', err);
    } finally {
      setIsApproving(false);
    }
  };
  
  // Original save function for changes only
  const handleSave = async () => {
    if (!editedPhrase.id || editedPhrase.id === -1) return;

    try {
      // Get category ID
      const { data: categoryData } = await supabase
        .from('categories')
        .select('id')
        .eq('name', editedPhrase.category)
        .single();
        
      if (!categoryData) throw new Error('Category not found');
      const categoryId = categoryData.id;
      
      // Update phrase
      const { error: phraseError } = await supabase
        .from('phrases')
        .update({
          hint: editedPhrase.hint,
          difficulty: editedPhrase.difficulty,
          category_id: categoryId,
          subcategory_id: null
        })
        .eq('id', editedPhrase.id);

      if (phraseError) throw phraseError;

      // Handle tags
      if (editedPhrase.tags) {
        const newTags = editedPhrase.tags.filter(Boolean);
        
        // Get existing tags
        const { data: existingTagsData } = await supabase
          .from('phrase_tags')
          .select('tags(id, tag)')
          .eq('phrase_id', editedPhrase.id);

        const existingTags = existingTagsData?.map((pt: any) => pt.tags.tag) || [];

        // Remove tags that are no longer present
        const tagsToRemove = existingTags.filter((tag: string) => !newTags.includes(tag));
        for (const tagToRemove of tagsToRemove) {
          const { data: tagData } = await supabase
            .from('tags')
            .select('id')
            .eq('tag', tagToRemove)
            .single();

          if (tagData) {
            await supabase
              .from('phrase_tags')
              .delete()
              .eq('phrase_id', editedPhrase.id)
              .eq('tag_id', tagData.id);
          }
        }

        // Add new tags
        for (const newTag of newTags) {
          if (!existingTags.includes(newTag)) {
            let tagId: number | undefined;
            const { data: existingTag } = await supabase
              .from('tags')
              .select('id')
              .eq('tag', newTag)
              .single();

            if (existingTag) {
              tagId = existingTag.id;
            } else {
              const { data: newTagData } = await supabase
                .from('tags')
                .insert({ tag: newTag })
                .select('id')
                .single();

              if (newTagData) tagId = newTagData.id;
            }

            if (tagId) {
              await supabase
                .from('phrase_tags')
                .insert({
                  phrase_id: editedPhrase.id,
                  tag_id: tagId
                });
            }
          }
        }
      }

      await fetchPhrases();
      setHasChanges(false);
    } catch (err) {
      console.error('Error saving changes:', err);
      throw err;
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-xl bg-black border border-neutral-800 max-h-[90vh] overflow-y-auto p-6 pt-10">
        <DialogTitle className="sr-only">Review Phrases</DialogTitle>
        <DialogDescription className="sr-only">Review and approve phrases for your collection</DialogDescription>
        
        <div className="flex justify-between items-center mb-5">
          <div>
            <h2 className="text-xl font-bold text-white">Phrase Review</h2>
            <p className="text-sm text-neutral-400">Reviewer: {reviewer.name} ({reviewer.total_reviews || 0} reviews)</p>
          </div>
          
          <Select value={selectedCategory} onValueChange={handleCategorySelect}>
            <SelectTrigger className="w-[180px] bg-transparent border-neutral-700 text-white">
              <SelectValue placeholder="All Categories" />
            </SelectTrigger>
            <SelectContent className="bg-black border border-neutral-700 text-white">
              <SelectItem value="all" className="hover:bg-neutral-800">All Categories</SelectItem>
              {categories.map(category => (
                <SelectItem 
                  key={category} 
                  value={category}
                  className="hover:bg-neutral-800"
                >{category}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        
        {/* Review Hot Streak */}
        <div className="mb-5 space-y-1">
          <div className="text-sm text-neutral-400">Review Hot Streak: {streak}</div>
          <div className="h-2 bg-neutral-800 rounded-full overflow-hidden">
            <div 
              className="h-full bg-gradient-to-r from-orange-500 to-red-500 transition-all"
              style={{ width: `${(streak % 10) * 10}%` }}
            ></div>
          </div>
        </div>
        
        {/* Celebration Overlay */}
        {showCelebration && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="text-center p-8 bg-black border-2 border-orange-500 rounded-lg">
              <div className="text-4xl mb-4">ðŸŽ‰ ðŸ”¥ ðŸŽ‰</div>
              <h3 className="text-2xl font-bold text-white mb-2">Hot Streak Complete!</h3>
              <p className="text-xl text-orange-400">You reviewed 10 phrases!</p>
            </div>
          </div>
        )}
        
        {phrasesLoading ? (
          <div className="flex items-center justify-center py-12">
            <div className="animate-spin h-8 w-8 border-t-2 border-blue-500 rounded-full"></div>
          </div>
        ) : phrases.length === 0 ? (
          <div className="text-center py-8">
            <p className="text-neutral-300 mb-4">No phrases available for review.</p>
            <Button 
              onClick={onClose}
              className="bg-neutral-100 text-black hover:bg-white"
            >
              Close
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Phrase Section */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Phrase</label>
                <Button
                  onClick={handleFlag}
                  variant="ghost"
                  size="sm"
                  className={`h-7 text-xs ${isFlagged ? 'text-red-500' : 'text-neutral-400 hover:text-white'}`}
                >
                  <Flag className="h-3.5 w-3.5 mr-1" />
                  Flag for Removal
                </Button>
              </div>
              <Input
                type="text"
                value={phrases[currentIndex]?.phrase || ''}
                readOnly
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0 rounded-md"
              />
            </div>
            
            {/* Difficulty */}
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Difficulty</label>
              <Select
                value={editedPhrase.difficulty?.toString() || '1'}
                onValueChange={(value) => handleFieldChange('difficulty', parseInt(value))}
              >
                <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                  <SelectValue placeholder="Select difficulty" />
                </SelectTrigger>
                <SelectContent className="bg-black border border-neutral-700 text-white">
                  <SelectItem value="1" className="hover:bg-neutral-800">Easy</SelectItem>
                  <SelectItem value="2" className="hover:bg-neutral-800">Medium</SelectItem>
                  <SelectItem value="3" className="hover:bg-neutral-800">Hard</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            {/* Category */}
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Category</label>
              <Select
                value={editedPhrase.category || ''}
                onValueChange={(value) => handleFieldChange('category', value)}
              >
                <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                  <SelectValue placeholder="Select category" />
                </SelectTrigger>
                <SelectContent className="bg-black border border-neutral-700 text-white">
                  {categories.map(category => (
                    <SelectItem 
                      key={category} 
                      value={category}
                      className="hover:bg-neutral-800"
                    >{category}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            {/* Tags */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Tags</label>
                <Button 
                  onClick={handleGenerateTags}
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs text-neutral-400 hover:text-white"
                  disabled={isGeneratingTags}
                >
                  {isGeneratingTags ? "..." : "ðŸ¤– Ask AI"}
                </Button>
              </div>
              <div className="grid grid-cols-3 gap-2">
                {Array.from({ length: 3 }).map((_, index) => (
                  <Input
                    key={`tag-${index}`}
                    type="text"
                    value={editedPhrase.tags?.[index] || ''}
                    onChange={(e) => handleTagChange(index, e.target.value)}
                    className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                    placeholder={`Tag ${index + 1}`}
                    maxLength={16}
                  />
                ))}
              </div>
            </div>
            
            {/* Hint */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Hint</label>
                <Button 
                  onClick={handleGenerateHint}
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs text-neutral-400 hover:text-white"
                  disabled={isGeneratingHint}
                >
                  {isGeneratingHint ? "..." : "ðŸ¤– Ask AI"}
                </Button>
              </div>
              <Input
                type="text"
                value={editedPhrase.hint || ''}
                onChange={(e) => handleFieldChange('hint', e.target.value)}
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
              />
            </div>

            {/* Actions */}
            <div className="flex justify-between items-center pt-4 mt-4 border-t border-neutral-800">
                <div className="flex items-center gap-1 border border-neutral-700 rounded-md">
                  <Button
                    onClick={handlePrevious}
                    disabled={currentIndex === 0}
                    variant="ghost"
                    className="h-10 px-2 text-neutral-300 hover:bg-neutral-800 hover:text-white disabled:opacity-50 border-r border-neutral-700 rounded-r-none"
                  >
                    <ChevronLeft className="h-4 w-4" />
                  </Button>
                  <span className="px-3 text-neutral-400 text-sm">
                    {currentIndex + 1} / {phrases.length}
                  </span>
                  <Button
                    onClick={handleNext}
                    disabled={currentIndex === phrases.length - 1}
                    variant="ghost"
                    className="h-10 px-2 text-neutral-300 hover:bg-neutral-800 hover:text-white disabled:opacity-50 border-l border-neutral-700 rounded-l-none"
                  >
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                </div>
                
                <Button
                  onClick={handleApprove}
                  className={isApproved 
                    ? "bg-neutral-700 text-white hover:bg-neutral-600" 
                    : "bg-white text-black hover:bg-neutral-200"}
                  disabled={isApproving}
                >
                  {isApproving ? 'Approving...' : isApproved ? 'Approved' : 'Approve'}
                </Button>
            </div>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
};

export default ReviewModal;

============================================================

FILE: .\features\phrases\WordCreatorModal.tsx
SIZE: 19.46 KB
LAST MODIFIED: 03/22/2025 23:48:27

'use client';

import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Loader2 } from 'lucide-react';
import { supabase } from '@/lib/services/supabase';
import { generateTags, generateHint, generatePhrases, suggestCategory } from '@/lib/services/claudeService';
import type { Reviewer } from '@/types/types';

interface WordCreatorModalProps {
  isOpen: boolean;
  onClose: () => void;
  reviewer: Reviewer;
  onWordAdded?: (id?: number) => void;
}

interface NewWord {
  phrase: string;
  category: string;
  difficulty: number;
  hint?: string;
  tags: string[];
}

const WordCreatorModal: React.FC<WordCreatorModalProps> = ({
  isOpen,
  onClose,
  reviewer,
  onWordAdded
}) => {
  const [categories, setCategories] = useState<string[]>([]);
  const [inspiration, setInspiration] = useState('');
  const [newWord, setNewWord] = useState<NewWord>({
    phrase: '',
    category: '',
    difficulty: 1,
    hint: '',
    tags: ['', '', '']
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingTags, setIsGeneratingTags] = useState(false);
  const [isGeneratingHint, setIsGeneratingHint] = useState(false);
  const [isGeneratingCategory, setIsGeneratingCategory] = useState(false);
  const [generatedWords, setGeneratedWords] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [wordGenerated, setWordGenerated] = useState(false);

  // Fetch categories on load
  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const { data, error } = await supabase
          .from('categories')
          .select('name')
          .order('name');
        
        if (error) throw error;
        if (data) setCategories(data.map(c => c.name));
      } catch (err) {
        console.error('Error fetching categories:', err);
        setError('Failed to load categories');
      }
    };

    fetchCategories();
  }, []);

  // Reset form when modal opens
  useEffect(() => {
    if (isOpen) {
      setInspiration('');
      setNewWord({
        phrase: '',
        category: '',
        difficulty: 1,
        hint: '',
        tags: ['', '', '']
      });
      setError(null);
      setSuccess(null);
      setWordGenerated(false);
      setGeneratedWords([]);
    }
  }, [isOpen]);

  const handleChange = (field: keyof NewWord, value: string | number | string[]) => {
    setNewWord(prev => ({ ...prev, [field]: value }));
    setError(null);
  };

  const handleTagChange = (index: number, value: string) => {
    const newTags = [...newWord.tags];
    newTags[index] = value.trim().replace(/\s+/g, '');
    handleChange('tags', newTags);
  };

  const handleGenerateTags = async () => {
    if (!newWord.phrase) {
      setError('Please generate a phrase first');
      return;
    }

    setIsGeneratingTags(true);
    try {
      const result = await generateTags(newWord.phrase);
      if (result.tags.length > 0) {
        const aiTags = result.tags.slice(0, 3);
        const newTags = [...aiTags, ...Array(3 - aiTags.length).fill('')];
        handleChange('tags', newTags);
      }
    } catch (error) {
      console.error('Error generating tags:', error);
      setError('Failed to generate tags');
    } finally {
      setIsGeneratingTags(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!newWord.phrase) {
      setError('Please generate a phrase first');
      return;
    }

    setIsGeneratingHint(true);
    try {
      const result = await generateHint(newWord.phrase);
      if (result.hint) {
        handleChange('hint', result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
      setError('Failed to generate hint');
    } finally {
      setIsGeneratingHint(false);
    }
  };

  const handleGenerateWords = async () => {
    if (!inspiration) {
      setError('Please enter some inspiration first');
      return;
    }

    setIsGenerating(true);
    setError(null);
    
    try {
      // Use the real Claude API to generate phrases
      const result = await generatePhrases(inspiration, 5);
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      if (result.phrases.length > 0) {
        setGeneratedWords(result.phrases);
        
        // Select the first generated word
        const firstPhrase = result.phrases[0];
        
        // Generate tags and hint for the selected phrase
        setIsGeneratingTags(true);
        setIsGeneratingHint(true);
        
        try {
          const [tagsResult, hintResult] = await Promise.all([
            generateTags(firstPhrase),
            generateHint(firstPhrase)
          ]);
          
          setNewWord(prev => ({
            ...prev,
            phrase: firstPhrase,
            hint: hintResult.hint || '',
            tags: tagsResult.tags.slice(0, 3)
          }));
        } catch (error) {
          console.error('Error generating tags/hint:', error);
          // Fallback values if API calls fail
          setNewWord(prev => ({
            ...prev,
            phrase: firstPhrase,
            hint: `Information about ${inspiration}`,
            tags: [`${inspiration}`, 'new', 'word']
          }));
        } finally {
          setIsGeneratingTags(false);
          setIsGeneratingHint(false);
        }
        
        setWordGenerated(true);
      } else {
        setError('No phrases were generated. Please try again with different inspiration.');
      }
    } catch (error) {
      console.error('Error generating phrases:', error);
      setError('Failed to generate phrases. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSelectWord = async (phrase: string) => {
    // Update the word with the selected phrase
    setNewWord(prev => ({
      ...prev,
      phrase
    }));
    
    // Set loading states
    setIsGeneratingTags(true);
    setIsGeneratingHint(true);
    setIsGeneratingCategory(true);
    
    try {
      // Generate tags, hint and category for the selected phrase using Claude
      const [tagsResult, hintResult, categoryResult] = await Promise.all([
        generateTags(phrase),
        generateHint(phrase),
        suggestCategory(phrase, categories)
      ]);
      
      setNewWord(prev => ({
        ...prev,
        hint: hintResult.hint || '',
        tags: tagsResult.tags.slice(0, 3),
        category: categoryResult.category || prev.category
      }));
    } catch (error) {
      console.error('Error generating phrase metadata:', error);
      // Fallback values if API calls fail
      const words = phrase.split(/\s+/);
      setNewWord(prev => ({
        ...prev,
        hint: `About ${words[0]?.toLowerCase() || phrase}`,
        tags: [
          words[0]?.toLowerCase() || 'general',
          phrase.length > 6 ? 'complex' : 'simple',
          words.length > 1 ? 'multi' : 'single'
        ]
      }));
    } finally {
      // Reset loading states
      setIsGeneratingTags(false);
      setIsGeneratingHint(false);
      setIsGeneratingCategory(false);
      
      // Set word as generated
      setWordGenerated(true);
    }
  };

  const handleSubmit = async () => {
    // Validate form
    if (!newWord.phrase) {
      setError('Please enter or generate a phrase');
      return;
    }
    if (!newWord.category) {
      setError('Please select a category');
      return;
    }

    setIsSubmitting(true);
    setError(null);
    
    try {
      // Get category ID
      const { data: categoryData } = await supabase
        .from('categories')
        .select('id')
        .eq('name', newWord.category)
        .single();
      
      if (!categoryData) {
        throw new Error('Category not found');
      }
      
      // Insert phrase
      const { data: phraseData, error: phraseError } = await supabase
        .from('phrases')
        .insert({
          phrase: newWord.phrase,
          category_id: categoryData.id,
          subcategory_id: null, // No subcategory
          difficulty: newWord.difficulty,
          hint: newWord.hint || null,
          created_by: reviewer.id,
          created_at: new Date().toISOString()
        })
        .select('id')
        .single();
      
      if (phraseError) throw phraseError;
      
      // Process tags
      const validTags = newWord.tags.filter(Boolean);
      for (const tag of validTags) {
        // Check if tag exists
        const { data: existingTag } = await supabase
          .from('tags')
          .select('id')
          .eq('tag', tag)
          .single();
          
        let tagId;
        if (existingTag) {
          tagId = existingTag.id;
        } else {
          // Create new tag
          const { data: newTag } = await supabase
            .from('tags')
            .insert({ tag })
            .select('id')
            .single();
            
          if (newTag) tagId = newTag.id;
        }
        
        // Link tag to phrase
        if (tagId && phraseData) {
          await supabase
            .from('phrase_tags')
            .insert({
              phrase_id: phraseData.id,
              tag_id: tagId
            });
        }
      }
      
      // Update reviewer stats
      await supabase
        .from('reviewers')
        .update({
          total_reviews: reviewer.total_reviews + 1,
          last_review_at: new Date().toISOString()
        })
        .eq('id', reviewer.id);
      
      setSuccess('Word added successfully');
      
      // Reset form but keep inspiration
      setTimeout(() => {
        setNewWord({
          phrase: '',
          category: '',
          difficulty: 1,
          hint: '',
          tags: ['', '', '']
        });
        setSuccess(null);
        setWordGenerated(false);
        
        if (onWordAdded) {
          // Pass the ID if available
          if (phraseData && phraseData.id) {
            onWordAdded(phraseData.id);
          } else {
            // Or call without an ID if not available
            onWordAdded();
          }
        }
      }, 1500);
      
    } catch (err) {
      console.error('Error adding word:', err);
      setError('Failed to add word');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-xl bg-black border border-neutral-800 max-h-[90vh] overflow-y-auto p-6 pt-10">
        <DialogTitle className="sr-only">Word Creator</DialogTitle>
        <DialogDescription className="sr-only">Create new phrases for your collection</DialogDescription>
        
        <div className="mb-6">
          <h2 className="text-xl font-bold text-white">Word Creator</h2>
          <p className="text-sm text-neutral-400">Reviewer: {reviewer.name}</p>
        </div>
        
        {error && (
          <div className="mb-4 p-3 rounded bg-red-900/30 border border-red-700 text-red-300 text-sm">
            {error}
          </div>
        )}
        
        {success && (
          <div className="mb-4 p-3 rounded bg-green-900/30 border border-green-700 text-green-300 text-sm">
            {success}
          </div>
        )}
        
        <div className="space-y-4">
          {/* Inspiration Field */}
          <div>
            <label className="block text-sm text-neutral-400 mb-2">Provide Inspiration</label>
            <div className="flex gap-2">
              <Input
                value={inspiration}
                onChange={(e) => setInspiration(e.target.value)}
                placeholder="Enter a theme, topic, or concept"
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
              />
              <Button
                onClick={handleGenerateWords}
                disabled={isGenerating || !inspiration}
                className="bg-white text-black hover:bg-neutral-200 whitespace-nowrap"
              >
                {isGenerating ? (
                  <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Generating...</>
                ) : (
                  <>ðŸ¤– Generate Phrase</>
                )}
              </Button>
            </div>
          </div>
          
          {/* Generated Words List (shown after generation) */}
          {generatedWords.length > 0 && (
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Select a Phrase</label>
              <div className="grid grid-cols-1 gap-2 mb-4">
                {generatedWords.map((phrase, index) => (
                  <Button
                    key={index}
                    variant="outline"
                    className={`justify-start text-left p-3 border-neutral-700 ${newWord.phrase === phrase ? 'bg-neutral-800 border-blue-500' : 'bg-transparent hover:bg-neutral-800'}`}
                    onClick={() => handleSelectWord(phrase)}
                  >
                    {phrase}
                  </Button>
                ))}
              </div>
            </div>
          )}
          
          {/* Phrase Field */}
          {wordGenerated && (
            <>
              <div>
                <label className="block text-sm text-neutral-400 mb-2">Phrase</label>
                <Input
                  value={newWord.phrase}
                  onChange={(e) => handleChange('phrase', e.target.value)}
                  className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              </div>
              
              {/* Difficulty */}
              <div>
                <label className="block text-sm text-neutral-400 mb-2">Difficulty</label>
                <Select
                  value={newWord.difficulty.toString()}
                  onValueChange={(value) => handleChange('difficulty', parseInt(value))}
                >
                  <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                    <SelectValue placeholder="Select difficulty" />
                  </SelectTrigger>
                  <SelectContent className="bg-black border border-neutral-700 text-white">
                    <SelectItem value="1" className="hover:bg-neutral-800">Easy</SelectItem>
                    <SelectItem value="2" className="hover:bg-neutral-800">Medium</SelectItem>
                    <SelectItem value="3" className="hover:bg-neutral-800">Hard</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              {/* Category */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Category</label>
                  {isGeneratingCategory && (
                    <span className="text-xs text-neutral-400">
                      <Loader2 className="inline h-3 w-3 animate-spin mr-1" /> 
                      AI selecting...
                    </span>
                  )}
                </div>
                <Select
                  value={newWord.category}
                  onValueChange={(value) => handleChange('category', value)}
                >
                  <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                    <SelectValue placeholder="Select category" />
                  </SelectTrigger>
                  <SelectContent className="bg-black border border-neutral-700 text-white">
                    {categories.map(category => (
                      <SelectItem 
                        key={category} 
                        value={category}
                        className="hover:bg-neutral-800"
                      >{category}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {newWord.category && (
                  <p className="text-xs text-neutral-400 mt-1">
                    Category selected by AI based on the phrase content
                  </p>
                )}
              </div>
              
              {/* Tags */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Tags</label>
                  <Button 
                    onClick={handleGenerateTags}
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs text-neutral-400 hover:text-white"
                    disabled={isGeneratingTags || !newWord.phrase}
                  >
                    {isGeneratingTags ? "..." : "ðŸ¤– Ask AI"}
                  </Button>
                </div>
                <div className="grid grid-cols-3 gap-2">
                  {Array.from({ length: 3 }).map((_, index) => (
                    <Input
                      key={`tag-${index}`}
                      type="text"
                      value={newWord.tags[index] || ''}
                      onChange={(e) => handleTagChange(index, e.target.value)}
                      className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                      placeholder={`Tag ${index + 1}`}
                      maxLength={16}
                    />
                  ))}
                </div>
              </div>
              
              {/* Hint */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Hint</label>
                  <Button 
                    onClick={handleGenerateHint}
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs text-neutral-400 hover:text-white"
                    disabled={isGeneratingHint || !newWord.phrase}
                  >
                    {isGeneratingHint ? "..." : "ðŸ¤– Ask AI"}
                  </Button>
                </div>
                <Input
                  type="text"
                  value={newWord.hint || ''}
                  onChange={(e) => handleChange('hint', e.target.value)}
                  className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              </div>
              
              {/* Submit Button */}
              <div className="flex justify-end pt-4 mt-4 border-t border-neutral-800">
                <Button
                  onClick={handleSubmit}
                  disabled={isSubmitting || !newWord.phrase || !newWord.category}
                  className="bg-white text-black hover:bg-neutral-200"
                >
                  {isSubmitting ? (
                    <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Adding...</>
                  ) : (
                    'Add Word'
                  )}
                </Button>
              </div>
            </>
          )}
          
          {!wordGenerated && !isGenerating && generatedWords.length === 0 && (
            <div className="flex flex-col items-center justify-center py-12 text-neutral-400">
              <p className="mb-2">Enter some inspiration and click Generate</p>
              <p className="text-sm">Example: "medical terms", "sports activities", "cooking verbs"</p>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default WordCreatorModal;

============================================================

FILE: .\features\phrases\hooks\useDeletePhrase.ts
SIZE: 0.97 KB
LAST MODIFIED: 03/21/2025 09:26:33

// features/phrases/hooks/useDeletePhrase.ts
import { useState } from 'react';
import { supabase } from '@/lib/services/supabase';

export const useDeletePhrase = () => {
  const [isDeleting, setIsDeleting] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const mutate = async (id: number, options?: { onSuccess?: () => void }) => {
    setIsDeleting(true);
    setError(null);
    
    try {
      const { error: deleteError } = await supabase
        .from('phrases')
        .delete()
        .eq('id', id);
        
      if (deleteError) {
        throw deleteError;
      }
      
      if (options?.onSuccess) {
        options.onSuccess();
      }
    } catch (err) {
      console.error('Error deleting phrase:', err);
      setError(err instanceof Error ? err : new Error('An unknown error occurred'));
    } finally {
      setIsDeleting(false);
    }
  };
  
  return {
    mutate,
    isDeleting,
    error
  };
};

============================================================

FILE: .\features\phrases\phrasesTable\index.tsx
SIZE: 20.73 KB
LAST MODIFIED: 03/23/2025 16:05:44

import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import { Search, Columns, Pencil, Trash, ChevronLeft, ChevronRight, MoreHorizontal, X } from 'lucide-react';
import TagDisplay from '@/components/ui/tags';
import { DifficultyIndicator } from '@/components/ui/difficulty-indicator';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuCheckboxItem,
} from "@/components/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Check } from 'lucide-react';
import { cn } from '@/lib/utils';
import { supabase } from '@/lib/services/supabase';
import { useTheme } from '@/providers/ThemeContext';

interface PhrasesTableProps {
  phrases: any[];
  loading?: boolean;
  tableState: TableState;
  onTableStateChange: (updates: Partial<TableState>) => void;
  onEdit?: (id: number) => void;
  onDelete?: (id: number) => void;
  newIds?: number[];
  onShowFilters?: () => void;
}

export function PhrasesTable({
  phrases,
  loading = false,
  tableState,
  onTableStateChange,
  onEdit,
  onDelete,
  newIds = [],
  onShowFilters
}: PhrasesTableProps) {
  const [selectedRows, setSelectedRows] = useState<number[]>([]);
  const [searchValue, setSearchValue] = useState(tableState.filters.search || '');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const { accent } = useTheme();

  // Get accent-specific color values for various parts of the UI
  const getAccentColors = () => {
    switch (accent) {
      case 'blue':
        return {
          highlight: 'bg-blue-500/10 border-blue-500/30',
          button: 'bg-blue-500 hover:bg-blue-600',
          outline: 'border-blue-500/50 text-blue-500',
          text: 'text-blue-500'
        };
      case 'green':
        return {
          highlight: 'bg-emerald-500/10 border-emerald-500/30',
          button: 'bg-emerald-500 hover:bg-emerald-600',
          outline: 'border-emerald-500/50 text-emerald-500',
          text: 'text-emerald-500'
        };
      case 'purple':
        return {
          highlight: 'bg-purple-500/10 border-purple-500/30',
          button: 'bg-purple-500 hover:bg-purple-600',
          outline: 'border-purple-500/50 text-purple-500',
          text: 'text-purple-500'
        };
      case 'orange':
        return {
          highlight: 'bg-orange-500/10 border-orange-500/30',
          button: 'bg-orange-500 hover:bg-orange-600',
          outline: 'border-orange-500/50 text-orange-500',
          text: 'text-orange-500'
        };
      default: // grayscale
        return {
          highlight: 'bg-gray-500/10 border-gray-500/30',
          button: 'bg-gray-500 hover:bg-gray-600',
          outline: 'border-gray-500/50 text-gray-500',
          text: 'text-gray-500'
        };
    }
  };

  const accentColors = getAccentColors();

  // Columns configuration for dropdown
  const columns = [
    { key: 'phrase', label: 'Phrase' },
    { key: 'category', label: 'Category' },
    { key: 'hint', label: 'Hint' }, 
    { key: 'tags', label: 'Tags' },
    { key: 'difficulty', label: 'Difficulty' },
    { key: 'reviewed', label: 'Reviewed' }
  ];

  // Current visible columns
  const [hiddenColumns, setHiddenColumns] = useState<string[]>([]);

  // Helper function to get difficulty bar
  const getDifficultyBar = (difficulty: number) => {
    return <DifficultyIndicator difficulty={difficulty} />;
  };

  // Handle search input changes
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchValue(e.target.value);
  };

  // Global search across the entire database - Only search phrase column
  const performGlobalSearch = async () => {
    if (!searchValue.trim()) {
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: ''
        }
      });
      return;
    }

    setIsSearching(true);
    try {
      const searchTerm = searchValue.toLowerCase().trim();
      
      // Search only the phrase column
      const { data, error } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(name),
          subcategories:subcategory_id(name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `)
        .ilike('phrase', `%${searchTerm}%`); // Only search in phrase column

      if (error) throw error;

      const transformedData = (data || []).map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      // Update search results and pagination
      setSearchResults(transformedData);
      
      // Update filter state
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: searchValue
        },
        pagination: {
          ...tableState.pagination,
          currentPage: 1,
          totalItems: transformedData.length,
          totalPages: Math.ceil(transformedData.length / tableState.pagination.rowsPerPage)
        }
      });
    } catch (err) {
      console.error('Error searching phrases:', err);
    } finally {
      setIsSearching(false);
    }
  };

  // Handle enter key
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      performGlobalSearch();
    }
  };

  // Clear search
  const clearSearch = () => {
    setSearchValue('');
    setSearchResults([]);
    onTableStateChange({
      filters: {
        ...tableState.filters,
        search: ''
      }
    });
  };

  const handleRowsPerPageChange = (value: string) => {
    const newRowsPerPage = parseInt(value, 10);
    
    // Call the parent component's handler
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        rowsPerPage: newRowsPerPage,
        currentPage: 1  // Reset to page 1 when changing rows per page
      }
    });
  };

  const handlePageChange = (newPage: number) => {
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        currentPage: newPage
      }
    });
  };

  const handleSort = (key: string) => {
    onTableStateChange({
      sortConfig: {
        key,
        direction: 
          tableState.sortConfig.key === key && 
          tableState.sortConfig.direction === 'asc' ? 'desc' : 'asc'
      }
    });
  };

  const toggleSelectAll = () => {
    if (selectedRows.length === phrases.length) {
      setSelectedRows([]);
    } else {
      setSelectedRows(phrases.map(phrase => phrase.id));
    }
  };

  const toggleRowSelection = (id: number) => {
    if (selectedRows.includes(id)) {
      setSelectedRows(prev => prev.filter(rowId => rowId !== id));
    } else {
      setSelectedRows(prev => [...prev, id]);
    }
  };

  const handleBulkDelete = async () => {
    if (selectedRows.length > 0 && window.confirm(`Are you sure you want to delete ${selectedRows.length} phrases?`)) {
      for (const id of selectedRows) {
        await onDelete?.(id);
      }
      setSelectedRows([]);
    }
  };

  // Determine which data to show
  const displayData = searchValue && searchResults.length > 0 ? searchResults : phrases;

  // Create flash animation class with accent color
  const getNewRowClass = (id: number) => {
    if (!newIds.includes(id)) return '';
    
    return cn("transition-colors", accentColors.highlight);
  };

  return (
    <div className="space-y-2">
      {/* Top toolbar with pagination and search */}
      <div className="flex flex-wrap items-center justify-between pb-4">
        <div className="flex items-center gap-4">
          {/* Rows per page dropdown */}
          <Select
            value={tableState.pagination.rowsPerPage.toString()}
            onValueChange={handleRowsPerPageChange}
          >
            <SelectTrigger className={cn("w-[120px] border", accentColors.outline)}>
              <SelectValue placeholder={`${tableState.pagination.rowsPerPage} per page`} />
            </SelectTrigger>
            <SelectContent>
              {[10, 25, 50, 100].map(value => (
                <SelectItem key={value} value={value.toString()}>
                  {value} per page
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          
          {/* Page info */}
          <span className="text-sm text-muted-foreground">
            {tableState.pagination.totalPages > 0
              ? `Page ${tableState.pagination.currentPage} of ${tableState.pagination.totalPages}`
              : 'No results'}
          </span>
        </div>

        <div className="flex items-center gap-2">
          {/* Search input */}
          <div className="relative w-full md:w-64">
            <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
              <Search className="h-4 w-4 text-muted-foreground" />
            </div>
            <Input
              placeholder="Search phrases..."
              value={searchValue}
              onChange={handleSearchChange}
              onKeyDown={handleKeyDown}
              onBlur={performGlobalSearch}
              className={cn("pl-10 pr-10 border", accentColors.outline)}
            />
            {searchValue && (
              <button
                onClick={clearSearch}
                className="absolute inset-y-0 right-0 flex items-center pr-3 text-muted-foreground hover:text-foreground"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
          
          {/* Column visibility */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className={cn("h-9 border", accentColors.outline)}>
                <Columns className={cn("mr-2 h-4 w-4", accentColors.text)} />
                Columns
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {columns.map((column) => (
                <DropdownMenuCheckboxItem
                  key={column.key}
                  checked={!hiddenColumns.includes(column.key)}
                  onCheckedChange={(checked) => {
                    setHiddenColumns(prev => 
                      checked 
                        ? prev.filter(key => key !== column.key)
                        : [...prev, column.key]
                    );
                  }}
                >
                  {column.label}
                </DropdownMenuCheckboxItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
          
          {/* Pagination buttons */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(tableState.pagination.currentPage - 1)}
            disabled={tableState.pagination.currentPage <= 1}
            className={cn("border", accentColors.outline)}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(tableState.pagination.currentPage + 1)}
            disabled={tableState.pagination.currentPage >= tableState.pagination.totalPages}
            className={cn("border", accentColors.outline)}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Main table */}
      <div className={cn("rounded-md p-1 border", accentColors.outline)}>
        <Table>
          <TableHeader className="bg-card">
            <TableRow>
              {/* Checkbox column */}
              <TableHead className="w-12">
                <Checkbox
                  checked={selectedRows.length > 0 && selectedRows.length === displayData.length}
                  indeterminate={selectedRows.length > 0 && selectedRows.length < displayData.length ? true : undefined}
                  onCheckedChange={toggleSelectAll}
                  className={accentColors.text}
                />
              </TableHead>
              
              {/* Phrase column */}
              {!hiddenColumns.includes('phrase') && (
                <TableHead onClick={() => handleSort('phrase')} className="cursor-pointer">
                  Phrase
                  {tableState.sortConfig.key === 'phrase' && (
                    <span className={cn("ml-1", accentColors.text)}>
                      {tableState.sortConfig.direction === 'asc' ? 'â†‘' : 'â†“'}
                    </span>
                  )}
                </TableHead>
              )}
              
              {/* Category column */}
              {!hiddenColumns.includes('category') && (
                <TableHead onClick={() => handleSort('category')} className="cursor-pointer">
                  Category
                  {tableState.sortConfig.key === 'category' && (
                    <span className={cn("ml-1", accentColors.text)}>
                      {tableState.sortConfig.direction === 'asc' ? 'â†‘' : 'â†“'}
                    </span>
                  )}
                </TableHead>
              )}
              
              {/* Hint column - Moved here */}
              {!hiddenColumns.includes('hint') && (
                <TableHead onClick={() => handleSort('hint')} className="cursor-pointer">
                  Hint
                  {tableState.sortConfig.key === 'hint' && (
                    <span className={cn("ml-1", accentColors.text)}>
                      {tableState.sortConfig.direction === 'asc' ? 'â†‘' : 'â†“'}
                    </span>
                  )}
                </TableHead>
              )}
              
              {/* Tags column */}
              {!hiddenColumns.includes('tags') && (
                <TableHead onClick={() => handleSort('tags')} className="cursor-pointer">
                  Tags
                  {tableState.sortConfig.key === 'tags' && (
                    <span className={cn("ml-1", accentColors.text)}>
                      {tableState.sortConfig.direction === 'asc' ? 'â†‘' : 'â†“'}
                    </span>
                  )}
                </TableHead>
              )}
              
              {/* Difficulty column */}
              {!hiddenColumns.includes('difficulty') && (
                <TableHead onClick={() => handleSort('difficulty')} className="cursor-pointer">
                  Difficulty
                  {tableState.sortConfig.key === 'difficulty' && (
                    <span className={cn("ml-1", accentColors.text)}>
                      {tableState.sortConfig.direction === 'asc' ? 'â†‘' : 'â†“'}
                    </span>
                  )}
                </TableHead>
              )}
              
              {/* Reviewed column */}
              {!hiddenColumns.includes('reviewed') && (
                <TableHead>Reviewed</TableHead>
              )}
              
              {/* Actions column */}
              <TableHead className="w-[80px]">
                {selectedRows.length > 0 ? (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={handleBulkDelete}
                    className="h-8"
                  >
                    <Trash className="h-4 w-4 mr-2" />
                    Delete
                  </Button>
                ) : null}
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading || isSearching ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  {isSearching ? 'Searching...' : 'Loading...'}
                </TableCell>
              </TableRow>
            ) : displayData.length === 0 ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  No phrases found.
                </TableCell>
              </TableRow>
            ) : (
              displayData.map((phrase) => (
                <TableRow 
                  key={phrase.id}
                  className={cn(
                    selectedRows.includes(phrase.id) && accentColors.highlight,
                    getNewRowClass(phrase.id)
                  )}
                >
                  {/* Checkbox */}
                  <TableCell className="w-12">
                    <Checkbox
                      checked={selectedRows.includes(phrase.id)}
                      onCheckedChange={() => toggleRowSelection(phrase.id)}
                      className={accentColors.text}
                    />
                  </TableCell>
                  
                  {/* Phrase */}
                  {!hiddenColumns.includes('phrase') && (
                    <TableCell className="font-medium">{phrase.phrase}</TableCell>
                  )}
                  
                  {/* Category */}
                  {!hiddenColumns.includes('category') && (
                    <TableCell>{phrase.category}</TableCell>
                  )}
                  
                  {/* Hint - Moved here */}
                  {!hiddenColumns.includes('hint') && (
                    <TableCell>{phrase.hint || '-'}</TableCell>
                  )}
                  
                  {/* Tags */}
                  {!hiddenColumns.includes('tags') && (
                    <TableCell>
                      <TagDisplay tags={phrase.tags || ''} />
                    </TableCell>
                  )}
                  
                  {/* Difficulty - Bar Style */}
                  {!hiddenColumns.includes('difficulty') && (
                    <TableCell>
                      {getDifficultyBar(phrase.difficulty)}
                    </TableCell>
                  )}
                  
                  {/* Reviewed Status */}
                  {!hiddenColumns.includes('reviewed') && (
                    <TableCell>
                      <div className="flex justify-center">
                        {phrase.reviewed ? (
                          <Check className={cn("h-5 w-5", accentColors.text)} />
                        ) : (
                          <Check className="h-5 w-5 text-gray-300" />
                        )}
                      </div>
                    </TableCell>
                  )}
                  
                  {/* Actions */}
                  <TableCell>
                    <div className="flex justify-end">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" className="h-8 w-8 p-0">
                            <span className="sr-only">Open menu</span>
                            <MoreHorizontal className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuLabel>Actions</DropdownMenuLabel>
                          <DropdownMenuItem onClick={() => onEdit?.(phrase.id)}>
                            <Pencil className={cn("h-4 w-4 mr-2", accentColors.text)} />
                            Edit
                          </DropdownMenuItem>
                          <DropdownMenuSeparator />
                          <DropdownMenuItem 
                            onClick={() => {
                              if (window.confirm('Are you sure you want to delete this phrase?')) {
                                onDelete?.(phrase.id);
                              }
                            }}
                            className="text-red-600"
                          >
                            <Trash className="h-4 w-4 mr-2" />
                            Delete
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}

============================================================

FILE: .\features\phrases\stores\filterContext.tsx
SIZE: 1.63 KB
LAST MODIFIED: 03/21/2025 09:15:13

// features/phrases/stores/filterContext.tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface FilterState {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
  page: number;
  pageSize: number;
  sortBy: string;
  sortDirection: 'asc' | 'desc';
}

interface FilterContextValue extends FilterState {
  setFilter: (key: string, value: string | number) => void;
  resetFilters: () => void;
}

const defaultState: FilterState = {
  searchTerm: '',
  category: '',
  difficulty: '',
  subcategory: '',
  part_of_speech: '',
  page: 1,
  pageSize: 10,
  sortBy: 'id',
  sortDirection: 'desc'
};

const FilterContext = createContext<FilterContextValue | undefined>(undefined);

export function FilterProvider({ children }: { children: ReactNode }) {
  const [filters, setFilters] = useState<FilterState>(defaultState);

  const setFilter = (key: string, value: string | number) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
      // Reset to page 1 when changing filters
      ...(key !== 'page' ? { page: 1 } : {})
    }));
  };

  const resetFilters = () => {
    setFilters(defaultState);
  };

  return (
    <FilterContext.Provider
      value={{
        ...filters,
        setFilter,
        resetFilters
      }}
    >
      {children}
    </FilterContext.Provider>
  );
}

export function useFilter() {
  const context = useContext(FilterContext);
  if (context === undefined) {
    throw new Error('useFilter must be used within a FilterProvider');
  }
  return context;
}

============================================================

FILE: .\hooks\useToast.ts
SIZE: 3.93 KB
LAST MODIFIED: 03/22/2025 23:37:09

// hooks/useToast.ts
import * as React from "react"
import { ToastActionElement, ToastProps } from "@/components/ui/toast"

const TOAST_LIMIT = 5
const TOAST_REMOVE_DELAY = 5000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast> & { id: string }
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: string
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: string
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: actionTypes.REMOVE_TOAST,
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case actionTypes.ADD_TOAST:
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case actionTypes.UPDATE_TOAST:
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case actionTypes.DISMISS_TOAST: {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case actionTypes.REMOVE_TOAST:
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast(props: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: actionTypes.UPDATE_TOAST,
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: actionTypes.DISMISS_TOAST, toastId: id })

  dispatch({
    type: actionTypes.ADD_TOAST,
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: actionTypes.DISMISS_TOAST, toastId }),
  }
}

export { useToast, toast }

============================================================

FILE: .\lib\theme-utils.ts
SIZE: 0.79 KB
LAST MODIFIED: 03/23/2025 12:55:34

// lib/theme-utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

type ThemeVariants<T> = Record<string, T>;

export function themeCn<T>(variants: ThemeVariants<T>, variant: string): T {
  return variants[variant] || variants.default;
}

export function getThemeValue(obj: any, path: string, fallback?: any): any {
  return path.split('.').reduce((o, p) => (o ? o[p] : undefined), obj) || fallback;
}

export function getCssVar(name: string, fallback?: string): string {
  if (typeof window === 'undefined') return fallback || '';
  
  const style = getComputedStyle(document.documentElement);
  const value = style.getPropertyValue(name).trim();
  
  return value || fallback || '';
}


============================================================

FILE: .\lib\utils.ts
SIZE: 0.16 KB
LAST MODIFIED: 03/04/2025 21:05:08

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


============================================================

FILE: .\lib\services\claudeService.ts
SIZE: 5.79 KB
LAST MODIFIED: 03/23/2025 00:01:04

'use client';

export interface GenerateTagsResponse {
  tags: string[];
  error?: string;
}

export interface GenerateHintResponse {
  hint: string;
  error?: string;
}

export interface GeneratePhrasesResponse {
  phrases: string[];
  error?: string;
}

export interface SuggestCategoryResponse {
  category: string;
  error?: string;
}

const makeClaudeRequest = async (messages: Array<{ role: string; content: string }>) => {
  const response = await fetch('/api/claude', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ messages })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('API error response:', errorText);
    throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
  }

  return await response.json();
};

export const generateTags = async (phrase: string): Promise<GenerateTagsResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate exactly 3 descriptive tags for this catch phrase: "${phrase}".
                Rules for tags:
                1. Must be single words, no spaces or hyphens
                2. All lowercase
                3. Maximum 15 characters per tag
                4. No special characters or numbers
                5. No generic words like "fun" or "game"
                6. Focus on theme, subject matter, or skill required
                7. Avoid duplicate meaning tags
                
                Return only the 3 tags separated by commas, nothing else.
                Example format: strategy,teamwork,creativity`
    }]);

    const tags = data.content[0].text
      .split(',')
      .map((tag: string) => tag.trim())
      .filter((tag: string) => 
        tag.length <= 15 && 
        /^[a-z]+$/.test(tag) &&
        !['fun', 'game', 'play'].includes(tag)
      );

    if (tags.length !== 3) {
      throw new Error('Invalid tag generation result');
    }

    return { tags };
  } catch (error) {
    console.error('Error generating tags:', error);
    return {
      tags: [],
      error: error instanceof Error ? error.message : 'Failed to generate tags'
    };
  }
};

export const generateHint = async (phrase: string): Promise<GenerateHintResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Create a VERY SHORT helpful hint for the catch phrase: "${phrase}".
                Rules for hints:
                1. MUST BE 20 CHARACTERS OR LESS - THIS IS CRITICAL
                2. Don't reveal the exact answer
                3. Focus on context or category
                4. No direct synonyms
                5. Can be a clever riddle or wordplay
                6. Should help players think in right direction
                7. No explicit "This is..." or "Think about..." phrases
                
                Return only the hint text, nothing else.
                Example: For "BOOKWORM" -> "Reads a lot"`
    }]);

    const hint = data.content[0].text.trim();

    if (hint.length > 20) {
      // Truncate if still over limit, keeping it to 20 characters
      return { hint: hint.substring(0, 20) };
    }

    return { hint };
  } catch (error) {
    console.error('Error generating hint:', error);
    return {
      hint: '',
      error: error instanceof Error ? error.message : 'Failed to generate hint'
    };
  }
};

export const generatePhrases = async (inspiration: string, count: number = 5): Promise<GeneratePhrasesResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate ${count} unique and interesting catch phrases or words based on this inspiration: "${inspiration}".
                Rules for generated words/phrases:
                1. Mix of single words and short phrases (2-3 words)
                2. Suitable for a word game
                3. Each entry should be distinct and creative
                4. No extremely obscure terms
                5. Family-friendly content only
                6. No proper nouns unless very well known
                7. Varying difficulty levels
                
                Return only the list of words/phrases separated by commas, nothing else.
                Example format: Slumber party, DÃ©jÃ  vu, Photograph, Brain teaser, Pumpkin spice`
    }]);

    const phrases = data.content[0].text
      .split(',')
      .map((phrase: string) => phrase.trim())
      .filter((phrase: string) => phrase.length > 0);

    if (phrases.length === 0) {
      throw new Error('No phrases were generated');
    }

    return { phrases };
  } catch (error) {
    console.error('Error generating phrases:', error);
    return {
      phrases: [],
      error: error instanceof Error ? error.message : 'Failed to generate phrases'
    };
  }
};

export const suggestCategory = async (phrase: string, categories: string[]): Promise<SuggestCategoryResponse> => {
  try {
    const response = await fetch('/api/claude/suggest-category', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        phrase,
        categories
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('API error response:', errorText);
      throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
    }

    const data = await response.json();
    return { category: data.category };
  } catch (error) {
    console.error('Error suggesting category:', error);
    return {
      category: '',
      error: error instanceof Error ? error.message : 'Failed to suggest category'
    };
  }
};

============================================================

FILE: .\lib\services\supabase.ts
SIZE: 0.55 KB
LAST MODIFIED: 02/18/2025 10:42:19

import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/supabase'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  }
})

export const checkAuth = async () => {
  if (typeof window === 'undefined') {
    return null
  }
  const { data: { session } } = await supabase.auth.getSession()
  return session
}

============================================================

FILE: .\providers\ThemeContext.tsx
SIZE: 2.44 KB
LAST MODIFIED: 03/23/2025 15:59:21

// providers/ThemeContext.tsx
'use client';

import React, { createContext, useContext, useState, useEffect } from 'react';
import { ThemeProvider as NextThemesProvider, useTheme as useNextTheme } from 'next-themes';

export type ThemeMode = 'light' | 'dark' | 'system';
export type ColorAccent = 'default' | 'blue' | 'green' | 'purple' | 'orange';

interface ThemeContextType {
  accent: ColorAccent;
  setAccent: (accent: ColorAccent) => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children, ...props }) {
  // Get the initial accent value from localStorage if available
  const [accent, setAccentState] = useState<ColorAccent>('default');
  const [mounted, setMounted] = useState(false);
  
  // Set up accent color with localStorage persistence
  const setAccent = (newAccent: ColorAccent) => {
    setAccentState(newAccent);
    // Save to localStorage
    if (typeof window !== 'undefined') {
      localStorage.setItem('theme-accent', newAccent);
    }
  };
  
  // Initialize from localStorage on mount
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedAccent = localStorage.getItem('theme-accent');
      if (savedAccent && ['default', 'blue', 'green', 'purple', 'orange'].includes(savedAccent)) {
        setAccentState(savedAccent as ColorAccent);
      }
      
      // Apply the accent to the HTML element
      document.documentElement.setAttribute('data-accent', accent);
    }
    setMounted(true);
  }, [accent]);
  
  // Prevent hydration mismatch
  if (!mounted) {
    return <>{children}</>;
  }
  
  return (
    <NextThemesProvider attribute="class" defaultTheme="dark" enableSystem {...props}>
      <ThemeContext.Provider 
        value={{
          accent,
          setAccent,
        }}
      >
        {children}
      </ThemeContext.Provider>
    </NextThemesProvider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  const { theme, setTheme, resolvedTheme, systemTheme } = useNextTheme();
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return {
    ...context,
    theme: theme as ThemeMode,
    setTheme,
    resolvedTheme: resolvedTheme as ThemeMode,
    systemTheme: systemTheme as ThemeMode,
    toggleTheme: () => setTheme(resolvedTheme === 'dark' ? 'light' : 'dark'),
    isLight: resolvedTheme === 'light',
    isDark: resolvedTheme === 'dark',
  };
}

============================================================

FILE: .\providers\ThemeProvider.tsx
SIZE: 0.77 KB
LAST MODIFIED: 03/06/2025 21:02:46

"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

/**
 * Hook for using the theme
 * @returns Theme utilities including theme, setTheme, and systemTheme
 */
export function useTheme() {
  const { theme, setTheme, systemTheme } = React.useContext(
    // @ts-ignore - This context does exist in next-themes
    require("next-themes").ThemeContext
  )
  
  return { 
    theme, 
    setTheme, 
    systemTheme,
    toggleTheme: () => setTheme(theme === "dark" ? "light" : "dark")
  }
}

============================================================

FILE: .\providers\ToastProvider.tsx
SIZE: 1.33 KB
LAST MODIFIED: 03/22/2025 23:33:46

'use client';

import React, { useState, useCallback } from 'react';
import { ToastActionElement, ToastProps } from '@/components/ui/toast';
import { Toaster } from '@/components/ui/toaster';

export type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const TOAST_LIMIT = 5;

type ToastContextType = {
  toasts: ToasterToast[];
  toast: (props: Omit<ToasterToast, "id">) => void;
  dismiss: (toastId: string) => void;
};

// Create a context with a no-op default
export const ToastContext = React.createContext<ToastContextType>({
  toasts: [],
  toast: () => {},
  dismiss: () => {},
});

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<ToasterToast[]>([]);

  const toast = useCallback((props: Omit<ToasterToast, "id">) => {
    const id = Math.random().toString(36).substring(2, 9);
    setToasts((prev) => [{ ...props, id }, ...prev].slice(0, TOAST_LIMIT));
    return id;
  }, []);

  const dismiss = useCallback((toastId: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== toastId));
  }, []);

  return (
    <ToastContext.Provider value={{ toasts, toast, dismiss }}>
      {children}
      <Toaster />
    </ToastContext.Provider>
  );
}

============================================================

FILE: .\services\dashboard-data-service.ts
SIZE: 10.85 KB
LAST MODIFIED: 03/21/2025 18:39:36

// src/services/dashboard-data-service.ts
import { supabase } from '@/lib/services/supabase';

export interface DashboardStats {
  newPhrases: {
    value: number;
    trend: number;
    sparkline: number[];
  };
  reviewedPhrases: {
    value: number;
    trend: number;
    sparkline: number[];
  };
  activeReviewers: {
    value: number;
    trend: number;
  };
  topReviewer: {
    name: string;
    count: number;
    streak: number;
  };
}

export const DashboardDataService = {
  // Fetch dashboard stats
  fetchDashboardStats: async (dateRange = 30): Promise<DashboardStats | null> => {
    try {
      // Calculate date ranges for current period and previous period
      const currentStart = new Date();
      currentStart.setDate(currentStart.getDate() - dateRange);
      
      const previousStart = new Date(currentStart);
      previousStart.setDate(previousStart.getDate() - dateRange);
      
      const currentStartStr = currentStart.toISOString();
      const previousStartStr = previousStart.toISOString();
      const now = new Date().toISOString();
      
      // 1. New Phrases in the Last Month
      const { data: newPhrasesData, error: newPhrasesError } = await supabase
        .from('phrases')
        .select('id, created_at')
        .gte('created_at', currentStartStr)
        .order('created_at', { ascending: true });
      
      if (newPhrasesError) {
        console.error("New phrases query error:", newPhrasesError);
        throw newPhrasesError;
      }
      
      // 2. Calculate previous period for trend
      const { count: previousNewPhrasesCount, error: previousNewPhrasesError } = await supabase
        .from('phrases')
        .select('id', { count: 'exact', head: true })
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousNewPhrasesError) {
        console.error("Previous phrases query error:", previousNewPhrasesError);
        throw previousNewPhrasesError;
      }
      
      // 3. Phrases Reviewed in the Last Month
      const { data: reviewedPhrasesData, error: reviewedPhrasesError } = await supabase
        .from('votes')
        .select('id, created_at')
        .gte('created_at', currentStartStr)
        .order('created_at', { ascending: true });
      
      if (reviewedPhrasesError) {
        console.error("Reviewed phrases query error:", reviewedPhrasesError);
        throw reviewedPhrasesError;
      }
      
      // 4. Calculate previous period for trend
      const { count: previousReviewedCount, error: previousReviewedError } = await supabase
        .from('votes')
        .select('id', { count: 'exact', head: true })
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousReviewedError) {
        console.error("Previous reviewed query error:", previousReviewedError);
        throw previousReviewedError;
      }
      
      // 5. Active Reviewers Count
      const { data: activeReviewers, error: activeReviewersError } = await supabase
        .from('votes')
        .select('reviewer_id')
        .gte('created_at', currentStartStr);
      
      if (activeReviewersError) {
        console.error("Active reviewers query error:", activeReviewersError);
        throw activeReviewersError;
      }
      
      // Get unique reviewer IDs
      const uniqueReviewerIds = [...new Set(activeReviewers?.map(item => item.reviewer_id))];
      
      // 6. Calculate previous period for trend
      const { data: previousActiveReviewers, error: previousActiveReviewersError } = await supabase
        .from('votes')
        .select('reviewer_id')
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousActiveReviewersError) {
        console.error("Previous active reviewers query error:", previousActiveReviewersError);
        throw previousActiveReviewersError;
      }
      
      const previousUniqueReviewerIds = [...new Set(previousActiveReviewers?.map(item => item.reviewer_id))];
      
      // 7. Top Reviewer - Use a different approach for this query
      // First get counts for each reviewer
      const { data: reviewCounts, error: reviewCountsError } = await supabase
        .rpc('get_reviewer_counts', { start_date: currentStartStr });
        
      if (reviewCountsError) {
        console.error("Review counts query error:", reviewCountsError);
        // Fallback approach if RPC doesn't exist
        console.log("Falling back to manual aggregation...");
        // Get all reviewer_ids and manually count them
        const { data: allVotes, error: allVotesError } = await supabase
          .from('votes')
          .select('reviewer_id')
          .gte('created_at', currentStartStr);
          
        if (allVotesError) {
          console.error("All votes query error:", allVotesError);
          throw allVotesError;
        }
        
        // Create a counts object
        const counts = {};
        allVotes?.forEach(vote => {
          if (vote.reviewer_id) {
            counts[vote.reviewer_id] = (counts[vote.reviewer_id] || 0) + 1;
          }
        });
        
        // Convert to array and sort
        const reviewerCounts = Object.entries(counts).map(([reviewer_id, count]) => ({
          reviewer_id,
          count
        })).sort((a, b) => b.count - a.count);
        
        // Get top reviewer
        const topReviewerId = reviewerCounts.length > 0 ? reviewerCounts[0].reviewer_id : null;
        const topReviewerCount = reviewerCounts.length > 0 ? reviewerCounts[0].count : 0;
        
        // 8. Get reviewer details
        let topReviewer = { name: 'N/A', count: 0, streak: 0 };
        
        if (topReviewerId) {
          const { data: reviewerData, error: reviewerError } = await supabase
            .from('reviewers')
            .select('id, name, current_streak')
            .eq('id', topReviewerId)
            .single();
          
          if (reviewerError) {
            console.error("Reviewer details query error:", reviewerError);
          } else if (reviewerData) {
            topReviewer = {
              name: reviewerData.name || 'Unknown',
              count: typeof topReviewerCount === 'number' ? topReviewerCount : 0,
              streak: reviewerData.current_streak || 0
            };
          }
        }
        
        // Calculate sparkline data by grouping by day
        const newPhrasesByDay = groupByDay(newPhrasesData || []);
        const reviewsByDay = groupByDay(reviewedPhrasesData || []);
        
        // Calculate trends
        const newPhrasesTrend = calculateTrend(newPhrasesData?.length || 0, previousNewPhrasesCount || 0);
        const reviewedPhrasesTrend = calculateTrend(reviewedPhrasesData?.length || 0, previousReviewedCount || 0);
        const activeReviewersTrend = calculateTrend(uniqueReviewerIds.length, previousUniqueReviewerIds.length);
        
        return {
          newPhrases: {
            value: newPhrasesData?.length || 0,
            trend: newPhrasesTrend,
            sparkline: Object.values(newPhrasesByDay)
          },
          reviewedPhrases: {
            value: reviewedPhrasesData?.length || 0,
            trend: reviewedPhrasesTrend,
            sparkline: Object.values(reviewsByDay)
          },
          activeReviewers: {
            value: uniqueReviewerIds.length,
            trend: activeReviewersTrend
          },
          topReviewer
        };
      }
      
      // If RPC approach succeeded
      const topReviewerData = reviewCounts && reviewCounts.length > 0 ? reviewCounts[0] : null;
      
      // 8. Get reviewer details
      let topReviewer = { name: 'N/A', count: 0, streak: 0 };
      
      if (topReviewerData) {
        const { data: reviewerData, error: reviewerError } = await supabase
          .from('reviewers')
          .select('id, name, current_streak')
          .eq('id', topReviewerData.reviewer_id)
          .single();
        
        if (reviewerError) {
          console.error("Reviewer details query error:", reviewerError);
        } else if (reviewerData) {
          topReviewer = {
            name: reviewerData.name || 'Unknown',
            count: typeof topReviewerData.count === 'number' ? topReviewerData.count : parseInt(topReviewerData.count) || 0,
            streak: reviewerData.current_streak || 0
          };
        }
      }
      
      // Calculate sparkline data by grouping by day
      const newPhrasesByDay = groupByDay(newPhrasesData || []);
      const reviewsByDay = groupByDay(reviewedPhrasesData || []);
      
      // Calculate trends
      const newPhrasesTrend = calculateTrend(newPhrasesData?.length || 0, previousNewPhrasesCount || 0);
      const reviewedPhrasesTrend = calculateTrend(reviewedPhrasesData?.length || 0, previousReviewedCount || 0);
      const activeReviewersTrend = calculateTrend(uniqueReviewerIds.length, previousUniqueReviewerIds.length);
      
      return {
        newPhrases: {
          value: newPhrasesData?.length || 0,
          trend: newPhrasesTrend,
          sparkline: Object.values(newPhrasesByDay)
        },
        reviewedPhrases: {
          value: reviewedPhrasesData?.length || 0,
          trend: reviewedPhrasesTrend,
          sparkline: Object.values(reviewsByDay)
        },
        activeReviewers: {
          value: uniqueReviewerIds.length,
          trend: activeReviewersTrend
        },
        topReviewer
      };
    } catch (error) {
      console.error('Error fetching dashboard stats:', error);
      // Add detailed error information
      if (error instanceof Error) {
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
      }
      return null;
    }
  },
  
  // Other methods remain the same...
};

// Helper function to calculate percentage trend
function calculateTrend(current: number, previous: number): number {
  if (previous === 0) return current > 0 ? 100 : 0;
  const trend = ((current - previous) / previous) * 100;
  return Math.round(trend);
}

// Helper function to group data by day for sparklines
function groupByDay(data: any[]): Record<string, number> {
  const result: Record<string, number> = {};
  
  // Initialize all days in the period with 0
  const today = new Date();
  for (let i = 30; i >= 0; i--) {
    const date = new Date();
    date.setDate(today.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    result[dateStr] = 0;
  }
  
  // Fill in actual counts
  data.forEach(item => {
    if (item && item.created_at) {
      const dateStr = new Date(item.created_at).toISOString().split('T')[0];
      if (result[dateStr] !== undefined) {
        result[dateStr]++;
      }
    }
  });
  
  return result;
}

============================================================

FILE: .\styles\theme.ts
SIZE: 0.74 KB
LAST MODIFIED: 03/23/2025 12:51:46

// styles/theme.ts
import { themes } from './themes';
import * as tokens from './tokens';

// Re-export everything
export { themes, tokens };
export * from './themes';
export * from './tokens';

// Utility functions for theme
export function getThemeValue(themeName: 'light' | 'dark' | string, path: string) {
  const theme = themes[themeName] || themes.light;
  return path.split('.').reduce((obj, key) => obj?.[key], theme);
}

export function getCssVar(name: string, fallback?: string) {
  if (typeof window === 'undefined') return fallback;
  const variable = getComputedStyle(document.documentElement)
    .getPropertyValue(name)
    .trim();
  return variable || fallback;
}

export default {
  themes,
  tokens,
  getThemeValue,
  getCssVar,
};


============================================================

FILE: .\styles\themes\dark.ts
SIZE: 0.83 KB
LAST MODIFIED: 03/23/2025 12:51:27

// styles/themes/dark.ts
export const darkTheme = {
  colors: {
    background: '0 0% 3.9%',
    foreground: '0 0% 98%',
    card: '0 0% 3.9%',
    cardForeground: '0 0% 98%',
    popover: '0 0% 3.9%',
    popoverForeground: '0 0% 98%',
    primary: '0 0% 98%',
    primaryForeground: '0 0% 9%',
    secondary: '0 0% 14.9%',
    secondaryForeground: '0 0% 98%',
    muted: '0 0% 14.9%',
    mutedForeground: '0 0% 63.9%',
    accent: '0 0% 14.9%',
    accentForeground: '0 0% 98%',
    destructive: '0 62.8% 30.6%',
    destructiveForeground: '0 0% 98%',
    border: '0 0% 14.9%',
    input: '0 0% 14.9%',
    ring: '0 0% 83.1%',
    
    // Chart colors
    chart1: '220 70% 50%',
    chart2: '160 60% 45%',
    chart3: '30 80% 55%',
    chart4: '280 65% 60%',
    chart5: '340 75% 55%'
  },
  radius: '0.5rem'
};

export default darkTheme;


============================================================

FILE: .\styles\themes\index.ts
SIZE: 0.32 KB
LAST MODIFIED: 03/23/2025 12:51:28

// styles/themes/index.ts
export { default as lightTheme } from './light';
export { default as darkTheme } from './dark';

// Export theme object for easy consumption
import lightTheme from './light';
import darkTheme from './dark';

export const themes = {
  light: lightTheme,
  dark: darkTheme,
};

export default themes;


============================================================

FILE: .\styles\themes\light.ts
SIZE: 0.83 KB
LAST MODIFIED: 03/23/2025 12:51:28

// styles/themes/light.ts
export const lightTheme = {
  colors: {
    background: '0 0% 100%',
    foreground: '0 0% 3.9%',
    card: '0 0% 100%',
    cardForeground: '0 0% 3.9%',
    popover: '0 0% 100%',
    popoverForeground: '0 0% 3.9%',
    primary: '0 0% 9%',
    primaryForeground: '0 0% 98%',
    secondary: '0 0% 96.1%',
    secondaryForeground: '0 0% 9%',
    muted: '0 0% 96.1%',
    mutedForeground: '0 0% 45.1%',
    accent: '0 0% 96.1%',
    accentForeground: '0 0% 9%',
    destructive: '0 84.2% 60.2%',
    destructiveForeground: '0 0% 98%',
    border: '0 0% 89.8%',
    input: '0 0% 89.8%',
    ring: '0 0% 3.9%',
    
    // Chart colors
    chart1: '12 76% 61%',
    chart2: '173 58% 39%',
    chart3: '197 37% 24%',
    chart4: '43 74% 66%',
    chart5: '27 87% 67%'
  },
  radius: '0.5rem'
};

export default lightTheme;


============================================================

FILE: .\styles\tokens\animations.ts
SIZE: 1.57 KB
LAST MODIFIED: 03/23/2025 12:50:31

// styles/tokens/animations.ts
export const animations = {
  // Durations
  duration: {
    fast: '150ms',
    normal: '300ms',
    slow: '500ms',
    slower: '700ms',
  },
  
  // Easing functions
  easing: {
    // Common easing curves
    linear: 'linear',
    in: 'cubic-bezier(0.4, 0, 1, 1)',
    out: 'cubic-bezier(0, 0, 0.2, 1)',
    inOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    
    // Material-inspired easings
    standard: 'cubic-bezier(0.4, 0.0, 0.2, 1)', // Standard material easing
    accelerate: 'cubic-bezier(0.4, 0.0, 1.0, 1.0)', // For elements exiting screen
    decelerate: 'cubic-bezier(0.0, 0.0, 0.2, 1.0)', // For elements entering screen
    sharp: 'cubic-bezier(0.4, 0.0, 0.6, 1.0)', // For elements changing state
  },
  
  // Animation keyframes (reference to CSS keyframes)
  keyframes: {
    fadeIn: 'fadeIn',
    fadeOut: 'fadeOut',
    slideIn: 'slideIn',
    slideOut: 'slideOut',
    zoomIn: 'zoomIn',
    zoomOut: 'zoomOut',
  },
  
  // Prebuilt animations
  animation: {
    fadeIn: 'fadeIn var(--animation-duration-normal) var(--animation-easing-out) forwards',
    fadeOut: 'fadeOut var(--animation-duration-normal) var(--animation-easing-in) forwards',
    slideIn: 'slideIn var(--animation-duration-normal) var(--animation-easing-out) forwards',
    slideOut: 'slideOut var(--animation-duration-normal) var(--animation-easing-in) forwards',
    zoomIn: 'zoomIn var(--animation-duration-normal) var(--animation-easing-out) forwards',
    zoomOut: 'zoomOut var(--animation-duration-normal) var(--animation-easing-in) forwards',
  },
}

export default animations;


============================================================

FILE: .\styles\tokens\colors.ts
SIZE: 2.59 KB
LAST MODIFIED: 03/23/2025 16:00:37

// styles/tokens/colors.ts
export const colors = {
  // Primary colors
  primary: {
    50: 'hsl(var(--primary-50))',
    100: 'hsl(var(--primary-100))',
    200: 'hsl(var(--primary-200))',
    300: 'hsl(var(--primary-300))',
    400: 'hsl(var(--primary-400))',
    500: 'hsl(var(--primary-500))',
    600: 'hsl(var(--primary-600))',
    700: 'hsl(var(--primary-700))',
    800: 'hsl(var(--primary-800))',
    900: 'hsl(var(--primary-900))',
    950: 'hsl(var(--primary-950))',
  },
  
  // Gray scale
  gray: {
    50: 'hsl(var(--gray-50))',
    100: 'hsl(var(--gray-100))',
    200: 'hsl(var(--gray-200))',
    300: 'hsl(var(--gray-300))',
    400: 'hsl(var(--gray-400))',
    500: 'hsl(var(--gray-500))',
    600: 'hsl(var(--gray-600))',
    700: 'hsl(var(--gray-700))',
    800: 'hsl(var(--gray-800))',
    900: 'hsl(var(--gray-900))',
    950: 'hsl(var(--gray-950))',
  },
  
  // Semantic colors
  background: 'hsl(var(--background))',
  foreground: 'hsl(var(--foreground))',
  card: 'hsl(var(--card))',
  cardForeground: 'hsl(var(--card-foreground))',
  popover: 'hsl(var(--popover))',
  popoverForeground: 'hsl(var(--popover-foreground))',
  
  // UI component colors
  primary: 'hsl(var(--primary))',
  primaryForeground: 'hsl(var(--primary-foreground))',
  secondary: 'hsl(var(--secondary))',
  secondaryForeground: 'hsl(var(--secondary-foreground))',
  muted: 'hsl(var(--muted))',
  mutedForeground: 'hsl(var(--muted-foreground))',
  accent: 'hsl(var(--accent))',
  accentForeground: 'hsl(var(--accent-foreground))',
  destructive: 'hsl(var(--destructive))',
  destructiveForeground: 'hsl(var(--destructive-foreground))',
  
  // Border and other UI elements
  border: 'hsl(var(--border))',
  input: 'hsl(var(--input))',
  ring: 'hsl(var(--ring))',
  
  // Chart colors
  chart: {
    1: 'hsl(var(--chart-1))',
    2: 'hsl(var(--chart-2))',
    3: 'hsl(var(--chart-3))',
    4: 'hsl(var(--chart-4))',
    5: 'hsl(var(--chart-5))',
  },
  
  // Theme accent colors
  accents: {
    default: {
      color: 'var(--accent-color)',
      foreground: 'var(--accent-foreground)',
      muted: 'var(--accent-muted)',
    },
    blue: {
      color: 'hsl(220 70% 50%)',
      foreground: 'hsl(220 70% 95%)',
      muted: 'hsl(220 70% 30%)',
    },
    green: {
      color: 'hsl(160 60% 45%)',
      foreground: 'hsl(160 60% 95%)',
      muted: 'hsl(160 60% 25%)',
    },
    purple: {
      color: 'hsl(270 60% 50%)',
      foreground: 'hsl(270 60% 95%)',
      muted: 'hsl(270 60% 30%)',
    },
    orange: {
      color: 'hsl(30 80% 50%)',
      foreground: 'hsl(30 80% 95%)',
      muted: 'hsl(30 80% 30%)',
    },
  },
}

export default colors;

============================================================

FILE: .\styles\tokens\globals.css
SIZE: 3.22 KB
LAST MODIFIED: 03/23/2025 12:52:34

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Base colors */
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;

    /* Chart colors */
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;

    /* Animation tokens */
    --animation-duration-fast: 150ms;
    --animation-duration-normal: 300ms;
    --animation-duration-slow: 500ms;
    --animation-easing-linear: linear;
    --animation-easing-in: cubic-bezier(0.4, 0, 1, 1);
    --animation-easing-out: cubic-bezier(0, 0, 0.2, 1);
    --animation-easing-in-out: cubic-bezier(0.4, 0, 0.2, 1);

    /* Spacing and layout tokens */
    --layout-gutter: 1rem;
    --layout-margin: 2rem;
    
    /* Border radius */
    --radius: 0.5rem;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;

    /* Chart colors for dark mode */
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }

  /* Accent colors - default (blue) */
  [data-accent="default"] {
    --accent-hue: 220;
    --accent-saturation: 70%;
  }

  /* Green accent */
  [data-accent="green"] {
    --accent-hue: 160;
    --accent-saturation: 60%;
  }

  /* Purple accent */
  [data-accent="purple"] {
    --accent-hue: 270;
    --accent-saturation: 60%;
  }

  /* Orange accent */
  [data-accent="orange"] {
    --accent-hue: 30;
    --accent-saturation: 80%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Animation keyframes */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes slideIn {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes slideOut {
  from { transform: translateY(0); opacity: 1; }
  to { transform: translateY(10px); opacity: 0; }
}

@keyframes zoomIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

@keyframes zoomOut {
  from { transform: scale(1); opacity: 1; }
  to { transform: scale(0.95); opacity: 0; }
}


============================================================

FILE: .\styles\tokens\index.ts
SIZE: 0.41 KB
LAST MODIFIED: 03/23/2025 12:50:31

// styles/tokens/index.ts
export { default as colors } from './colors';
export { default as typography } from './typography';
export { default as spacing } from './spacing';
export { default as shadows } from './shadows';
export { default as animations } from './animations';

// Centralizing export of all tokens
const tokens = {
  colors,
  typography,
  spacing,
  shadows,
  animations,
};

export default tokens;


============================================================

FILE: .\styles\tokens\shadows.ts
SIZE: 1.01 KB
LAST MODIFIED: 03/23/2025 12:50:31

// styles/tokens/shadows.ts
export const shadows = {
  sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
  DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
  md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
  lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
  xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
  '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
  inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
  none: 'none',
  
  // Dark mode shadow variants
  dark: {
    sm: '0 1px 2px 0 rgb(0 0 0 / 0.4)',
    DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.4), 0 1px 2px -1px rgb(0 0 0 / 0.4)',
    md: '0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.4)',
    lg: '0 10px 15px -3px rgb(0 0 0 / 0.4), 0 4px 6px -4px rgb(0 0 0 / 0.4)',
    xl: '0 20px 25px -5px rgb(0 0 0 / 0.4), 0 8px 10px -6px rgb(0 0 0 / 0.4)',
    '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.8)',
    inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.2)',
  },
}

export default shadows;


============================================================

FILE: .\styles\tokens\spacing.ts
SIZE: 1.26 KB
LAST MODIFIED: 03/23/2025 12:50:31

// styles/tokens/spacing.ts
export const spacing = {
  // Core spacing values
  0: '0',
  px: '1px',
  0.5: '0.125rem', // 2px
  1: '0.25rem',    // 4px
  1.5: '0.375rem', // 6px
  2: '0.5rem',     // 8px
  2.5: '0.625rem', // 10px
  3: '0.75rem',    // 12px
  3.5: '0.875rem', // 14px
  4: '1rem',       // 16px
  5: '1.25rem',    // 20px
  6: '1.5rem',     // 24px
  7: '1.75rem',    // 28px
  8: '2rem',       // 32px
  9: '2.25rem',    // 36px
  10: '2.5rem',    // 40px
  11: '2.75rem',   // 44px
  12: '3rem',      // 48px
  14: '3.5rem',    // 56px
  16: '4rem',      // 64px
  20: '5rem',      // 80px
  24: '6rem',      // 96px
  28: '7rem',      // 112px
  32: '8rem',      // 128px
  36: '9rem',      // 144px
  40: '10rem',     // 160px
  44: '11rem',     // 176px
  48: '12rem',     // 192px
  52: '13rem',     // 208px
  56: '14rem',     // 224px
  60: '15rem',     // 240px
  64: '16rem',     // 256px
  72: '18rem',     // 288px
  80: '20rem',     // 320px
  96: '24rem',     // 384px
  
  // Semantic spacing
  container: {
    sm: '640px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    '2xl': '1536px',
  },
  
  // Layout spacing
  layout: {
    gutter: 'var(--layout-gutter, 1rem)',
    margin: 'var(--layout-margin, 2rem)',
  }
}

export default spacing;


============================================================

FILE: .\styles\tokens\typography.ts
SIZE: 0.84 KB
LAST MODIFIED: 03/23/2025 12:50:31

// styles/tokens/typography.ts
export const typography = {
  fontFamily: {
    sans: 'var(--font-sans)',
    mono: 'var(--font-mono)',
  },
  fontSize: {
    xs: '0.75rem',    // 12px
    sm: '0.875rem',   // 14px
    base: '1rem',     // 16px
    lg: '1.125rem',   // 18px
    xl: '1.25rem',    // 20px
    '2xl': '1.5rem',  // 24px
    '3xl': '1.875rem', // 30px
    '4xl': '2.25rem',  // 36px
    '5xl': '3rem',     // 48px
  },
  fontWeight: {
    light: '300',
    normal: '400',
    medium: '500',
    semibold: '600',
    bold: '700',
  },
  lineHeight: {
    none: '1',
    tight: '1.25',
    snug: '1.375',
    normal: '1.5',
    relaxed: '1.625',
    loose: '2',
  },
  letterSpacing: {
    tighter: '-0.05em',
    tight: '-0.025em',
    normal: '0',
    wide: '0.025em',
    wider: '0.05em',
    widest: '0.1em',
  },
}

export default typography;


============================================================

FILE: .\types\types.ts
SIZE: 5.43 KB
LAST MODIFIED: 03/17/2025 11:40:41

import type { Session } from '@supabase/supabase-js';

export interface PhraseWithRelations extends Phrase {
  categories: Category;
  subcategories?: Subcategory;
  phrase_tags: {
    tags: Tag;
  }[];
}

export interface SupabaseQueryResponse<T> {
  data: T[] | null;
  error: any;
  count?: number | null;
}

export interface Category {
  id: number;
  name: string;
}

export interface PhraseTagWithTag {
  tag_id: number;
  tags: {
    id: number;
    tag: string;
  };
}

export type SubcategoryName = {
  name: string;
}

export interface Subcategory {
  id: number;
  name: string;
  category_id: number;
}

export interface Tag {
  id: number;
  tag: string;
}

export interface PhraseTag {
  phrase_id: number;
  tag_id: number;
}

export interface PhraseBase {
  phrase: string;
  category_id: number;
  subcategory_id?: number | null;
  difficulty: number;  // Changed from string to number
  part_of_speech: string;
  hint?: string | null;
}

export interface Phrase extends Omit<PhraseBase, 'category_id' | 'subcategory_id'> {
  id: number;
  category: string;
  subcategory?: string;
  tags: string;
  difficulty: number;
}

export interface NewPhrase {
  phrase: string;
  category: string;
  subcategory?: string;
  difficulty: string;
  part_of_speech: string;
  hint?: string;
  tags?: string;
}

export interface Vote {
  id: string;
  reviewer_id: string;
  phrase_id: number;
  category: VoteCategory;
  vote: boolean;
  created_at: string;
}

export type VoteCategory = 'phrase' | 'category' | 'subcategory' | 'hint' | 'tags' | 'difficulty';

export interface Filters {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
}

export interface PaginationState {
  currentPage: number;
  rowsPerPage: number;
  totalPages: number;
  totalItems?: number; // Make sure this is included
}
export interface TableState {
  sortConfig: SortConfig;
  pagination: PaginationState;
  filters: Filters;
}
export interface SortConfig {
  key: keyof Phrase | '';
  direction: 'asc' | 'desc';
}

export interface Stats {
  total: number;
  uniqueCategories: number;
  difficultyBreakdown: {
    easy: number;
    medium: number;
    hard: number;
  };
}

export interface Reviewer {
  id: string;
  name: string;
  pin: string;
  total_reviews: number;
  current_streak: number;
  last_review_at: string | null;
}

export interface BulkImportFormProps {
  onSuccess: (importedIds?: number[]) => void;
  onError: (errorMessage: string) => void;
  categories?: string[];
  difficulties?: string[];
  partsOfSpeech?: string[];
}

export interface ImportedPhrase extends NewPhrase {
  id: number;
}

export interface AddPhraseFormProps {
  onAddPhrase: (phrase: NewPhrase) => Promise<void>;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
}

export interface FilterControlsProps {
  filters: Filters;
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading?: boolean;
}

export interface PhrasesTableProps {
  phrases: any[]; // This should match the actual data structure
  loading?: boolean;
  tableState: TableState;
  onTableStateChange: (updates: Partial<TableState>) => void;
  onEdit?: (id: number) => void;
  onDelete?: (id: number) => void;
  newIds?: number[];
  onShowFilters?: () => void;
}

export interface CardViewModalProps {
  isOpen: boolean;
  onClose: () => void;
  phrases: Phrase[];
  currentIndex: number;
  onNavigate: (index: number) => void;
  isEditing: boolean;
  editedPhrase: Phrase | null;
  onEdit: () => void;
  onSave: () => void;
  onCancel: () => void;
  onEditChange: (field: keyof Phrase, value: string) => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  reviewer?: Reviewer;
  onTagClick?: (tag: string) => void;
  loading?: boolean;
  error?: string | null;
}

export interface UsePhrasesReturn {
  phrases: Phrase[];
  loading: boolean;
  error: string | null;
  setError: (error: string | null) => void;
  pagination: PaginationState;
  sortConfig: SortConfig;
  filters: Filters;
  handleSort: (key: keyof Phrase) => void;
  handlePageChange: (page: number) => void;
  handleRowsPerPageChange: (rowsPerPage: number) => void;
  handleFilterChange: (name: string, value: string) => void;
  addPhrase: (phrase: NewPhrase) => Promise<void>;
  editPhrase: (phrase: Phrase) => Promise<void>;
  deletePhrase: (id: number) => Promise<void>;
  fetchPhrases: () => Promise<void>;
  resetFilters: () => void;
  sortByIdDesc: () => void;
}

export interface TagValidationResult {
  isValid: boolean;
  formattedTags: string;
  errors?: string[];
}

export interface UsePaginationProps {
  totalItems: number;
  itemsPerPage: number;
  currentPage: number;
}

export interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

export interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
}

export interface SelectProps {
  value: string;
  onChange: (value: string) => void;
  options: string[];
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  className?: string;
}

export interface StatsSectionProps {
  stats: Stats | null;
  loading: boolean;
}
