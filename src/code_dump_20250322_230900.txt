PROJECT ANALYSIS
Generated: 03/22/2025 23:09:00
Directory: C:\_websites\phrase\src

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: 5.1.19041.5607
OS: Microsoft Windows 10 Pro
Computer Name: OFFICE

============================================================

FILE CONTENTS:

============================================================

FILE: .\code-base.ps1
SIZE: 2.94 KB
LAST MODIFIED: 02/13/2025 10:17:39

# Get current directory path and script start time
$currentPath = (Get-Location).Path
$startTime = Get-Date
$outputFile = "code_dump_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"

# Add exclusion patterns for folders and files
$excludedPaths = @(
    'node_modules',
    '.git',
    'bin',
    'obj',
    'dist',
    'build',
    '.vscode',
    'packages'
)

# Write initial info to console
Write-Host "Starting analysis of $currentPath"
Write-Host "Excluding folders: $($excludedPaths -join ', ')"

# Initial file header
$envInfo = @"
PROJECT ANALYSIS
Generated: $(Get-Date)
Directory: $currentPath

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: $($PSVersionTable.PSVersion)
OS: $(Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty Caption)
Computer Name: $env:COMPUTERNAME
"@
Set-Content -Path $outputFile -Value $envInfo -Encoding utf8

Write-Host "Gathering file list..."

# Get all files, excluding problematic paths
$allFiles = Get-ChildItem -Path $currentPath -Recurse -File | Where-Object {
    $fullPath = $_.FullName
    $exclude = $false
    foreach ($path in $excludedPaths) {
        if ($fullPath -like "*\$path\*") {
            $exclude = $true
            break
        }
    }
    -not $exclude -and
    $_.Name -ne $outputFile -and
    -not $_.Name.EndsWith(".tmp")
}

# Process each file
"`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
"FILE CONTENTS:" | Out-File $outputFile -Append -Encoding utf8

$fileCounter = 0
$totalFiles = $allFiles.Count

# Avoid division by zero
if ($totalFiles -eq 0) {
    Write-Host "No files found to process. Exiting."
    exit
}

$allFiles | Where-Object {
    $_.Extension -notmatch '\.(exe|dll|pdb|obj|bin|cache|jpg|jpeg|png|gif|bmp|ico|mp3|mp4|zip|rar|7z)$' -and
    $_.Length -lt 5MB
} | ForEach-Object {
    $fileCounter++
    $percentComplete = [math]::Round(($fileCounter / $totalFiles) * 100, 1)
    Write-Progress -Activity "Processing Files" -Status "$fileCounter of $totalFiles ($percentComplete%)" -PercentComplete $percentComplete
    Write-Host "Processing ($fileCounter/$totalFiles): $($_.Name)"

    try {
        # Write file metadata
        $relPath = $_.FullName.Replace($currentPath, ".")
        $fileSize = [math]::Round($_.Length / 1KB, 2)
        
        "`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
        "FILE: $relPath`nSIZE: $fileSize KB`nLAST MODIFIED: $($_.LastWriteTime)`n" | Out-File $outputFile -Append -Encoding utf8
        
        # Append file content
        Get-Content $_.FullName -Raw | Out-File $outputFile -Append -Encoding utf8
    } catch {
        Write-Warning "Error processing $($_.FullName): $_"
    }
}

Write-Host "Analysis complete. Output saved to $outputFile"


============================================================

FILE: .\file-structure.ps1
SIZE: 2.99 KB
LAST MODIFIED: 03/17/2025 11:11:08

# Directory Structure Generator for AI Readability
# This script creates a clean, hierarchical text document of the current directory structure
# Format is optimized for AI processing with consistent indentation and clear labeling

$outputFile = "DirectoryStructure.txt"
$indentChar = "    " # 4 spaces for indentation

function Get-FormattedSize {
    param (
        [long]$SizeInBytes
    )
    
    if ($SizeInBytes -lt 1KB) {
        return "$SizeInBytes B"
    }
    elseif ($SizeInBytes -lt 1MB) {
        return "{0:N2} KB" -f ($SizeInBytes / 1KB)
    }
    elseif ($SizeInBytes -lt 1GB) {
        return "{0:N2} MB" -f ($SizeInBytes / 1MB)
    }
    else {
        return "{0:N2} GB" -f ($SizeInBytes / 1GB)
    }
}

function Get-DirectoryStructure {
    param (
        [string]$Path,
        [int]$Level = 0,
        [System.IO.StreamWriter]$Writer
    )

    $indent = $indentChar * $Level
    
    # Get directory information
    $dirInfo = Get-Item -Path $Path
    $dirName = Split-Path -Path $Path -Leaf
    if ($Level -eq 0) {
        $dirName = Resolve-Path -Path $Path
    }
    
    # Write directory entry
    $Writer.WriteLine("$indent[DIR] $dirName")
    
    # Process all files first (for cleaner organization)
    $files = Get-ChildItem -Path $Path -File | Sort-Object Name
    foreach ($file in $files) {
        $size = Get-FormattedSize -SizeInBytes $file.Length
        $extension = if ($file.Extension) { $file.Extension.ToLower() } else { "no-extension" }
        $Writer.WriteLine("$indent$indentChar[FILE] $($file.Name) | Size: $size | Type: $extension | Modified: $($file.LastWriteTime.ToString('yyyy-MM-dd HH:mm:ss'))")
    }
    
    # Then process all subdirectories
    $dirs = Get-ChildItem -Path $Path -Directory | Sort-Object Name
    foreach ($dir in $dirs) {
        Get-DirectoryStructure -Path $dir.FullName -Level ($Level + 1) -Writer $Writer
    }
}

try {
    # Create or overwrite the output file
    $writer = New-Object System.IO.StreamWriter $outputFile
    
    # Write header information
    $writer.WriteLine("DIRECTORY STRUCTURE REPORT")
    $writer.WriteLine("Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')")
    $writer.WriteLine("Computer: $env:COMPUTERNAME")
    $writer.WriteLine("Current User: $env:USERNAME")
    $writer.WriteLine("PowerShell Version: $($PSVersionTable.PSVersion)")
    $writer.WriteLine("---------------------------------------------")
    $writer.WriteLine("")
    
    # Get and write the full directory structure
    $currentPath = Get-Location
    Get-DirectoryStructure -Path $currentPath -Writer $writer
    
    # Close the file
    $writer.Close()
    
    Write-Host "Directory structure has been written to: $((Resolve-Path $outputFile).Path)" -ForegroundColor Green
    Write-Host "This file format is optimized for AI readability." -ForegroundColor Green
}
catch {
    Write-Host "An error occurred: $_" -ForegroundColor Red
    if ($writer) {
        $writer.Close()
    }
}

============================================================

FILE: .\app\globals.css
SIZE: 1.67 KB
LAST MODIFIED: 03/04/2025 21:05:06

@tailwind base;
@tailwind components;
@tailwind utilities;



@layer base {
  :root {

    --background: 0 0% 100%;

    --foreground: 0 0% 3.9%;

    --card: 0 0% 100%;

    --card-foreground: 0 0% 3.9%;

    --popover: 0 0% 100%;

    --popover-foreground: 0 0% 3.9%;

    --primary: 0 0% 9%;

    --primary-foreground: 0 0% 98%;

    --secondary: 0 0% 96.1%;

    --secondary-foreground: 0 0% 9%;

    --muted: 0 0% 96.1%;

    --muted-foreground: 0 0% 45.1%;

    --accent: 0 0% 96.1%;

    --accent-foreground: 0 0% 9%;

    --destructive: 0 84.2% 60.2%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 89.8%;

    --input: 0 0% 89.8%;

    --ring: 0 0% 3.9%;

    --chart-1: 12 76% 61%;

    --chart-2: 173 58% 39%;

    --chart-3: 197 37% 24%;

    --chart-4: 43 74% 66%;

    --chart-5: 27 87% 67%;

    --radius: 0.5rem
  }
  .dark {

    --background: 0 0% 3.9%;

    --foreground: 0 0% 98%;

    --card: 0 0% 3.9%;

    --card-foreground: 0 0% 98%;

    --popover: 0 0% 3.9%;

    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 98%;

    --primary-foreground: 0 0% 9%;

    --secondary: 0 0% 14.9%;

    --secondary-foreground: 0 0% 98%;

    --muted: 0 0% 14.9%;

    --muted-foreground: 0 0% 63.9%;

    --accent: 0 0% 14.9%;

    --accent-foreground: 0 0% 98%;

    --destructive: 0 62.8% 30.6%;

    --destructive-foreground: 0 0% 98%;

    --border: 0 0% 14.9%;

    --input: 0 0% 14.9%;

    --ring: 0 0% 83.1%;

    --chart-1: 220 70% 50%;

    --chart-2: 160 60% 45%;

    --chart-3: 30 80% 55%;

    --chart-4: 280 65% 60%;

    --chart-5: 340 75% 55%
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


============================================================

FILE: .\app\layout.tsx
SIZE: 0.58 KB
LAST MODIFIED: 03/05/2025 16:27:42

import type { Metadata } from "next";
import "./globals.css";
import { ThemeProvider } from "@/providers/ThemeProvider";

export const metadata: Metadata = {
  title: "Catch Phrase Admin",
  description: "Manage your catch phrases",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="font-sans antialiased">
        <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

============================================================

FILE: .\app\page.tsx
SIZE: 0.23 KB
LAST MODIFIED: 02/07/2025 09:27:36

'use client'
 
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
 
export default function Home() {
  const router = useRouter()
  
  useEffect(() => {
    router.push('/admin')
  }, [router])
  
  return null
}

============================================================

FILE: .\app\admin\page.tsx
SIZE: 0.46 KB
LAST MODIFIED: 03/20/2025 23:01:08

// src/app/admin/page.tsx
'use client'

import dynamic from 'next/dynamic';
import { PhrasesListContainer } from '@/features/phrases/components/PhrasesList';

// If you're currently using this pattern:
const Dashboard = dynamic(() => import('@/features/dashboard/Dashboard'), {
  ssr: false
});

export default function AdminPage() {
  // If you have a tab system in your Dashboard component,
  // you'll need to pass the PhrasesListContainer to it
  return <Dashboard />;
}

============================================================

FILE: .\app\api\claude\route.ts
SIZE: 1.41 KB
LAST MODIFIED: 03/01/2025 15:23:07

import { NextResponse } from 'next/server';

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';

export async function POST(req: Request) {
  if (!CLAUDE_API_KEY) {
    console.error('Claude API key is not configured');
    return NextResponse.json(
      { error: 'Claude API key is not configured' },
      { status: 500 }
    );
  }

  try {
    const body = await req.json();
    
    const claudeResponse = await fetch(CLAUDE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-7-sonnet-20250219', // Updated model
        max_tokens: 150,
        messages: body.messages
      })
    });

    if (!claudeResponse.ok) {
      const errorText = await claudeResponse.text();
      console.error('Claude API error:', errorText);
      return NextResponse.json(
        { error: `Claude API error: ${claudeResponse.statusText}` },
        { status: claudeResponse.status }
      );
    }

    const data = await claudeResponse.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

============================================================

FILE: .\app\api\dashboard\stats\route.ts
SIZE: 0.69 KB
LAST MODIFIED: 03/21/2025 16:56:07

// app/api/dashboard/stats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { DashboardDataService } from '@/services/dashboard-data-service';

export async function POST(request: NextRequest) {
  try {
    const { dateRange = 30 } = await request.json();
    
    const stats = await DashboardDataService.fetchDashboardStats(dateRange);
    
    if (!stats) {
      return NextResponse.json({ error: 'Failed to fetch stats' }, { status: 500 });
    }
    
    return NextResponse.json(stats);
  } catch (error) {
    console.error('Error in stats API route:', error);
    return NextResponse.json({ error: 'Failed to process request' }, { status: 500 });
  }
}

============================================================

FILE: .\components\ui\alert.tsx
SIZE: 2.23 KB
LAST MODIFIED: 02/09/2025 10:34:20

import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-gray-800 border-gray-700 text-white",
        destructive: "border-red-700 bg-red-900/50 text-red-100 [&>svg]:text-red-100",
        success: "border-green-700 bg-green-900/50 text-green-100 [&>svg]:text-green-100",
        warning: "border-yellow-700 bg-yellow-900/50 text-yellow-100 [&>svg]:text-yellow-100",
        info: "border-blue-700 bg-blue-900/50 text-blue-100 [&>svg]:text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> &
    VariantProps<typeof alertVariants> & {
      onClose?: () => void;
    }
>(({ className, variant, children, onClose, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  >
    {children}
    {onClose && (
      <button
        onClick={onClose}
        className="absolute top-4 right-4 p-1 rounded-full hover:bg-gray-700/50 transition-colors"
        aria-label="Close alert"
      >
        <X className="h-4 w-4" />
      </button>
    )}
  </div>
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

============================================================

FILE: .\components\ui\button.tsx
SIZE: 1.69 KB
LAST MODIFIED: 02/09/2025 10:32:42

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-blue-500 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-blue-600 text-white hover:bg-blue-700",
        destructive: "bg-red-600 text-white hover:bg-red-700",
        outline: "border border-gray-600 bg-transparent hover:bg-gray-700 hover:text-white",
        secondary: "bg-gray-600 text-white hover:bg-gray-700",
        ghost: "hover:bg-gray-700 hover:text-white",
        link: "text-blue-500 underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };

============================================================

FILE: .\components\ui\card.tsx
SIZE: 1.79 KB
LAST MODIFIED: 03/21/2025 18:41:24

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-md border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


============================================================

FILE: .\components\ui\chart.tsx
SIZE: 2.92 KB
LAST MODIFIED: 03/07/2025 09:03:03

// components/ui/chart.tsx

"use client"

import * as React from "react"
import { Line, LineChart, ResponsiveContainer, Tooltip } from "recharts"

export type ChartConfig = {
  [key: string]: {
    label: string
    color: string
  }
}

export function ChartContainer({
  config,
  children,
  className,
  ...props
}: React.PropsWithChildren & {
  config: ChartConfig
  className?: string
  [key: string]: any
}) {
  const createCSSVariable = (obj: Record<string, string>) => {
    return Object.entries(obj).reduce((vars, [key, value]) => {
      return {
        ...vars,
        [`--color-${key}`]: value,
      }
    }, {})
  }

  const colors = Object.entries(config).reduce((colors, [key, item]) => {
    return {
      ...colors,
      [key]: item.color,
    }
  }, {})

  const cssVars = createCSSVariable(colors)

  return (
    <div style={cssVars} className={className} {...props}>
      {children}
    </div>
  )
}

export function ChartTooltipContent({
  active,
  payload,
  label,
  config,
  indicator = "circle",
}: {
  active?: boolean
  payload?: any[]
  label?: string
  config?: ChartConfig
  indicator?: "circle" | "line"
}) {
  const TypeIndicator = ({ name }: { name: string }) =>
    indicator === "circle" ? (
      <circle
        cx="6.5"
        cy="6.5"
        r="3.5"
        fill={`var(--color-${name})`}
      />
    ) : (
      <line
        x1="1"
        y1="6.5"
        x2="9"
        y2="6.5"
        stroke={`var(--color-${name})`}
        strokeWidth={2}
        strokeLinecap="round"
      />
    )

  if (!active || !payload) return null

  return (
    <div className="rounded-lg border bg-background p-2 shadow-sm">
      <div className="grid grid-cols-2 gap-2">
        <div className="flex flex-col">
          <span className="text-[0.70rem] uppercase text-muted-foreground">
            {label}
          </span>
        </div>
        <div className="flex flex-col gap-1">
          {payload.map(({ value, name }) => (
            <div key={name} className="flex items-center justify-end gap-1">
              <span className="text-[0.70rem] text-muted-foreground">
                {config?.[name]?.label ?? name}
              </span>
              <span className="font-bold tabular-nums">{value}</span>
              {config?.[name] && (
                <svg
                  width="13"
                  height="13"
                  viewBox="0 0 13 13"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <TypeIndicator name={name} />
                </svg>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

export function ChartTooltip({
  content,
  ...props
}: {
  content?: React.JSXElementConstructor<any>
  [key: string]: any
}) {
  return <Tooltip {...props} content={content} />
}

============================================================

FILE: .\components\ui\checkbox.tsx
SIZE: 1.07 KB
LAST MODIFIED: 03/07/2025 17:11:30

"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

============================================================

FILE: .\components\ui\dialog.tsx
SIZE: 4.78 KB
LAST MODIFIED: 02/09/2025 15:31:45

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-700 bg-gray-800 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-gray-800 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-gray-700 data-[state=open]:text-gray-400">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-400", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

/* Example usage:
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function DialogDemo() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="outline">Edit Profile</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit profile</DialogTitle>
          <DialogDescription>
            Make changes to your profile here.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          Form content here
        </div>
        <DialogFooter>
          <Button type="submit">Save changes</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
*/

============================================================

FILE: .\components\ui\difficulty-indicator.tsx
SIZE: 0.86 KB
LAST MODIFIED: 03/22/2025 16:32:24

import React from 'react';
import { cn } from '@/lib/utils';

interface DifficultyIndicatorProps extends React.HTMLAttributes<HTMLDivElement> {
  difficulty: number;
}

const DifficultyIndicator = React.forwardRef<HTMLDivElement, DifficultyIndicatorProps>(
  ({ difficulty, className, ...props }, ref) => {
    // Determine the width based on difficulty
    const width = 
      difficulty === 1 ? 'w-1/3' : 
      difficulty === 2 ? 'w-2/3' : 
      difficulty === 3 ? 'w-full' : 'w-0';
    
    return (
      <div 
        ref={ref} 
        className={cn("w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-600", className)}
        {...props}
      >
        <div className={cn(`${width} h-2.5 rounded-full bg-gray-400`)}></div>
      </div>
    );
  }
);

DifficultyIndicator.displayName = "DifficultyIndicator";

export { DifficultyIndicator };

============================================================

FILE: .\components\ui\dropdown-menu.tsx
SIZE: 7.37 KB
LAST MODIFIED: 03/07/2025 08:43:08

// components/ui/dropdown-menu.tsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

============================================================

FILE: .\components\ui\input.tsx
SIZE: 0.75 KB
LAST MODIFIED: 03/04/2025 21:21:03

import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


============================================================

FILE: .\components\ui\label.tsx
SIZE: 0.71 KB
LAST MODIFIED: 03/04/2025 21:21:19

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


============================================================

FILE: .\components\ui\pagination.tsx
SIZE: 2.34 KB
LAST MODIFIED: 03/21/2025 09:25:13

// components/ui/pagination.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '@/lib/utils';

export interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  className?: string;
}

export function Pagination({
  currentPage,
  totalPages,
  onPageChange,
  className,
}: PaginationProps) {
  const pages = [];
  
  // Calculate which page numbers to display
  const maxPages = 5;
  let startPage: number, endPage: number;
  
  if (totalPages <= maxPages) {
    // Less than max pages, show all
    startPage = 1;
    endPage = totalPages;
  } else {
    // More than max pages, calculate which to show
    const maxPagesBeforeCurrentPage = Math.floor(maxPages / 2);
    const maxPagesAfterCurrentPage = Math.ceil(maxPages / 2) - 1;
    
    if (currentPage <= maxPagesBeforeCurrentPage) {
      // Near the start
      startPage = 1;
      endPage = maxPages;
    } else if (currentPage + maxPagesAfterCurrentPage >= totalPages) {
      // Near the end
      startPage = totalPages - maxPages + 1;
      endPage = totalPages;
    } else {
      // Middle
      startPage = currentPage - maxPagesBeforeCurrentPage;
      endPage = currentPage + maxPagesAfterCurrentPage;
    }
  }
  
  // Generate page numbers
  for (let i = startPage; i <= endPage; i++) {
    pages.push(i);
  }
  
  return (
    <div className={cn("flex justify-center items-center space-x-2", className)}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
      >
        <ChevronLeft className="h-4 w-4" />
      </Button>
      
      {pages.map((page) => (
        <Button
          key={page}
          variant={currentPage === page ? "default" : "outline"}
          size="sm"
          onClick={() => onPageChange(page)}
          disabled={currentPage === page}
        >
          {page}
        </Button>
      ))}
      
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
      >
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
}

============================================================

FILE: .\components\ui\pill-tabs.tsx
SIZE: 1.42 KB
LAST MODIFIED: 03/17/2025 21:44:17

'use client';

import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import { cn } from '@/lib/utils';

interface PillTabsProps {
  tabs: Array<{
    value: string;
    label: string;
  }>;
  activeTab: string;
  onTabChange: (value: string) => void;
  className?: string;
}

export function PillTabs({ tabs, activeTab, onTabChange, className }: PillTabsProps) {
  return (
    <div className={cn("relative overflow-auto", className)}>
      <div className="flex items-center">
        {tabs.map((tab) => (
          <button
            key={tab.value}
            onClick={() => onTabChange(tab.value)}
            className={cn(
              "flex h-9 items-center justify-center rounded-full px-4 text-center text-sm font-medium transition-colors",
              activeTab === tab.value
                ? "bg-muted text-primary"
                : "text-muted-foreground hover:text-primary"
            )}
          >
            {tab.label}
          </button>
        ))}
      </div>
    </div>
  );
}

interface PillTabsContentProps {
  value: string;
  activeTab: string;
  children: React.ReactNode;
  className?: string;
}

export function PillTabsContent({ value, activeTab, children, className }: PillTabsContentProps) {
  if (value !== activeTab) return null;
  
  return (
    <div className={cn("mt-4", className)}>
      {children}
    </div>
  );
}

============================================================

FILE: .\components\ui\select.tsx
SIZE: 5.51 KB
LAST MODIFIED: 03/04/2025 21:25:38

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


============================================================

FILE: .\components\ui\stat-card.tsx
SIZE: 1.61 KB
LAST MODIFIED: 03/04/2025 21:07:38

// components/ui/stat-card.tsx
import React from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { cn } from "@/lib/utils"

interface StatCardProps extends React.HTMLAttributes<HTMLDivElement> {
  title: string
  value: string | number
  description?: string
  icon?: React.ReactNode
  trend?: {
    value: number
    label: string
    direction: "up" | "down" | "neutral"
  }
}

export function StatCard({
  title,
  value,
  description,
  icon,
  trend,
  className,
  ...props
}: StatCardProps) {
  const trendColors = {
    up: "text-green-500",
    down: "text-red-500",
    neutral: "text-gray-500",
  }

  return (
    <Card className={cn("overflow-hidden", className)} {...props}>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        {icon && <div className="h-4 w-4 text-muted-foreground">{icon}</div>}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground">{description}</p>
        )}
        {trend && (
          <div className={cn("flex items-center text-xs mt-1", trendColors[trend.direction])}>
            {trend.direction === "up" ? "â†‘" : trend.direction === "down" ? "â†“" : "â†’"}
            <span className="ml-1">{trend.value}%</span>
            <span className="ml-1 text-muted-foreground">{trend.label}</span>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

============================================================

FILE: .\components\ui\table.tsx
SIZE: 2.79 KB
LAST MODIFIED: 03/04/2025 21:21:35

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


============================================================

FILE: .\components\ui\tabs.tsx
SIZE: 1.88 KB
LAST MODIFIED: 03/12/2025 09:01:44

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

============================================================

FILE: .\components\ui\tags.tsx
SIZE: 1.03 KB
LAST MODIFIED: 03/11/2025 21:48:59

import React from 'react';
import { cn } from '@/lib/utils';

interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
  className?: string;
}

const TagDisplay: React.FC<TagDisplayProps> = ({ 
  tags, 
  onClick,
  className
}) => {
  if (!tags) return null;
  
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  if (tagArray.length === 0) return null;
  
  return (
    <div className={cn("flex flex-wrap gap-1", className)}>
      {tagArray.map((tag, idx) => (
        <button
          key={`${tag}-${idx}`}
          onClick={() => onClick?.(tag)}
          className={cn(
            "px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300",
            onClick ? "hover:bg-gray-200 dark:hover:bg-gray-600 cursor-pointer" : "cursor-default",
            "transition-colors duration-150",
            className
          )}
        >
          {tag}
        </button>
      ))}
    </div>
  );
};

export default TagDisplay;

============================================================

FILE: .\components\ui\toast.tsx
SIZE: 4.88 KB
LAST MODIFIED: 02/09/2025 10:39:17

import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border-gray-700 bg-gray-800 text-white",
        destructive: "destructive group border-red-700 bg-red-900 text-red-100",
        success: "border-green-700 bg-green-900 text-green-100",
        warning: "border-yellow-700 bg-yellow-900 text-yellow-100",
        info: "border-blue-700 bg-blue-900 text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-gray-700 bg-transparent px-3 text-sm font-medium transition-colors hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-red-700 group-[.destructive]:hover:border-red-600 group-[.destructive]:hover:bg-red-600 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-white/50 opacity-0 transition-opacity hover:text-white focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

============================================================

FILE: .\components\ui\toaster.tsx
SIZE: 1.3 KB
LAST MODIFIED: 02/09/2025 10:39:36

import {
    Toast,
    ToastClose,
    ToastDescription,
    ToastProvider,
    ToastTitle,
    ToastViewport,
  } from "@/components/ui/toast";
  import { useToast } from "@/hooks/useToast";
  
  export function Toaster() {
    const { toasts } = useToast();
  
    return (
      <ToastProvider>
        {toasts.map(function ({ id, title, description, action, ...props }) {
          return (
            <Toast key={id} {...props}>
              <div className="grid gap-1">
                {title && <ToastTitle>{title}</ToastTitle>}
                {description && (
                  <ToastDescription>{description}</ToastDescription>
                )}
              </div>
              {action}
              <ToastClose />
            </Toast>
          );
        })}
        <ToastViewport />
      </ToastProvider>
    );
  }
  
  // Example usage:
  /*
  import { useToast } from '@/hooks/useToast';
  
  function MyComponent() {
    const { toast } = useToast();
    
    const showToast = () => {
      toast({
        title: "Success!",
        description: "Your action was completed successfully.",
        variant: "success", // or "default", "destructive", "warning", "info"
      });
    };
  
    return <button onClick={showToast}>Show Toast</button>;
  }
  */

============================================================

FILE: .\features\auth\PinPad.tsx
SIZE: 2.47 KB
LAST MODIFIED: 03/17/2025 09:58:57

'use client';

import * as React from 'react';
import { Button } from '@/components/ui/button';

interface PinPadProps {
  onSubmit: (pin: string) => void;
  onCancel: () => void;
}

export default function PinPad({ onSubmit, onCancel }: PinPadProps) {
  const [pin, setPin] = React.useState('');
  const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'X', '0', 'â†'];

  function handleClick(num: string) {
    if (num === 'â†') {
      setPin((prev) => prev.slice(0, -1));
    } else if (num === 'X') {
      onCancel();
    } else if (pin.length < 4 && /\d/.test(num)) {
      setPin((prev) => prev + num);
    }
  }

  React.useEffect(() => {
    if (pin.length === 4) {
      onSubmit(pin);
      setPin('');
    }
  }, [pin, onSubmit]);

  return (
    <div className="flex flex-col items-center gap-8 w-full max-w-[320px] py-4">
      <div className="flex gap-3 justify-center">
        {[...Array(4)].map((_, i) => (
          <div
            key={i}
            className={`w-5 h-5 rounded-full ${
              pin.length > i ? 'bg-white' : 'bg-neutral-700'
            }`}
          />
        ))}
      </div>
      
      <div className="grid grid-cols-3 gap-4 w-full">
        {numbers.map((num, idx) => {
          // Special styling for cancel (X) and backspace buttons
          if (num === 'X' || num === 'â†') {
            return (
              <Button
                key={idx}
                variant="ghost"
                className={`h-14 text-xl ${
                  num === 'X' 
                    ? 'text-neutral-400 hover:text-white hover:bg-neutral-800' 
                    : 'text-neutral-300 hover:text-white hover:bg-neutral-800'
                }`}
                onClick={() => handleClick(num)}
              >
                {num}
              </Button>
            );
          }
          
          // Number buttons
          return (
            <Button
              key={idx}
              variant="ghost"
              className="h-14 text-xl font-medium text-neutral-200 hover:bg-neutral-800 hover:text-white"
              onClick={() => handleClick(num)}
            >
              {num}
            </Button>
          );
        })}
      </div>
      
      <Button 
        variant="outline" 
        className="mt-4 border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white"
        onClick={onCancel}
      >
        Back
      </Button>
    </div>
  );
}

============================================================

FILE: .\features\auth\ReviewerLoginButton.tsx
SIZE: 1.01 KB
LAST MODIFIED: 03/22/2025 22:17:12

'use client';

import * as React from 'react';
import { Button } from '@/components/ui/button';
import { ReviewerLoginModal } from './ReviewerLoginModal';


interface ReviewerLoginButtonProps {
  onLoginSuccess?: (reviewer: Reviewer) => void;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  className?: string;
}

export function ReviewerLoginButton({ 
  onLoginSuccess, 
  variant = 'outline',
  className = '' 
}: ReviewerLoginButtonProps) {
  const [open, setOpen] = React.useState(false);

  const handleLoginSuccess = (reviewer: Reviewer) => {
    setOpen(false);
    if (onLoginSuccess) {
      onLoginSuccess(reviewer);
    }
  };

  return (
    <>
      <Button 
        onClick={() => setOpen(true)} 
        variant={variant} 
        className={className}
      >
        Login
      </Button>
      <ReviewerLoginModal
        open={open}
        onClose={() => setOpen(false)}
        onLoginSuccess={handleLoginSuccess}
      />
    </>
  );
}

============================================================

FILE: .\features\auth\ReviewerLoginModal.tsx
SIZE: 4.96 KB
LAST MODIFIED: 03/22/2025 22:17:43

'use client';

import * as React from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { supabase } from '@/lib/services/supabase';
import PinPad from './PinPad';


interface ReviewerLoginModalProps {
  open: boolean;
  onClose: () => void;
  onLoginSuccess: (reviewer: Reviewer) => void;
}

// Avatar icons for reviewers - desaturated colors
const AVATAR_EMOJIS = ['ðŸ™', 'ðŸˆ', 'ðŸ•', 'ðŸ’', 'ðŸ¢', 'ðŸ£', 'ðŸ¦Š', 'ðŸ¼'];
const AVATAR_COLORS = [
  'from-orange-400/80 to-amber-400/80', // Desaturated Orange/Gold
  'from-red-500/80 to-red-600/80',      // Desaturated Red
  'from-emerald-400/80 to-teal-400/80', // Desaturated Green
  'from-purple-500/80 to-blue-400/80',  // Desaturated Purple/Blue
  'from-blue-400/80 to-cyan-300/80',    // Desaturated Blue
  'from-rose-400/80 to-pink-400/80',    // Desaturated Pink
  'from-amber-300/80 to-yellow-200/80', // Desaturated Yellow
  'from-slate-500/80 to-slate-700/80',  // Desaturated Gray
];

export function ReviewerLoginModal({
  open,
  onClose,
  onLoginSuccess
}: ReviewerLoginModalProps) {
  const [reviewers, setReviewers] = React.useState<Reviewer[]>([]);
  const [selectedReviewer, setSelectedReviewer] = React.useState<Reviewer | null>(null);
  const [error, setError] = React.useState<string | null>(null);
  const [showPinPad, setShowPinPad] = React.useState(false);

  React.useEffect(() => {
    if (open) {
      fetchReviewers();
      setError(null);
      setSelectedReviewer(null);
      setShowPinPad(false);
    }
  }, [open]);

  async function fetchReviewers() {
    try {
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });
      if (error) throw error;
      if (data) setReviewers(data);
    } catch (err: any) {
      console.error('Error fetching reviewers:', err);
      setError('Failed to load reviewers');
    }
  }

  async function handleSelectReviewer(reviewer: Reviewer) {
    setSelectedReviewer(reviewer);
    setShowPinPad(true);
    setError(null);
  }

  async function handlePinSubmit(pin: string) {
    if (!selectedReviewer) return;
    setError(null);

    const { data, error } = await supabase
      .from('reviewers')
      .select('*')
      .eq('id', selectedReviewer.id)
      .eq('pin', pin)
      .maybeSingle();

    if (error) {
      setError('Database error checking PIN');
      return;
    }
    if (!data) {
      setError('Incorrect PIN');
      return;
    }

    onLoginSuccess(selectedReviewer);
    onClose();
  }

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[700px] bg-black border-neutral-800">
        <DialogHeader className="mb-6">
          <DialogTitle className="text-3xl font-medium text-center text-white">
            {!showPinPad ? "Who's reviewing?" : `Enter PIN for ${selectedReviewer?.name}`}
          </DialogTitle>
        </DialogHeader>

        {error && (
          <div className="mb-6 rounded bg-neutral-900 text-neutral-300 p-3 text-center border border-neutral-700">
            {error}
          </div>
        )}

        {!showPinPad ? (
          <div className="flex flex-col items-center">
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-6 mb-8">
              {reviewers.map((rev, index) => (
                <button
                  key={rev.id}
                  onClick={() => handleSelectReviewer(rev)}
                  className="flex flex-col items-center gap-3 transition-transform hover:scale-110 focus:outline-none"
                >
                  <div 
                    className={`w-28 h-28 rounded-md flex items-center justify-center overflow-hidden bg-gradient-to-b ${AVATAR_COLORS[index % AVATAR_COLORS.length]}`}
                  >
                    <div className="text-[3rem] transform scale-150">
                      {AVATAR_EMOJIS[index % AVATAR_EMOJIS.length]}
                    </div>
                  </div>
                  <span className="text-neutral-300 text-sm">{rev.name}</span>
                </button>
              ))}
            </div>
            
            <Button 
              variant="outline" 
              className="border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white mt-4"
              onClick={onClose}
            >
              Cancel
            </Button>
          </div>
        ) : (
          <div className="flex flex-col items-center">
            <PinPad
              onSubmit={handlePinSubmit}
              onCancel={() => {
                setShowPinPad(false);
                setError(null);
                setSelectedReviewer(null);
              }}
            />
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}

============================================================

FILE: .\features\auth\ReviewerProfileDropdown.tsx
SIZE: 3.32 KB
LAST MODIFIED: 03/22/2025 22:17:23

'use client';

import * as React from 'react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ChevronDown, LogOut, FileDownIcon, Plus, CheckSquare } from "lucide-react";

// Avatar icons for reviewers (should match those in ReviewerLoginModal)
const AVATAR_EMOJIS = ['ðŸ™', 'ðŸˆ', 'ðŸ•', 'ðŸ’', 'ðŸ¢', 'ðŸ£', 'ðŸ¦Š', 'ðŸ¼'];
const AVATAR_COLORS = [
  'from-orange-400/80 to-amber-400/80', // Desaturated Orange/Gold
  'from-red-500/80 to-red-600/80',      // Desaturated Red
  'from-emerald-400/80 to-teal-400/80', // Desaturated Green
  'from-purple-500/80 to-blue-400/80',  // Desaturated Purple/Blue
  'from-blue-400/80 to-cyan-300/80',    // Desaturated Blue
  'from-rose-400/80 to-pink-400/80',    // Desaturated Pink
  'from-amber-300/80 to-yellow-200/80', // Desaturated Yellow
  'from-slate-500/80 to-slate-700/80',  // Desaturated Gray
];

interface ReviewerProfileDropdownProps {
  reviewer: Reviewer;
  reviewerIndex: number; // To determine the emoji and color
  onLogout: () => void;
  onExportClick: () => void;
  onAddWordsClick: () => void;
  onReviewWordsClick: () => void;
}

export function ReviewerProfileDropdown({
  reviewer,
  reviewerIndex = 0,
  onLogout,
  onExportClick,
  onAddWordsClick,
  onReviewWordsClick
}: ReviewerProfileDropdownProps) {
  const avatarEmoji = AVATAR_EMOJIS[reviewerIndex % AVATAR_EMOJIS.length];
  const avatarColor = AVATAR_COLORS[reviewerIndex % AVATAR_COLORS.length];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger className="flex items-center gap-2 outline-none">
        <div className={`w-9 h-9 rounded-full flex items-center justify-center overflow-hidden bg-gradient-to-b ${avatarColor}`}>
          <div className="text-2xl transform scale-150 translate-y-1">
            {avatarEmoji}
          </div>
        </div>
        <span className="text-sm text-white hidden sm:inline-block">{reviewer.name}</span>
        <ChevronDown className="h-4 w-4 text-muted-foreground" />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col">
            <span>{reviewer.name}</span>
            <span className="text-xs text-muted-foreground">{reviewer.total_reviews || 0} reviews</span>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem className="cursor-pointer" onClick={onAddWordsClick}>
          <Plus className="mr-2 h-4 w-4" />
          <span>Add Words</span>
        </DropdownMenuItem>
        <DropdownMenuItem className="cursor-pointer" onClick={onReviewWordsClick}>
          <CheckSquare className="mr-2 h-4 w-4" />
          <span>Review Words</span>
        </DropdownMenuItem>
        <DropdownMenuItem className="cursor-pointer" onClick={onExportClick}>
          <FileDownIcon className="mr-2 h-4 w-4" />
          <span>Export</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem className="cursor-pointer" onClick={onLogout}>
          <LogOut className="mr-2 h-4 w-4" />
          <span>Logout</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

============================================================

FILE: .\features\dashboard\Dashboard.tsx
SIZE: 19.33 KB
LAST MODIFIED: 03/22/2025 23:04:24

'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { supabase } from '@/lib/services/supabase';
import { useTheme } from 'next-themes';
import './styles/dashboard.css';

// Import chart components
import { ChartContainer, ChartTooltip, ChartTooltipContent } from '@/features/charts';
import WordCreatorModal from '@/features/phrases/WordCreatorModal';
import ReviewModal from '@/features/phrases/ReviewModal';

// Components
import { PhrasesTable } from '@/features/phrases/phrasesTable';
import { DashboardHeader } from '@/features/dashboard/components/DashboardHeader';
import ExportModal from '@/features/dashboard/components/ExportModal';
import FilterModal from '@/features/filters/FilterModal';
import { FilterProvider } from '@/features/phrases/stores/filterContext';
import { StatsCards } from '@/features/dashboard/components/StatsCards';
import AnalyticsSection from '@/features/dashboard/components/AnalyticsSection';


// UI Components
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { PillTabs, PillTabsContent } from '@/components/ui/pill-tabs'; 

// Hooks
import { useStats } from '@/features/data/hooks/useStats';
import { usePhrases } from '@/features/data/hooks/usePhrases';
import { usePhraseMetadata } from '@/features/data/hooks/usePhraseMetadata';
import { useReviewers } from '@/features/data/hooks/useReviewers';
import { useDeletePhrase } from '@/features/phrases/hooks/useDeletePhrase';
import { useDashboardState } from '@/features/dashboard/hooks/useDashboardState';

// Types
import type { Reviewer, Phrase } from '@/types/types';

const Dashboard = () => {
  const router = useRouter();
  const { theme, setTheme } = useTheme();
  
  // Use dashboard state hook for centralized state management
  const {
    activeTab, 
    setActiveTab,
    showWordCreatorModal, 
    setShowWordCreatorModal,
    showReviewModal, 
    setShowReviewModal,
    showFilterModal, 
    setShowFilterModal,
    showExportModal, 
    setShowExportModal,
    selectedPhraseId,
    setSelectedPhraseId,
    newIds, 
    setNewIds,
    currentReviewer,
    setCurrentReviewer, 
    isExporting,
    setIsExporting,
  } = useDashboardState();
  
  // Initialize the delete phrase mutation
  const deletePhraseMutation = useDeletePhrase();
  
  // Add handlers for edit and delete
  const handleEdit = (id: number) => {
    setSelectedPhraseId(id);
    setShowReviewModal(true);
  };

  const handleDelete = (id: number) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      deletePhraseMutation.mutate(id, {
        onSuccess: () => {
          // Refresh the phrases list after deletion
          fetchPhrases();
        }
      });
    }
  };
  
  // ======= DASHBOARD UI STATE =======
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [phrasesOverTime, setPhrasesOverTime] = useState<any[]>([]);

  // ======= DATA HOOKS =======
  const { stats, loading: statsLoading } = useStats();
  const { reviewers } = useReviewers();
  const {
    phrases,
    loading: phrasesLoading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    editPhrase,
    deletePhrase,
    resetFilters,
    fetchPhrases,
  } = usePhrases();
  const { categories, difficulties, partsOfSpeech } = usePhraseMetadata();

  // Find reviewer index for the avatar
  const reviewerIndex = currentReviewer 
    ? reviewers?.findIndex(r => r.id === currentReviewer.id) ?? 0
    : 0;

  // ======= TABLE STATE =======
  const [tableState, setTableState] = useState<TableState>({
    sortConfig: {
      key: '',
      direction: 'asc'
    },
    pagination: {
      currentPage: 1,
      rowsPerPage: 10,  // Set default to 10
      totalItems: 0,
      totalPages: 1
    },
    filters: {
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    }
  });
  
  // ======= CHART DATA =======
  // Data for the radial chart
  const wordsAddedData = [
    { name: "Words Added", value: 45, fill: "hsl(var(--primary))" },
    { name: "Goal", value: 100, fill: "hsl(var(--muted))" },
  ];

  // Chart configuration
  const chartConfig = {
    phrases: { label: 'Phrases', color: 'var(--chart-1)' },
    reviews: { label: 'Reviews', color: 'var(--chart-2)' },
    additions: { label: 'Additions', color: 'var(--chart-3)' },
    edits: { label: 'Edits', color: 'var(--chart-4)' }
  };

  // ======= AUTH HANDLERS =======
  /**
   * Handle successful login
   */
  const handleLoginSuccess = (reviewer: Reviewer) => {
    setCurrentReviewer(reviewer);
    localStorage.setItem('currentReviewer', JSON.stringify(reviewer));
    console.log('Reviewer logged in:', reviewer.name);
  };
  
  /**
   * Handle logout
   */
  const handleLogout = () => {
    setCurrentReviewer(null);
    localStorage.removeItem('currentReviewer');
  };

  // Add this function since it's used in the component
  const handleWordAdded = (id: number) => {
    // Track newly added phrase ID
    setNewIds(prev => [...prev, id]);
    // Refresh data after a word is added
    fetchPhrases();
  };

  const handleAddWordsClick = () => {
    setShowWordCreatorModal(true);
  };
  
  const handleReviewWordsClick = () => {
    setShowReviewModal(true);
  };

  // ======= EFFECTS =======
  
  // Load reviewer from localStorage on initial render
  useEffect(() => {
    const savedReviewer = localStorage.getItem('currentReviewer');
    if (savedReviewer) {
      try {
        setCurrentReviewer(JSON.parse(savedReviewer));
      } catch (e) {
        console.error("Error parsing saved reviewer:", e);
        localStorage.removeItem('currentReviewer');
      }
    }
  }, []);

  // Hide any debug JSON output on load
  useEffect(() => {
    const preElements = document.querySelectorAll('pre');
    preElements.forEach(el => {
      if (
        el.textContent &&
        el.textContent.includes('"dataLength":') &&
        el.textContent.includes('"totalItems":')
      ) {
        el.style.display = 'none';
      }
    });
  }, []);

  // Sync Table State with hook state
  useEffect(() => {
    if (phrases && pagination) {
      const totalItems = pagination.totalItems || phrases.length || 0;
      const rowsPerPage = pagination.rowsPerPage || 10; // Get rowsPerPage from pagination
      const totalPages = Math.ceil(totalItems / rowsPerPage);
      
      setTableState(prev => ({
        ...prev,
        sortConfig,
        pagination: {
          ...pagination,
          rowsPerPage,
          totalItems,
          totalPages,
          currentPage: Math.min(pagination.currentPage, totalPages || 1)
        },
        filters,
      }));
    }
  }, [phrases, pagination, sortConfig, filters]);



  // Fetch subcategories when the category filter changes
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!filters.category) {
        setSubcategories([]);
        return;
      }
      try {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();
        if (categoryData) {
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');
          if (subcategoryData) {
            setSubcategories(subcategoryData.map(sub => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      }
    };
    fetchSubcategories();
  }, [filters.category]);

  // Fetch phrases over time
  useEffect(() => {
    fetchPhrasesOverTime();
  }, []);

  // ======= DATA FUNCTIONS =======
  /**
   * Fetch phrases over time data for chart
   */
  const fetchPhrasesOverTime = async () => {
    try {
      const { data, error } = await supabase
        .from('phrases')
        .select('created_at')
        .order('created_at');
      if (error) {
        console.error('Error fetching phrase timestamps:', error);
        setPhrasesOverTime(getErrorStateData());
        return;
      }
      if (data && data.length > 0) {
        const monthlyData = processTimestampData(data);
        setPhrasesOverTime(monthlyData);
      } else {
        setPhrasesOverTime(getErrorStateData());
      }
    } catch (err) {
      console.error('Error fetching phrase timestamps:', err);
      setPhrasesOverTime(getErrorStateData());
    }
  };

  /**
   * Process timestamp data for charts
   */
  const processTimestampData = (data: any[]) => {
    const monthCounts: Record<string, any> = {};
    data.forEach(item => {
      if (!item.created_at) return;
      const date = new Date(item.created_at);
      const month = date.toLocaleString('default', { month: 'short' });
      const year = date.getFullYear();
      const key = `${month} ${year}`;
      if (!monthCounts[key]) {
        monthCounts[key] = { month, year, count: 0, fullDate: date };
      }
      monthCounts[key].count++;
    });
    return Object.values(monthCounts)
      .sort((a, b) => a.fullDate - b.fullDate)
      .map(item => ({ month: item.month, year: item.year, phrases: item.count }))
      .slice(-6);
  };

  /**
   * Get fallback data for charts when error occurs
   */
  const getErrorStateData = () => {
    return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'].map(month => ({
      month,
      year: new Date().getFullYear(),
      phrases: null
    }));
  };
  /**
   * Handle table state changes
   */
  const handleTableStateChange = (updates: Partial<TableState>) => {
    // Update local state first
    setTableState(prev => {
      const newState = { ...prev };
      
      if (updates.filters) {
        newState.filters = { ...prev.filters, ...updates.filters };
      }
      
      if (updates.sortConfig) {
        newState.sortConfig = { ...prev.sortConfig, ...updates.sortConfig };
      }
      
      if (updates.pagination) {
        // Make sure all pagination properties are properly set
        newState.pagination = { ...prev.pagination, ...updates.pagination };
      }
      
      return newState;
    });
    
    // Then immediately propagate changes to the hooks
    if (updates.filters) {
      // Apply each filter individually to ensure all are updated
      Object.entries(updates.filters).forEach(([key, value]) => {
        if (value !== undefined) { // Only update if value is provided
          handleFilterChange(key, value || '');
        }
      });
    }
    
    if (updates.sortConfig && updates.sortConfig.key) {
      handleSort(updates.sortConfig.key as keyof Phrase);
    }
    
    if (updates.pagination) {
      // Note: Order matters here! First update rows per page, then page number
      if (updates.pagination.rowsPerPage) {
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
      
      if (updates.pagination.currentPage) {
        handlePageChange(updates.pagination.currentPage);
      }
    }
  };

  /**
   * Generate monthly activity data for charts
   */
  const generateMonthlyActivityData = () => {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
    return months.map(month => ({
      name: month,
      reviews: Math.floor(Math.random() * 100) + 50,
      additions: Math.floor(Math.random() * 40) + 10,
      edits: Math.floor(Math.random() * 30) + 5,
    }));
  };

  const monthlyActivityData = generateMonthlyActivityData();

  /**
   * Generate category data for charts
   */
  const generateCategoryData = () => {
    if (categories && categories.length > 0) {
      return [
        { name: 'Animals & Plants', value: 30 },
        { name: 'Art & Design', value: 22 },
        { name: 'Education & Learning', value: 13 },
        { name: 'Celebrations & Traditions', value: 16 },
        { name: 'Business & Careers', value: 19 },
      ];
    }
    return [
      { name: 'Animals & Plants', value: 30 },
      { name: 'Art & Design', value: 22 },
      { name: 'Education & Learning', value: 13 },
      { name: 'Celebrations & Traditions', value: 16 },
      { name: 'Business & Careers', value: 19 },
    ];
  };

  const categoryData = generateCategoryData();

  /**
   * Handle exporting data
   */
  const handleExport = async (options: any) => {
    try {
      setIsExporting(true);
      const { data: phrases, error: phrasesError } = await supabase
        .from('phrases')
        .select(`
          id,
          phrase,
          part_of_speech,
          hint,
          category_id,
          subcategory_id,
          difficulty,
          categories:category_id(name),
          subcategories:subcategory_id(name)
        `);
      if (phrasesError) throw phrasesError;
      const { data: phraseTags, error: tagsError } = await supabase
        .from('phrase_tags')
        .select(`
          phrase_id,
          tags:tag_id(tag)
        `);
      if (tagsError) throw tagsError;
      
      // Process data
      const tagsByPhraseId: Record<string, string[]> = {};
      phraseTags.forEach((item: any) => {
        if (!tagsByPhraseId[item.phrase_id]) {
          tagsByPhraseId[item.phrase_id] = [];
        }
        tagsByPhraseId[item.phrase_id].push(item.tags.tag);
      });
      
      const categorizedPhrases: Record<string, any[]> = {};
      phrases.forEach((phrase: any) => {
        const categoryName = phrase.categories ? phrase.categories.name : 'Uncategorized';
        if (!categorizedPhrases[categoryName]) {
          categorizedPhrases[categoryName] = [];
        }
        categorizedPhrases[categoryName].push({
          text: phrase.phrase,
          pos: phrase.part_of_speech,
          hint: phrase.hint || '',
          difficulty: phrase.difficulty || 1,
          subcategory: phrase.subcategories ? phrase.subcategories.name : null,
          tags: tagsByPhraseId[phrase.id] || [],
        });
      });
      
      const esp32Data: Record<string, any[]> = {};
      Object.keys(categorizedPhrases).forEach(cat => {
        if (options.optimizeForESP32) {
          esp32Data[cat] = categorizedPhrases[cat].map(p => ({
            t: p.text,
            h: p.hint || '',
            d: p.difficulty || 1
          }));
        } else {
          esp32Data[cat] = categorizedPhrases[cat];
        }
      });
      
      const headerContent = options.exportHeader ? generateArduinoHeader(esp32Data) : '';
      setIsExporting(false);
      return { jsonData: esp32Data, headerContent };
    } catch (error) {
      console.error('Export error:', error);
      setIsExporting(false);
      return null;
    }
  };

  /**
   * Generate Arduino header file
   */
  const generateArduinoHeader = (data: Record<string, any[]>) => {
    let headerContent = `// Auto-generated phrases header file
#ifndef PHRASES_H
#define PHRASES_H

#include <Arduino.h>

struct Phrase {
  const char* text;
  const char* hint;
  uint8_t difficulty;
};
`;
    Object.keys(data).forEach(category => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      const phrases = data[category];
      headerContent += `// ${category} phrases
constexpr Phrase ${categoryVar}_phrases[] PROGMEM = {
`;
      phrases.forEach(phrase => {
        const text = phrase.t || phrase.text;
        const hint = phrase.h || phrase.hint || '';
        const difficulty = phrase.d || phrase.difficulty || 1;
        headerContent += `  {"${escapeString(text)}", "${escapeString(hint)}", ${difficulty}},
`;
      });
      headerContent += `};

constexpr size_t ${categoryVar}_count = ${phrases.length};

`;
    });
    headerContent += `// Category index
struct PhraseCategory {
  const char* name;
  const Phrase* phrases;
  size_t count;
};

constexpr PhraseCategory phrase_categories[] PROGMEM = {
`;
    Object.keys(data).forEach(category => {
      const categoryVar = category.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
      headerContent += `  {"${escapeString(category)}", ${categoryVar}_phrases, ${categoryVar}_count},
`;
    });
    headerContent += `};

constexpr size_t category_count = ${Object.keys(data).length};

#endif // PHRASES_H
`;
    return headerContent;
  };

  /**
   * Escape strings for C++ code
   */
  const escapeString = (str: string) => {
    if (!str) return "";
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
  };

  // ======= RENDER =======
  return (
    <div className="container mx-auto py-6 space-y-6">
      <DashboardHeader
        theme={theme}
        setTheme={setTheme}
        onExportClick={() => setShowExportModal(true)}
        currentReviewer={currentReviewer}
        onLoginSuccess={handleLoginSuccess}
        onLogout={handleLogout}
        onAddWordsClick={handleAddWordsClick}
        onReviewWordsClick={handleReviewWordsClick}
      />
    
    {/* Add the StatsCards component here */}
    <StatsCards />

      <div className="mb-6">
        {/* Word Creator Modal */}
{currentReviewer && (
  <WordCreatorModal
    isOpen={showWordCreatorModal}
    onClose={() => setShowWordCreatorModal(false)}
    reviewer={currentReviewer}
    onWordAdded={handleWordAdded}
  />
)}

{/* Review Modal */}
{currentReviewer && (
  <ReviewModal
  isOpen={showReviewModal}
  onClose={() => {
    setShowReviewModal(false);
    setSelectedPhraseId(null);
  }}
  reviewer={currentReviewer}
  selectedPhraseId={selectedPhraseId}
/>
)}
  <PillTabs
    tabs={[
      { value: 'phrases', label: 'Phrases' },
      { value: 'analytics', label: 'Analytics' }
    ]}
    activeTab={activeTab}
    onTabChange={setActiveTab}
    className="py-3 border-dashed border-y"
  />

{/* Phrases Tab */}
<PillTabsContent value="phrases" activeTab={activeTab}>
  <div className="flex flex-col space-y-4">
    {/* Wrap your existing PhrasesTable with FilterProvider */}
    <FilterProvider>
      <PhrasesTable
        phrases={phrases}
        loading={phrasesLoading}
        tableState={tableState}
        onTableStateChange={handleTableStateChange}
        onEdit={handleEdit}
        onDelete={handleDelete}
        newIds={newIds}
      />
    </FilterProvider>
  </div>
</PillTabsContent>

        {/* Analytics Tab */}
        <PillTabsContent value="analytics" activeTab={activeTab}>
          <AnalyticsSection />
        </PillTabsContent>
          </div>

      {/* Modals */}
      <FilterModal
        isOpen={showFilterModal}
        onClose={() => setShowFilterModal(false)}
        filters={filters}
        onChange={handleFilterChange}
        onReset={resetFilters}
        categories={categories}
        difficulties={difficulties}
        partsOfSpeech={partsOfSpeech}
        subcategories={subcategories}
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        onExport={handleExport}
        isLoading={isExporting}
      />
    </div>
  );
};

export default Dashboard;

============================================================

FILE: .\features\dashboard\types.ts
SIZE: 1.02 KB
LAST MODIFIED: 03/22/2025 22:45:54

// features/dashboard/types.ts
export interface DashboardStateHook {
  // Tab and Modal States
  activeTab: string;
  setActiveTab: (tab: string) => void;
  showWordCreatorModal: boolean;
  setShowWordCreatorModal: (show: boolean) => void;
  showReviewModal: boolean;
  setShowReviewModal: (show: boolean) => void;
  showFilterModal: boolean;
  setShowFilterModal: (show: boolean) => void;
  showExportModal: boolean;
  setShowExportModal: (show: boolean) => void;
  
  // Data States
  selectedPhraseId: number | null;
  setSelectedPhraseId: (id: number | null) => void;
  newIds: number[];
  setNewIds: (ids: number[]) => void;
  dateRange: number;
  updateDateRange: (days: number) => void;
  currentReviewer: Reviewer | null;
  isExporting: boolean;
  setIsExporting: (isExporting: boolean) => void;
  
  // Loading States
  isLoading: boolean;
  error: string | null;
  
  // Handlers
  handleLoginSuccess: (reviewer: Reviewer) => void;
  handleLogout: () => void;
  handleWordAdded: (id: number) => void;
}

============================================================

FILE: .\features\dashboard\components\AnalyticsSection.tsx
SIZE: 12.23 KB
LAST MODIFIED: 03/21/2025 23:53:07

// features/dashboard/components/AnalyticsSection/AnalyticsSection.tsx
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import {
  PieChart, Pie, Cell, BarChart, Bar, 
  ResponsiveContainer, Tooltip, Legend, XAxis, YAxis, CartesianGrid
} from 'recharts';
import { supabase } from '@/lib/services/supabase';

export const AnalyticsSection = () => {
  const [categoryData, setCategoryData] = useState([]);
  const [difficultyData, setDifficultyData] = useState([]);
  const [phrasesAdded, setPhrasesAdded] = useState(0);
  const [reviewsCompleted, setReviewsCompleted] = useState(0);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        // Fetch categories data
        const { data: categoriesData, error: categoriesError } = await supabase
          .from('phrases')
          .select('category_id, categories:category_id(name)');

        if (categoriesError) throw categoriesError;

        // Count frequency of each category
        const categoryCounts = {};
        categoriesData.forEach(item => {
          const categoryName = item.categories?.name || 'Uncategorized';
          categoryCounts[categoryName] = (categoryCounts[categoryName] || 0) + 1;
        });

        // Convert to array format for Bar Chart and sort by value (descending)
        const categoryDataArray = Object.entries(categoryCounts)
          .map(([name, value]) => ({ name, value }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 10); // Take top 10 categories for better visualization

        setCategoryData(categoryDataArray);

        // Fetch difficulty data
        const { data: difficultyRawData, error: difficultyError } = await supabase
          .from('phrases')
          .select('difficulty');

        if (difficultyError) throw difficultyError;

        // Count frequency of each difficulty level
        const difficultyCounts = { 'Easy': 0, 'Medium': 0, 'Hard': 0 };
        difficultyRawData.forEach(item => {
          const diffLevel = item.difficulty === 1 ? 'Easy' : 
                           item.difficulty === 2 ? 'Medium' : 
                           item.difficulty === 3 ? 'Hard' : 'Unknown';
          difficultyCounts[diffLevel] = (difficultyCounts[diffLevel] || 0) + 1;
        });

        // Convert to array format for PieChart
        const difficultyDataArray = Object.entries(difficultyCounts).map(([name, value]) => ({
          name,
          value
        }));

        setDifficultyData(difficultyDataArray);

        // Get phrases added this month
        const firstDayOfMonth = new Date();
        firstDayOfMonth.setDate(1);
        firstDayOfMonth.setHours(0, 0, 0, 0);

        const { data: phrasesThisMonth, error: phrasesError } = await supabase
          .from('phrases')
          .select('id')
          .gte('created_at', firstDayOfMonth.toISOString());

        if (phrasesError) throw phrasesError;
        setPhrasesAdded(phrasesThisMonth?.length || 0);

        // Get reviews completed this month
        const { data: reviewsThisMonth, error: reviewsError } = await supabase
          .from('votes')
          .select('id')
          .gte('created_at', firstDayOfMonth.toISOString());

        if (reviewsError) throw reviewsError;
        setReviewsCompleted(reviewsThisMonth?.length || 0);

      } catch (error) {
        console.error('Error fetching stats data:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  // Grayscale colors for the visualizations
  const COLORS = ['#555555', '#777777', '#999999', '#BBBBBB', '#DDDDDD'];

  // If loading, show skeleton state
  if (loading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {[1, 2, 3, 4].map((i) => (
          <Card key={i} className="animate-pulse">
            <CardHeader className="pb-2">
              <div className="h-6 w-1/3 bg-gray-200 dark:bg-gray-700 rounded"></div>
            </CardHeader>
            <CardContent>
              <div className="h-[250px] w-full bg-gray-100 dark:bg-gray-800 rounded"></div>
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  // Calculate percentage for gauges
  const phrasesPercentage = Math.min(100, Math.round((phrasesAdded / 100) * 100));
  const reviewsPercentage = Math.min(100, Math.round((reviewsCompleted / 100) * 100));

  // Gauge chart needle renderer
  const renderNeedle = (value, data, cx, cy, iRadius, oRadius, color) => {
    const angle = 180 - value * 1.8; // Convert percentage to angle (180 to 0)
    const length = oRadius * 0.8; // Length of the needle
    const sin = Math.sin(-angle * Math.PI / 180);
    const cos = Math.cos(-angle * Math.PI / 180);
    const r = 5; // Needle base radius
    const x0 = cx;
    const y0 = cy;
    const xba = x0 + r * sin;
    const yba = y0 - r * cos;
    const xbb = x0 - r * sin;
    const ybb = y0 + r * cos;
    const xp = x0 + length * sin;
    const yp = y0 - length * cos;

    return [
      <circle cx={x0} cy={y0} r={r + 2} fill={color} stroke="none" key="needle-center" />,
      <path d={`M${xba} ${yba}L${xbb} ${ybb}L${xp} ${yp}Z`} fill={color} key="needle-path" />
    ];
  };

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {/* Category Bar Chart - horizontal layout for better category name display */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Category Distribution</CardTitle>
          <CardDescription>Top categories by phrase count</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                layout="vertical"
                data={categoryData}
                margin={{ top: 5, right: 30, left: 75, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#555" opacity={0.2} />
                <XAxis type="number" />
                <YAxis 
                  type="category" 
                  dataKey="name" 
                  width={75}
                  tick={{ fontSize: 11 }}
                />
                <Tooltip
                  formatter={(value) => [`${value} phrases`, 'Count']}
                  contentStyle={{ backgroundColor: '#333', border: '1px solid #444' }}
                />
                <Bar dataKey="value" fill="#555555">
                  {categoryData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Difficulty Pie Chart */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Difficulty Distribution</CardTitle>
          <CardDescription>Breakdown by difficulty level</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={difficultyData}
                  cx="50%"
                  cy="50%"
                  labelLine={true}
                  innerRadius={60}
                  outerRadius={90}
                  fill="#8884d8"
                  dataKey="value"
                  stroke="#000"
                  label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                >
                  {difficultyData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip 
                  formatter={(value) => [`${value} phrases`, 'Count']}
                  contentStyle={{ backgroundColor: '#333', border: '1px solid #444' }}
                />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Monthly Phrases Goal Gauge */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Words Added This Month</CardTitle>
          <CardDescription>Progress towards the goal of 100 words</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  startAngle={180}
                  endAngle={0}
                  data={[
                    { name: 'Empty', value: 100 - phrasesPercentage, fill: '#E5E7EB' },
                    { name: 'Progress', value: phrasesPercentage, fill: '#777777' }
                  ]}
                  cx="50%"
                  cy="80%"
                  innerRadius={70}
                  outerRadius={90}
                  fill="#8884d8"
                  paddingAngle={0}
                  dataKey="value"
                  stroke="none"
                >
                </Pie>
                {renderNeedle(phrasesPercentage, null, '50%', '80%', 70, 90, '#333333')}
                <text
                  x="50%"
                  y="50%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground font-bold"
                  fontSize="24"
                >
                  {phrasesPercentage}%
                </text>
                <text
                  x="50%"
                  y="75%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground"
                  fontSize="14"
                >
                  {phrasesAdded}/100 words
                </text>
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Monthly Reviews Goal Gauge */}
      <Card className="border rounded-md">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Reviews Completed This Month</CardTitle>
          <CardDescription>Progress towards 100 reviews this month</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[250px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  startAngle={180}
                  endAngle={0}
                  data={[
                    { name: 'Empty', value: 100 - reviewsPercentage, fill: '#E5E7EB' },
                    { name: 'Progress', value: reviewsPercentage, fill: '#777777' }
                  ]}
                  cx="50%"
                  cy="80%"
                  innerRadius={70}
                  outerRadius={90}
                  fill="#8884d8"
                  paddingAngle={0}
                  dataKey="value"
                  stroke="none"
                >
                </Pie>
                {renderNeedle(reviewsPercentage, null, '50%', '80%', 70, 90, '#333333')}
                <text
                  x="50%"
                  y="50%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground font-bold"
                  fontSize="24"
                >
                  {reviewsPercentage}%
                </text>
                <text
                  x="50%"
                  y="75%"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  className="fill-foreground"
                  fontSize="14"
                >
                  {reviewsCompleted}/100 reviews
                </text>
              </PieChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default AnalyticsSection;

============================================================

FILE: .\features\dashboard\components\DashboardHeader.tsx
SIZE: 2.06 KB
LAST MODIFIED: 03/22/2025 22:58:57

'use client';

import React from 'react';
import { Button } from "@/components/ui/button";
import { Moon, Sun } from "lucide-react";
import { ReviewerLoginButton } from '@/features/auth/ReviewerLoginButton';
import { ReviewerProfileDropdown } from '@/features/auth/ReviewerProfileDropdown';
import { Reviewer } from '@/types/types'; // Make sure to import the Reviewer type

// Define the props interface
interface DashboardHeaderProps {
  theme?: string;
  setTheme: (theme: string) => void;
  onExportClick: () => void;
  currentReviewer: Reviewer | null;
  onLoginSuccess: (reviewer: Reviewer) => void;
  onLogout: () => void;
  onAddWordsClick: () => void;
  onReviewWordsClick: () => void;
}

export function DashboardHeader({ 
  theme, 
  setTheme, 
  onExportClick,
  currentReviewer,
  onLoginSuccess,
  onLogout,
  onAddWordsClick,
  onReviewWordsClick
}: DashboardHeaderProps) {
  return (
    <div className="flex justify-between items-center">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground">Manage your catch phrases</p>
      </div>

      <div className="flex items-center gap-3">
        <Button
          variant="outline"
          size="icon"
          onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
          className="h-9 w-9 rounded-md"
        >
          {theme === 'dark' ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />}
        </Button>

        {currentReviewer ? (
          <ReviewerProfileDropdown 
            reviewer={currentReviewer} 
            reviewerIndex={0} 
            onLogout={onLogout}
            onExportClick={onExportClick}
            onAddWordsClick={onAddWordsClick}
            onReviewWordsClick={onReviewWordsClick}
          />
        ) : (
          <ReviewerLoginButton 
            variant="secondary"
            className="text-black bg-white hover:bg-gray-100 rounded-md border-0"
            onLoginSuccess={onLoginSuccess}
          />
        )}
      </div>
    </div>
  );
}

============================================================

FILE: .\features\dashboard\components\ExportModal.tsx
SIZE: 4.29 KB
LAST MODIFIED: 03/17/2025 21:35:28

// src/components/common/ExportModal.tsx

import React, { useState } from 'react';
import { saveAs } from 'file-saver';
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogFooter, 
  DialogHeader, 
  DialogTitle
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

interface ExportModalProps {
  isOpen: boolean;
  onClose: () => void;
  onExport: (options: ExportOptions) => Promise<ExportResult | null>;
  isLoading: boolean;
}

interface ExportOptions {
  exportJson: boolean;
  exportHeader: boolean;
  optimizeForESP32: boolean;
}

interface ExportResult {
  jsonData: any;
  headerContent: string;
}

const ExportModal: React.FC<ExportModalProps> = ({ 
  isOpen, 
  onClose, 
  onExport,
  isLoading
}) => {
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    exportJson: true,
    exportHeader: true,
    optimizeForESP32: true
  });

  const handleOptionChange = (option: keyof ExportOptions) => {
    setExportOptions(prev => ({
      ...prev,
      [option]: !prev[option]
    }));
  };

  const handleExport = async () => {
    const data = await onExport(exportOptions);
    
    if (!data) return;

    // Download files based on options
    if (exportOptions.exportJson) {
      const jsonBlob = new Blob(
        [JSON.stringify(data.jsonData, null, 2)], 
        { type: 'application/json' }
      );
      saveAs(jsonBlob, 'phrases_esp32.json');
    }
    
    if (exportOptions.exportHeader) {
      const headerBlob = new Blob(
        [data.headerContent], 
        { type: 'text/plain' }
      );
      saveAs(headerBlob, 'phrases.h');
    }

    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md bg-black border-neutral-800">
        <DialogHeader>
          <DialogTitle className="text-white">Export Phrases for ESP32</DialogTitle>
          <DialogDescription className="text-neutral-400">
            Choose export options for your ESP32 catch phrase game
          </DialogDescription>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-json" 
              checked={exportOptions.exportJson} 
              onCheckedChange={() => handleOptionChange('exportJson')}
            />
            <Label htmlFor="export-json" className="text-neutral-300">Export JSON file (for SPIFFS)</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="export-header" 
              checked={exportOptions.exportHeader} 
              onCheckedChange={() => handleOptionChange('exportHeader')}
            />
            <Label htmlFor="export-header" className="text-neutral-300">Export Arduino header file</Label>
          </div>
          
          <div className="flex items-center space-x-2">
            <Checkbox 
              id="optimize" 
              checked={exportOptions.optimizeForESP32} 
              onCheckedChange={() => handleOptionChange('optimizeForESP32')}
            />
            <Label htmlFor="optimize" className="text-neutral-300">Optimize for ESP32 memory usage</Label>
          </div>
        </div>
        
        <DialogFooter>
          <Button 
            type="button" 
            variant="outline" 
            onClick={onClose}
            className="border-neutral-600 text-neutral-400 hover:bg-neutral-800 hover:text-white"
          >
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleExport}
            disabled={isLoading}
            className="bg-neutral-100 text-black hover:bg-white"
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Exporting...
              </>
            ) : (
              'Export'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default ExportModal;

============================================================

FILE: .\features\dashboard\components\ImportSection.tsx
SIZE: 0.49 KB
LAST MODIFIED: 03/21/2025 10:05:40

// features/dashboard/components/ImportSection.tsx
import React from 'react';
import BulkImportForm from '@/features/import/BulkImportForm';

interface ImportSectionProps {
  onSuccess?: () => void;
}

export const ImportSection: React.FC<ImportSectionProps> = ({ onSuccess }) => {
  const handleError = (error: string) => {
    console.error('Import error:', error);
  };

  return (
    <BulkImportForm 
      onSuccess={onSuccess} 
      onError={handleError} 
    />
  );
};

============================================================

FILE: .\features\dashboard\components\PhrasesSection.tsx
SIZE: 2.41 KB
LAST MODIFIED: 03/21/2025 10:04:10

// features/dashboard/components/PhrasesSection.tsx
import React from 'react';
import { PhrasesTable } from '@/features/phrases/phrasesTable';
import { FilterProvider } from '@/features/phrases/stores/filterContext';
import { useDeletePhrase } from '@/features/phrases/hooks/useDeletePhrase';
import { usePhrases } from '@/features/data/hooks/usePhrases';

interface PhrasesSectionProps {
  newIds: number[];
}

export const PhrasesSection: React.FC<PhrasesSectionProps> = ({ newIds }) => {
  const {
    phrases,
    loading: phrasesLoading,
    filters,
    pagination,
    sortConfig,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    fetchPhrases
  } = usePhrases();

  // Initialize the delete phrase mutation
  const deletePhraseMutation = useDeletePhrase();
  
  // Add handlers for edit and delete
  const handleEdit = (id: number) => {
    console.log('Editing phrase with ID:', id);
  };

  const handleDelete = (id: number) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      deletePhraseMutation.mutate(id, {
        onSuccess: () => {
          fetchPhrases();
        }
      });
    }
  };

  // Create a tableState object from the hook's state
  const tableState = {
    sortConfig,
    pagination,
    filters
  };

  // Function to update the table state
  const handleTableStateChange = (updates: any) => {
    if (updates.filters) {
      Object.entries(updates.filters).forEach(([key, value]) => {
        if (value !== undefined) {
          handleFilterChange(key, value as string);
        }
      });
    }
    
    if (updates.sortConfig?.key) {
      handleSort(updates.sortConfig.key);
    }
    
    if (updates.pagination) {
      if (updates.pagination.rowsPerPage) {
        handleRowsPerPageChange(updates.pagination.rowsPerPage);
      }
      
      if (updates.pagination.currentPage) {
        handlePageChange(updates.pagination.currentPage);
      }
    }
  };

  return (
    <div className="flex flex-col space-y-4">
      <FilterProvider>
        <PhrasesTable
          phrases={phrases}
          loading={phrasesLoading}
          tableState={tableState}
          onTableStateChange={handleTableStateChange}
          onEdit={handleEdit}
          onDelete={handleDelete}
          newIds={newIds}
        />
      </FilterProvider>
    </div>
  );
};

============================================================

FILE: .\features\dashboard\components\StatsCards.tsx
SIZE: 6.34 KB
LAST MODIFIED: 03/21/2025 23:46:46

// features/dashboard/components/StatsCards.tsx
import React, { useEffect, useState } from 'react';
import { Card } from '@/components/ui/card';
import { useDashboardState } from '../hooks/useDashboardState';
import { TrendingUp, TrendingDown, Minus, Award, Users, BookOpen, Clock } from 'lucide-react';

// Type for each stat card
type StatCardProps = {
  title: string;
  value: string | number;
  description: string;
  trend?: number;
  trendDirection?: 'up' | 'down' | 'neutral';
  timeframe: string;
  icon?: React.ReactNode;
  loading?: boolean;
  sparklineData?: number[];
};

// Individual stat card component
const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  trend = 0,
  trendDirection = 'neutral',
  timeframe,
  icon,
  loading = false,
  sparklineData = [],
}) => {
  // Determine color and icon based on trend direction
  const getTrendColor = () => {
    if (trendDirection === 'up') return 'text-green-500';
    if (trendDirection === 'down') return 'text-red-500';
    return 'text-gray-500';
  };

  const getTrendIcon = () => {
    if (trendDirection === 'up') return <TrendingUp className="w-4 h-4 ml-1" />;
    if (trendDirection === 'down') return <TrendingDown className="w-4 h-4 ml-1" />;
    return <Minus className="w-4 h-4 ml-1" />;
  };

  // Render sparkline if data is provided
  const renderSparkline = () => {
    if (!sparklineData.length) return null;
    
    const max = Math.max(...sparklineData);
    const min = Math.min(...sparklineData);
    const range = max - min || 1;
    
    return (
      <div className="h-8 mt-2">
        <svg width="100%" height="100%" viewBox={`0 0 ${sparklineData.length} 50`} preserveAspectRatio="none">
          {sparklineData.map((value, index) => {
            const height = ((value - min) / range) * 40 + 10;
            const x = index;
            const y = 50 - height;
            const color = trendDirection === 'up' ? '#10B981' : trendDirection === 'down' ? '#EF4444' : '#3B82F6';
            
            return (
              <rect 
                key={index} 
                x={x} 
                y={y} 
                width="0.8" 
                height={height}
                fill={color}
                rx="1"
              />
            );
          })}
        </svg>
      </div>
    );
  };

  return (
    <Card className="p-6  text-white shadow-lg">
      <div className="flex justify-between items-start">
        <div className="space-y-2">
          <h3 className="text-gray-400 text-sm uppercase font-medium">{title}</h3>
          <div className="flex items-baseline">
            <h2 className="text-2xl font-bold">{loading ? '...' : value}</h2>
            {trend !== 0 && (
              <span className={`text-sm ml-2 flex items-center ${getTrendColor()}`}>
                {trend > 0 ? '+' : ''}{trend}% {getTrendIcon()}
              </span>
            )}
          </div>
        </div>
        {icon && <div className="rounded-full p-2 bg-gray-800">{icon}</div>}
      </div>
      
      <p className="text-gray-400 text-sm mt-1">{description}</p>
      
      {renderSparkline()}
      
      <div className="mt-2 text-xs text-gray-500">
        {timeframe}
      </div>
    </Card>
  );
};

// Main StatsCards component
export const StatsCards: React.FC = () => {
  const { dateRange } = useDashboardState();
  const [stats, setStats] = useState({
    newPhrases: { value: 0, trend: 0, sparkline: [] },
    reviewedPhrases: { value: 0, trend: 0, sparkline: [] },
    activeReviewers: { value: 0, trend: 0 },
    topReviewer: { name: '', count: 0, streak: 0 }
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchStats = async () => {
      setLoading(true);
      try {
        const response = await fetch('/api/dashboard/stats', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ dateRange }),
        });
        
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        setStats(data);
      } catch (error) {
        console.error('Error fetching dashboard stats:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchStats();
  }, [dateRange]);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
      <StatCard
        title="NEW PHRASES"
        value={stats.newPhrases.value}
        description="Phrases added in the last month"
        trend={stats.newPhrases.trend}
        trendDirection={stats.newPhrases.trend > 0 ? 'up' : stats.newPhrases.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<BookOpen className="text-blue-500 w-5 h-5" />}
        loading={loading}
        sparklineData={stats.newPhrases.sparkline}
      />
      
      <StatCard
        title="PHRASES REVIEWED"
        value={stats.reviewedPhrases.value}
        description="Total reviews in the last month"
        trend={stats.reviewedPhrases.trend}
        trendDirection={stats.reviewedPhrases.trend > 0 ? 'up' : stats.reviewedPhrases.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<Clock className="text-green-500 w-5 h-5" />}
        loading={loading}
        sparklineData={stats.reviewedPhrases.sparkline}
      />
      
      <StatCard
        title="ACTIVE REVIEWERS"
        value={stats.activeReviewers.value}
        description="Unique reviewers this month"
        trend={stats.activeReviewers.trend}
        trendDirection={stats.activeReviewers.trend > 0 ? 'up' : stats.activeReviewers.trend < 0 ? 'down' : 'neutral'}
        timeframe={`Last ${dateRange} days`}
        icon={<Users className="text-purple-500 w-5 h-5" />}
        loading={loading}
      />
      
      <StatCard
        title="TOP REVIEWER"
        value={stats.topReviewer.name || 'N/A'}
        description={`${stats.topReviewer.count} reviews (${stats.topReviewer.streak} day streak)`}
        timeframe={`Last ${dateRange} days`}
        icon={<Award className="text-yellow-500 w-5 h-5" />}
        loading={loading}
      />
    </div>
  );
};

export default StatsCards;

============================================================

FILE: .\features\dashboard\hooks\useDashboardState.ts
SIZE: 2.75 KB
LAST MODIFIED: 03/22/2025 23:07:41

// features/dashboard/hooks/useDashboardState.ts
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Reviewer } from '@/types/types';

export const useDashboardState = () => {
  // Tab and Modal States
  const [activeTab, setActiveTab] = useState<string>('phrases');
  const [showWordCreatorModal, setShowWordCreatorModal] = useState<boolean>(false);
  const [showReviewModal, setShowReviewModal] = useState<boolean>(false);
  const [showFilterModal, setShowFilterModal] = useState<boolean>(false);
  const [showExportModal, setShowExportModal] = useState<boolean>(false);
  
  // Data States
  const [selectedPhraseId, setSelectedPhraseId] = useState<number | null>(null); 
  const [newIds, setNewIds] = useState<number[]>([]);
  const [dateRange, setDateRange] = useState<number>(30);
  const [currentReviewer, setCurrentReviewer] = useState<Reviewer | null>(null);
  const [isExporting, setIsExporting] = useState(false);
  
  // Loading States
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Initialize current reviewer from localStorage
  useEffect(() => {
    const savedReviewer = localStorage.getItem('currentReviewer');
    if (savedReviewer) {
      try {
        setCurrentReviewer(JSON.parse(savedReviewer));
      } catch (e) {
        console.error("Error parsing saved reviewer:", e);
        localStorage.removeItem('currentReviewer');
      }
    }
    
    setIsLoading(false);
  }, []);

  // Function to update date range
  const updateDateRange = useCallback((days: number) => {
    setDateRange(days);
  }, []);
  
  // Login/Logout handlers
  const handleLoginSuccess = useCallback((reviewer: Reviewer) => {
    setCurrentReviewer(reviewer);
    localStorage.setItem('currentReviewer', JSON.stringify(reviewer));
  }, []);
  
  const handleLogout = useCallback(() => {
    setCurrentReviewer(null);
    localStorage.removeItem('currentReviewer');
  }, []);

  // Word Creator handlers
  const handleWordAdded = useCallback((id: number) => {
    setNewIds(prev => [...prev, id]);
  }, []);

  return {
    // Tab and Modal States
    activeTab, 
    setActiveTab,
    showWordCreatorModal, 
    setShowWordCreatorModal,
    showReviewModal, 
    setShowReviewModal,
    showFilterModal, 
    setShowFilterModal,
    showExportModal, 
    setShowExportModal,
    
    // Data States
    selectedPhraseId,
    setSelectedPhraseId,
    newIds, 
    setNewIds,
    dateRange,
    updateDateRange,
    currentReviewer,
    setCurrentReviewer,
    isExporting,
    setIsExporting,
    
    // Loading States
    isLoading,
    error,
    
    // Handlers
    handleLoginSuccess,
    handleLogout,
    handleWordAdded
  };
};

export default useDashboardState;

============================================================

FILE: .\features\dashboard\styles\dashboard.css
SIZE: 1.53 KB
LAST MODIFIED: 03/06/2025 22:07:22

@keyframes flash {
  0%, 100% {
    background-color: transparent;
  }
  50% {
    background-color: var(--accent);
  }
}

.animate-flash {
  animation: flash 1.5s ease-in-out;
}

/* Table row hover effect */
.table-row-hover {
  transition: background-color 0.15s ease;
}

.table-row-hover:hover {
  background-color: var(--muted);
}

/* Ensure top margin for pie labels */
.recharts-pie-label-text {
  margin-top: 5px; /* Fix for cut-off text */
}

/* Chart hover effects */
.recharts-wrapper {
  margin-top: 5px;
}

/* Chart style updates */
.recharts-bar-rectangle:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

.recharts-pie-sector:hover {
  filter: brightness(1.2);
  cursor: pointer;
}

/* Custom grayscale palette for charts */
.chart-gray-100 {
  fill: #f5f5f5;
}

.chart-gray-200 {
  fill: #e0e0e0;
}

.chart-gray-300 {
  fill: #cccccc;
}

.chart-gray-400 {
  fill: #bbbbbb;
}

.chart-gray-500 {
  fill: #999999;
}

.chart-gray-600 {
  fill: #777777;
}

.chart-gray-700 {
  fill: #555555;
}

.chart-gray-800 {
  fill: #333333;
}

/* Tooltip styling */
.custom-tooltip {
  background-color: var(--background);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  padding: 0.5rem;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Login button styling */
.login-button {
  background-color: white;
  color: black;
  border: 1px solid var(--border);
}

.login-button:hover {
  background-color: #f0f0f0;
}

============================================================

FILE: .\features\data\hooks\usePhraseMetadata.ts
SIZE: 2.39 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';

interface PhraseMetadata {
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
  error: string | null;
}

interface CategoryRecord {
  name: string;
}

interface PartOfSpeechRecord {
  part_of_speech: string;
}

export const usePhraseMetadata = (): PhraseMetadata => {
  const [categories, setCategories] = useState<string[]>([]);
  const [difficulties, setDifficulties] = useState<string[]>([]);
  const [partsOfSpeech, setPartsOfSpeech] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchMetadata = async () => {
      setLoading(true);
      setError(null);
      
      try {
        // Fetch categories
        const { data: categoryData, error: categoryError } = await supabase
          .from('categories')
          .select('name')
          .order('name');

        if (categoryError) throw categoryError;

        // Fetch parts of speech from phrases
        const { data: posData, error: posError } = await supabase
          .from('phrases')
          .select('part_of_speech')
          .not('part_of_speech', 'is', null);

        if (posError) throw posError;

        // Process categories
        const uniqueCategories = Array.from(
          new Set((categoryData as CategoryRecord[]).map(record => record.name))
        );

        // Process parts of speech
        const uniquePartsOfSpeech = Array.from(
          new Set((posData as PartOfSpeechRecord[])
            .map(record => record.part_of_speech)
            .filter(Boolean))
        ).sort();

        // Set predefined difficulties
        const difficultyLevels = ['Easy', 'Medium', 'Hard'];

        setCategories(uniqueCategories);
        setDifficulties(difficultyLevels);
        setPartsOfSpeech(uniquePartsOfSpeech);
      } catch (err) {
        console.error('Error fetching metadata:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch metadata');
      } finally {
        setLoading(false);
      }
    };

    fetchMetadata();
  }, []);

  return {
    categories,
    difficulties,
    partsOfSpeech,
    loading,
    error
  };
};

export default usePhraseMetadata;


============================================================

FILE: .\features\data\hooks\usePhrases.ts
SIZE: 6.12 KB
LAST MODIFIED: 03/17/2025 21:29:25

// hooks/usePhrases.ts

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase'
import type { Phrase, PaginationState, SortConfig, Filters } from '@/types/types';

export const usePhrases = () => {
  const [phrases, setPhrases] = useState<Phrase[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    rowsPerPage: 10,  // Default to 10 rows per page
    totalPages: 1,
    totalItems: 0
  });

  const [sortConfig, setSortConfig] = useState<SortConfig>({
    key: '',
    direction: 'asc'
  });

  const [filters, setFilters] = useState<Filters>({
    searchTerm: '',
    category: '',
    difficulty: '',
    subcategory: '',
    part_of_speech: ''
  });

  const fetchPhrases = useCallback(async () => {
    try {
      setLoading(true);
      let query = supabase
      .from('phrases')
      .select(`
        *,
        categories:category_id(id, name),
        subcategories:subcategory_id(id, name),
        phrase_tags!inner(
          tags(id, tag)
        )
      `, { count: 'exact' });
      // Apply filters
      if (filters.category) {
        // First get the category id
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          query = query.eq('category_id', categoryData.id);
        }
      }

      if (filters.difficulty) {
        query = query.eq('difficulty', filters.difficulty);
      }

      if (filters.subcategory) {
        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('id')
          .eq('name', filters.subcategory)
          .single();

        if (subcategoryData) {
          query = query.eq('subcategory_id', subcategoryData.id);
        }
      }

      if (filters.part_of_speech) {
        query = query.eq('part_of_speech', filters.part_of_speech);
      }

      if (filters.searchTerm) {
        query = query.or(`phrase.ilike.%${filters.searchTerm}%`);
      }

      // Apply sorting
      if (sortConfig.key) {
        query = query.order(sortConfig.key, {
          ascending: sortConfig.direction === 'asc',
          nullsFirst: false
        });
      } else {
        // Default sort
        query = query.order('id', { ascending: false });
      }

      // Apply pagination
      console.log('Pagination values:', {
        currentPage: pagination.currentPage,
        rowsPerPage: pagination.rowsPerPage,
        calculatedStart: (pagination.currentPage - 1) * pagination.rowsPerPage,
        calculatedEnd: (pagination.currentPage - 1) * pagination.rowsPerPage + pagination.rowsPerPage - 1
      });
      const start = (pagination.currentPage - 1) * pagination.rowsPerPage;
      const end = start + pagination.rowsPerPage - 1;
      query = query.range(start, end);

      const { data, error: supabaseError, count } = await query as SupabaseQueryResponse<PhraseWithRelations>;

    if (supabaseError) throw supabaseError;

      // Transform the data
      const transformedData = data?.map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      setPhrases(transformedData || []);
      
      if (count !== null) {
        const totalPages = Math.ceil(count / pagination.rowsPerPage);
        setPagination(prev => ({
          ...prev,
          totalItems: count,
          totalPages: totalPages,
          // Ensure currentPage doesn't exceed total pages
          currentPage: Math.min(prev.currentPage, totalPages || 1)
        }));
      }
  
      setPhrases(transformedData || []);
    } catch (err) {
      // ... Error handling ...
    } finally {
      setLoading(false);
    }
  }, [filters, sortConfig, pagination.currentPage, pagination.rowsPerPage]);

  // Fetch categories for the filter
  const fetchCategories = async () => {
    try {
      const { data, error } = await supabase
        .from('categories')
        .select('name')
        .order('name');
        
      if (error) {
        console.error('Supabase error fetching categories:', error);
        return [];
      }
      
      return data.map(category => category.name);
    } catch (error) {
      console.error('Error fetching categories:', error);
      return [];
    }
  };

  const handleFilterChange = (name: string, value: string) => {
    setFilters(prev => ({ ...prev, [name]: value }));
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const resetFilters = () => {
    setFilters({
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    });
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const handleSort = (key: keyof Phrase) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };

  const handlePageChange = (page: number) => {
    setPagination(prev => ({
      ...prev,
      currentPage: page
    }));
  };

  const handleRowsPerPageChange = (rowsPerPage: number) => {
    setPagination(prev => ({
      ...prev,
      rowsPerPage,
      currentPage: 1,  // Reset to page 1 when changing rows per page
      totalPages: Math.ceil((prev.totalItems || 0) / rowsPerPage)
    }));
  };

  useEffect(() => {
    fetchPhrases();
  }, [fetchPhrases, pagination.currentPage, pagination.rowsPerPage, filters, sortConfig]);

  return {
    phrases,
    loading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    resetFilters,
    fetchCategories,
    fetchPhrases,
    setError
  };
};

============================================================

FILE: .\features\data\hooks\useReviewers.ts
SIZE: 0.9 KB
LAST MODIFIED: 03/22/2025 22:17:43

// hooks/useReviewers.ts
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/services/supabase';


export const useReviewers = () => {
  const [reviewers, setReviewers] = useState<Reviewer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchReviewers = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });

      if (error) throw error;
      setReviewers(data || []);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to fetch reviewers'));
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchReviewers();
  }, []);

  return { reviewers, loading, error, refetch: fetchReviewers };
};


============================================================

FILE: .\features\data\hooks\useStats.ts
SIZE: 2.84 KB
LAST MODIFIED: 03/05/2025 15:03:18

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/services/supabase';
import type { Stats, Phrase } from '@/types/types';

interface UseStatsReturn {
  stats: Stats;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const useStats = (): UseStatsReturn => {
  const [stats, setStats] = useState<Stats>({
    total: 0,
    uniqueCategories: 0,
    difficultyBreakdown: {
      easy: 0,
      medium: 0,
      hard: 0,
    },
  });

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const calculateStats = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const { data: phrases, error: fetchError, count } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id (name)
        `, { count: 'exact' });

      if (fetchError) throw fetchError;
      if (!phrases) throw new Error('No data received');

      // Calculate unique categories
      const uniqueCategories = new Set(phrases.map((p) => p.categories?.name)).size;

      // Map difficulty numbers to labels
      const difficultyLabels = {
        1: 'easy',
        2: 'medium',
        3: 'hard',
      };

      // Calculate difficulty breakdown
      const difficultyCount = phrases.reduce((acc: Record<string, number>, phrase) => {
        const difficultyLabel = difficultyLabels[phrase.difficulty] || 'unknown';
        acc[difficultyLabel] = (acc[difficultyLabel] || 0) + 1;
        return acc;
      }, {});

      const total = count || phrases.length;

      // Calculate percentages
      let easy = Math.round(((difficultyCount['easy'] || 0) / total) * 100);
      let medium = Math.round(((difficultyCount['medium'] || 0) / total) * 100);
      let hard = Math.round(((difficultyCount['hard'] || 0) / total) * 100);

      // Adjust for rounding errors
      const sum = easy + medium + hard;
      if (sum !== 100) {
        const diff = 100 - sum;
        if (easy >= medium && easy >= hard) {
          easy += diff;
        } else if (medium >= easy && medium >= hard) {
          medium += diff;
        } else {
          hard += diff;
        }
      }

      setStats({
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard,
        },
      });
    } catch (err) {
      console.error('Error calculating stats:', err);
      setError(err instanceof Error ? err.message : 'Failed to calculate stats');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    calculateStats();
  }, [calculateStats]);

  return {
    stats,
    loading,
    error,
    refetch: calculateStats,
  };
};

export default useStats;


============================================================

FILE: .\features\filters\FilterModal.tsx
SIZE: 5.5 KB
LAST MODIFIED: 03/05/2025 16:59:06

// components/common/FilterModal.tsx
import React from 'react';
import { X, Search } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface FilterModalProps {
  isOpen: boolean;
  onClose: () => void;
  filters: {
    searchTerm: string;
    category: string;
    difficulty: string;
    subcategory: string;
    part_of_speech: string;
  };
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  subcategories: string[];
}

const FilterModal: React.FC<FilterModalProps> = ({
  isOpen,
  onClose,
  filters,
  onChange,
  onReset,
  categories,
  difficulties,
  partsOfSpeech,
  subcategories = []
}) => {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Filter Phrases</DialogTitle>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          {/* Search */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Search</label>
            <div className="relative">
              <Search className="absolute left-3 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                value={filters.searchTerm}
                onChange={(e) => onChange('searchTerm', e.target.value)}
                placeholder="Search phrases or tags..."
                className="pl-9"
              />
            </div>
          </div>
          
          {/* Category */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Category</label>
            <Select
              value={filters.category}
              onValueChange={(value) => onChange('category', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Categories</SelectItem>
                {categories.map(category => (
                  <SelectItem key={category} value={category}>
                    {category}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Subcategory */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Subcategory</label>
            <Select
              value={filters.subcategory}
              onValueChange={(value) => onChange('subcategory', value)}
              disabled={!filters.category}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Subcategories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Subcategories</SelectItem>
                {subcategories.map(subcategory => (
                  <SelectItem key={subcategory} value={subcategory}>
                    {subcategory}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Difficulty */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Difficulty</label>
            <Select
              value={filters.difficulty}
              onValueChange={(value) => onChange('difficulty', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Difficulties" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Difficulties</SelectItem>
                {difficulties.map(difficulty => (
                  <SelectItem key={difficulty} value={difficulty}>
                    {difficulty}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {/* Part of Speech */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Part of Speech</label>
            <Select
              value={filters.part_of_speech}
              onValueChange={(value) => onChange('part_of_speech', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="All Parts of Speech" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">All Parts of Speech</SelectItem>
                {partsOfSpeech.map(pos => (
                  <SelectItem key={pos} value={pos}>
                    {pos}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
        
        <DialogFooter className="flex justify-between">
          <Button 
            variant="outline" 
            onClick={onReset}
            className="flex items-center gap-1"
          >
            <X className="h-4 w-4" />
            Reset Filters
          </Button>
          <Button type="submit" onClick={onClose}>Apply Filters</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default FilterModal;

============================================================

FILE: .\features\import\BulkImportForm.tsx
SIZE: 3.89 KB
LAST MODIFIED: 03/06/2025 22:11:26

import React, { useState, useRef } from 'react';
import { Upload } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import type { BulkImportFormProps, NewPhrase } from '@/types/types';
import { supabase } from '@/lib/services/supabase';
import Papa from 'papaparse';

const BulkImportForm: React.FC<BulkImportFormProps> = ({
  onSuccess,
  onError
}) => {
  const [bulkImportText, setBulkImportText] = useState('');
  const [loading, setLoading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Existing handleBulkImport code and other processing functions

  const handleFileSelect = async (file: File) => {
    try {
      const text = await file.text();
      setBulkImportText(text);
    } catch (err) {
      console.error('File reading error:', err);
      onError('Failed to read file');
    }
  };

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(e.type === 'dragenter' || e.type === 'dragover');
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    const file = e.dataTransfer.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Bulk Import</CardTitle>
      </CardHeader>
      <CardContent>
        <div
          className={`relative border-2 border-dashed rounded-lg p-6 mb-4
            ${dragActive 
              ? 'border-blue-500 bg-blue-500/10' 
              : 'border-gray-600'
            }`}
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          <input
            ref={fileInputRef}
            type="file"
            onChange={handleFileInput}
            accept=".csv"
            className="hidden"
          />
          
          <div className="text-center">
            <Upload className="mx-auto h-12 w-12 text-gray-400" />
            <p className="mt-2 text-sm text-gray-400">
              Drag and drop a CSV file, or{' '}
              <button
                type="button"
                onClick={() => fileInputRef.current?.click()}
                className="text-blue-500 hover:text-blue-400"
              >
                browse
              </button>
            </p>
          </div>
        </div>

        <textarea
          value={bulkImportText}
          onChange={(e) => setBulkImportText(e.target.value)}
          className="w-full h-32 p-2 mb-4 border rounded bg-background focus:ring-2 focus:ring-blue-500"
          placeholder="phrase,category,difficulty,subcategory,tags,hint,part_of_speech"
        />

        <p className="text-sm text-muted-foreground mb-4">
          Format: phrase,category,difficulty,subcategory,tags,hint,part_of_speech
        </p>

        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => setBulkImportText('')}
            disabled={loading || !bulkImportText.trim()}
          >
            Clear
          </Button>
          <Button
            onClick={() => handleBulkImport(bulkImportText)}
            disabled={loading || !bulkImportText.trim()}
            className="bg-white text-black hover:bg-gray-100"
          >
            {loading ? 'Importing...' : 'Import Phrases'}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default BulkImportForm;

============================================================

FILE: .\features\phrases\ReviewModal.tsx
SIZE: 22.43 KB
LAST MODIFIED: 03/22/2025 22:17:43

'use client';

import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { ChevronLeft, ChevronRight, Flag } from 'lucide-react';
import { supabase } from '@/lib/services/supabase';
import { usePhrases } from '@/features/data/hooks/usePhrases';
import { generateTags, generateHint } from '@/lib/services/claudeService';


interface ReviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  reviewer: Reviewer;
  selectedPhraseId?: number | null;
}

interface EditedPhrase {
  id: number;
  category: string | undefined;
  hint?: string | undefined;
  difficulty?: number | undefined;
  tags?: string[] | undefined;
}

const ReviewModal: React.FC<ReviewModalProps> = ({
  isOpen,
  onClose,
  reviewer,
  selectedPhraseId 
}) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [selectedCategory, setSelectedCategory] = useState<string>('all');
  const [categories, setCategories] = useState<string[]>([]);
  const [isFlagged, setIsFlagged] = useState(false);
  const [isApproved, setIsApproved] = useState(false);
  const [isApproving, setIsApproving] = useState(false);
  const [isGeneratingTags, setIsGeneratingTags] = useState(false);
  const [isGeneratingHint, setIsGeneratingHint] = useState(false);
  const [streak, setStreak] = useState(0);
  const [showCelebration, setShowCelebration] = useState(false);
  const [editedPhrase, setEditedPhrase] = useState<EditedPhrase>({
    id: -1,
    category: undefined,
    hint: undefined,
    difficulty: undefined,
    tags: undefined
  });
  const [hasChanges, setHasChanges] = useState(false);
  
  const {
    phrases,
    loading: phrasesLoading,
    handleFilterChange,
    fetchCategories: fetchCategoriesFromHook,
    fetchPhrases
  } = usePhrases();

  // Fetch categories on load
  useEffect(() => {
    const loadCategories = async () => {
      const fetchedCategories = await fetchCategoriesFromHook();
      if (fetchedCategories) {
        setCategories(fetchedCategories);
      }
    };
    loadCategories();
  }, [fetchCategoriesFromHook]);

  // Reset current index when modal opens or filter changes
  useEffect(() => {
    if (isOpen) {
      setCurrentIndex(0);
      setIsFlagged(false);
      setHasChanges(false);
      
      // Get the reviewer's streak from local storage or set it to 0
      const savedStreak = localStorage.getItem(`reviewer-streak-${reviewer.id}`);
      if (savedStreak) {
        setStreak(parseInt(savedStreak));
      } else {
        setStreak(0);
      }
    }
  }, [isOpen, selectedCategory, reviewer.id]);

  useEffect(() => {
    if (isOpen && selectedPhraseId && phrases.length > 0) {
      const index = phrases.findIndex(p => p.id === selectedPhraseId);
      if (index !== -1) {
        setCurrentIndex(index);
      }
    }
  }, [isOpen, selectedPhraseId, phrases]);
  // Check if current phrase is flagged
  useEffect(() => {
    const checkFlagged = async () => {
      if (!phrases[currentIndex] || !reviewer) return;
      
      try {
        const { data, error } = await supabase
          .from('votes')
          .select('*')
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', false)
          .maybeSingle();
          
        setIsFlagged(!!data);
      } catch (err) {
        console.error('Error checking flag status:', err);
      }
    };
    
    checkFlagged();
  }, [phrases, currentIndex, reviewer]);

  // Check if phrase is already approved
  useEffect(() => {
    const checkApprovalStatus = async () => {
      if (!phrases[currentIndex] || !reviewer) return;
      
      try {
        const { data, error } = await supabase
          .from('votes')
          .select('*')
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', true)
          .maybeSingle();
          
        setIsApproved(!!data);
      } catch (err) {
        console.error('Error checking approval status:', err);
      }
    };
    
    checkApprovalStatus();
  }, [phrases, currentIndex, reviewer]);

  // Load current phrase data
  useEffect(() => {
    const loadPhraseData = async () => {
      if (!phrases[currentIndex]) return;
      
      const currentPhrase = phrases[currentIndex];
      
      if (currentPhrase) {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('name')
          .eq('id', currentPhrase.category_id)
          .single();

        // Get tags as array
        let tagsArray: string[] = [];
        if (currentPhrase.tags) {
          tagsArray = currentPhrase.tags.split(',').map(tag => tag.trim());
        }

        setEditedPhrase({
          id: currentPhrase.id,
          category: categoryData?.name || undefined,
          hint: currentPhrase.hint || undefined,
          difficulty: currentPhrase.difficulty || undefined,
          tags: tagsArray
        });
        
        setHasChanges(false);
      }
    };

    loadPhraseData();
  }, [phrases, currentIndex]);

  const handleCategorySelect = (category: string) => {
    setSelectedCategory(category);
    // If "all" is selected, pass empty string to filter function
    handleFilterChange('category', category === 'all' ? '' : category);
    setCurrentIndex(0);
  };

  const handleNext = () => {
    if (currentIndex < phrases.length - 1) {
      setCurrentIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentIndex(prev => prev - 1);
    }
  };

  // Increment and manage streak
  const incrementStreak = () => {
    const newStreak = streak + 1;
    setStreak(newStreak);
    localStorage.setItem(`reviewer-streak-${reviewer.id}`, newStreak.toString());
    
    // Check if we've hit a milestone (10)
    if (newStreak >= 10) {
      setShowCelebration(true);
      
      // Reset streak after celebration
      setTimeout(() => {
        setStreak(0);
        localStorage.setItem(`reviewer-streak-${reviewer.id}`, '0');
        setShowCelebration(false);
      }, 3000);
    }
    
    // Update reviewer streak in database
    supabase
      .from('reviewers')
      .update({
        current_streak: newStreak % 10, // Keep it within 0-9
        last_review_at: new Date().toISOString()
      })
      .eq('id', reviewer.id)
      .then(() => {})
      .catch(err => console.error('Error updating streak:', err));
  };

  const handleFlag = async () => {
    if (!reviewer || !phrases[currentIndex]) return;
    
    const newFlagState = !isFlagged;
    setIsFlagged(newFlagState);
    
    try {
      if (newFlagState) {
        const { error } = await supabase
          .from('votes')
          .insert({
            reviewer_id: reviewer.id,
            phrase_id: phrases[currentIndex].id,
            category: 'phrase',
            vote: false,
            created_at: new Date().toISOString()
          });
          
        if (error) {
          setIsFlagged(!newFlagState);
          throw error;
        }
      } else {
        const { error } = await supabase
          .from('votes')
          .delete()
          .eq('reviewer_id', reviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase')
          .eq('vote', false);
          
        if (error) {
          setIsFlagged(!newFlagState);
          throw error;
        }
      }
    } catch (err) {
      console.error('Error toggling flag:', err);
    }
  };

  const handleFieldChange = (field: keyof EditedPhrase, value: any) => {
    setEditedPhrase(prev => ({ ...prev, [field]: value }));
    setHasChanges(true);
  };

  const handleTagChange = (index: number, value: string) => {
    const newTags = [...(editedPhrase.tags || ['', '', ''])];
    while (newTags.length < 3) newTags.push('');
    
    newTags[index] = value.trim();
    handleFieldChange('tags', newTags);
  };

  const handleGenerateTags = async () => {
    if (!phrases[currentIndex]?.phrase) return;

    setIsGeneratingTags(true);
    try {
      const result = await generateTags(phrases[currentIndex].phrase);
      if (result.tags.length > 0) {
        const newTags = result.tags.slice(0, 3);
        while (newTags.length < 3) newTags.push('');
        handleFieldChange('tags', newTags);
      }
    } catch (error) {
      console.error('Error generating tags:', error);
    } finally {
      setIsGeneratingTags(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!phrases[currentIndex]?.phrase) return;
  
    setIsGeneratingHint(true);
    try {
      const result = await generateHint(phrases[currentIndex].phrase);
      if (result.hint) {
        handleFieldChange('hint', result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
    } finally {
      setIsGeneratingHint(false);
    }
  };

  const handleApprove = async () => {
    if (!reviewer || !phrases[currentIndex]) return;
    
    setIsApproving(true);
    
    try {
      // Save any changes first if needed
      if (hasChanges) {
        await handleSave();
      }
      
      // Add or update the approval vote
      const { error } = await supabase
        .from('votes')
        .upsert({
          reviewer_id: reviewer.id,
          phrase_id: phrases[currentIndex].id,
          category: 'phrase',
          vote: true,
          created_at: new Date().toISOString()
        });
        
      if (error) throw error;
      
      // Set as approved
      setIsApproved(true);
      
      // Increment streak
      incrementStreak();
      
      // Move to next phrase if not at the end
      if (currentIndex < phrases.length - 1) {
        setCurrentIndex(prev => prev + 1);
      }
    } catch (err) {
      console.error('Error approving phrase:', err);
    } finally {
      setIsApproving(false);
    }
  };
  
  // Original save function for changes only
  const handleSave = async () => {
    if (!editedPhrase.id || editedPhrase.id === -1) return;

    try {
      // Get category ID
      const { data: categoryData } = await supabase
        .from('categories')
        .select('id')
        .eq('name', editedPhrase.category)
        .single();
        
      if (!categoryData) throw new Error('Category not found');
      const categoryId = categoryData.id;
      
      // Update phrase
      const { error: phraseError } = await supabase
        .from('phrases')
        .update({
          hint: editedPhrase.hint,
          difficulty: editedPhrase.difficulty,
          category_id: categoryId,
          subcategory_id: null
        })
        .eq('id', editedPhrase.id);

      if (phraseError) throw phraseError;

      // Handle tags
      if (editedPhrase.tags) {
        const newTags = editedPhrase.tags.filter(Boolean);
        
        // Get existing tags
        const { data: existingTagsData } = await supabase
          .from('phrase_tags')
          .select('tags(id, tag)')
          .eq('phrase_id', editedPhrase.id);

        const existingTags = existingTagsData?.map((pt: any) => pt.tags.tag) || [];

        // Remove tags that are no longer present
        const tagsToRemove = existingTags.filter((tag: string) => !newTags.includes(tag));
        for (const tagToRemove of tagsToRemove) {
          const { data: tagData } = await supabase
            .from('tags')
            .select('id')
            .eq('tag', tagToRemove)
            .single();

          if (tagData) {
            await supabase
              .from('phrase_tags')
              .delete()
              .eq('phrase_id', editedPhrase.id)
              .eq('tag_id', tagData.id);
          }
        }

        // Add new tags
        for (const newTag of newTags) {
          if (!existingTags.includes(newTag)) {
            let tagId: number | undefined;
            const { data: existingTag } = await supabase
              .from('tags')
              .select('id')
              .eq('tag', newTag)
              .single();

            if (existingTag) {
              tagId = existingTag.id;
            } else {
              const { data: newTagData } = await supabase
                .from('tags')
                .insert({ tag: newTag })
                .select('id')
                .single();

              if (newTagData) tagId = newTagData.id;
            }

            if (tagId) {
              await supabase
                .from('phrase_tags')
                .insert({
                  phrase_id: editedPhrase.id,
                  tag_id: tagId
                });
            }
          }
        }
      }

      await fetchPhrases();
      setHasChanges(false);
    } catch (err) {
      console.error('Error saving changes:', err);
      throw err;
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-xl bg-black border border-neutral-800 max-h-[90vh] overflow-y-auto p-6 pt-10">
        <DialogTitle className="sr-only">Review Phrases</DialogTitle>
        <DialogDescription className="sr-only">Review and approve phrases for your collection</DialogDescription>
        
        <div className="flex justify-between items-center mb-5">
          <div>
            <h2 className="text-xl font-bold text-white">Phrase Review</h2>
            <p className="text-sm text-neutral-400">Reviewer: {reviewer.name} ({reviewer.total_reviews || 0} reviews)</p>
          </div>
          
          <Select value={selectedCategory} onValueChange={handleCategorySelect}>
            <SelectTrigger className="w-[180px] bg-transparent border-neutral-700 text-white">
              <SelectValue placeholder="All Categories" />
            </SelectTrigger>
            <SelectContent className="bg-black border border-neutral-700 text-white">
              <SelectItem value="all" className="hover:bg-neutral-800">All Categories</SelectItem>
              {categories.map(category => (
                <SelectItem 
                  key={category} 
                  value={category}
                  className="hover:bg-neutral-800"
                >{category}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        
        {/* Review Hot Streak */}
        <div className="mb-5 space-y-1">
          <div className="text-sm text-neutral-400">Review Hot Streak: {streak}</div>
          <div className="h-2 bg-neutral-800 rounded-full overflow-hidden">
            <div 
              className="h-full bg-gradient-to-r from-orange-500 to-red-500 transition-all"
              style={{ width: `${(streak % 10) * 10}%` }}
            ></div>
          </div>
        </div>
        
        {/* Celebration Overlay */}
        {showCelebration && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="text-center p-8 bg-black border-2 border-orange-500 rounded-lg">
              <div className="text-4xl mb-4">ðŸŽ‰ ðŸ”¥ ðŸŽ‰</div>
              <h3 className="text-2xl font-bold text-white mb-2">Hot Streak Complete!</h3>
              <p className="text-xl text-orange-400">You reviewed 10 phrases!</p>
            </div>
          </div>
        )}
        
        {phrasesLoading ? (
          <div className="flex items-center justify-center py-12">
            <div className="animate-spin h-8 w-8 border-t-2 border-blue-500 rounded-full"></div>
          </div>
        ) : phrases.length === 0 ? (
          <div className="text-center py-8">
            <p className="text-neutral-300 mb-4">No phrases available for review.</p>
            <Button 
              onClick={onClose}
              className="bg-neutral-100 text-black hover:bg-white"
            >
              Close
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Phrase Section */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Phrase</label>
                <Button
                  onClick={handleFlag}
                  variant="ghost"
                  size="sm"
                  className={`h-7 text-xs ${isFlagged ? 'text-red-500' : 'text-neutral-400 hover:text-white'}`}
                >
                  <Flag className="h-3.5 w-3.5 mr-1" />
                  Flag for Removal
                </Button>
              </div>
              <Input
                type="text"
                value={phrases[currentIndex]?.phrase || ''}
                readOnly
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0 rounded-md"
              />
            </div>
            
            {/* Difficulty */}
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Difficulty</label>
              <Select
                value={editedPhrase.difficulty?.toString() || '1'}
                onValueChange={(value) => handleFieldChange('difficulty', parseInt(value))}
              >
                <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                  <SelectValue placeholder="Select difficulty" />
                </SelectTrigger>
                <SelectContent className="bg-black border border-neutral-700 text-white">
                  <SelectItem value="1" className="hover:bg-neutral-800">Easy</SelectItem>
                  <SelectItem value="2" className="hover:bg-neutral-800">Medium</SelectItem>
                  <SelectItem value="3" className="hover:bg-neutral-800">Hard</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            {/* Category */}
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Category</label>
              <Select
                value={editedPhrase.category || ''}
                onValueChange={(value) => handleFieldChange('category', value)}
              >
                <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                  <SelectValue placeholder="Select category" />
                </SelectTrigger>
                <SelectContent className="bg-black border border-neutral-700 text-white">
                  {categories.map(category => (
                    <SelectItem 
                      key={category} 
                      value={category}
                      className="hover:bg-neutral-800"
                    >{category}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            {/* Tags */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Tags</label>
                <Button 
                  onClick={handleGenerateTags}
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs text-neutral-400 hover:text-white"
                  disabled={isGeneratingTags}
                >
                  {isGeneratingTags ? "..." : "ðŸ¤– Ask AI"}
                </Button>
              </div>
              <div className="grid grid-cols-3 gap-2">
                {Array.from({ length: 3 }).map((_, index) => (
                  <Input
                    key={`tag-${index}`}
                    type="text"
                    value={editedPhrase.tags?.[index] || ''}
                    onChange={(e) => handleTagChange(index, e.target.value)}
                    className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                    placeholder={`Tag ${index + 1}`}
                    maxLength={16}
                  />
                ))}
              </div>
            </div>
            
            {/* Hint */}
            <div>
              <div className="flex justify-between items-center mb-2">
                <label className="text-sm text-neutral-400">Hint</label>
                <Button 
                  onClick={handleGenerateHint}
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs text-neutral-400 hover:text-white"
                  disabled={isGeneratingHint}
                >
                  {isGeneratingHint ? "..." : "ðŸ¤– Ask AI"}
                </Button>
              </div>
              <Input
                type="text"
                value={editedPhrase.hint || ''}
                onChange={(e) => handleFieldChange('hint', e.target.value)}
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
              />
            </div>

            {/* Actions */}
            <div className="flex justify-between items-center pt-4 mt-4 border-t border-neutral-800">
                <div className="flex items-center gap-1 border border-neutral-700 rounded-md">
                  <Button
                    onClick={handlePrevious}
                    disabled={currentIndex === 0}
                    variant="ghost"
                    className="h-10 px-2 text-neutral-300 hover:bg-neutral-800 hover:text-white disabled:opacity-50 border-r border-neutral-700 rounded-r-none"
                  >
                    <ChevronLeft className="h-4 w-4" />
                  </Button>
                  <span className="px-3 text-neutral-400 text-sm">
                    {currentIndex + 1} / {phrases.length}
                  </span>
                  <Button
                    onClick={handleNext}
                    disabled={currentIndex === phrases.length - 1}
                    variant="ghost"
                    className="h-10 px-2 text-neutral-300 hover:bg-neutral-800 hover:text-white disabled:opacity-50 border-l border-neutral-700 rounded-l-none"
                  >
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                </div>
                
                <Button
                  onClick={handleApprove}
                  className={isApproved 
                    ? "bg-neutral-700 text-white hover:bg-neutral-600" 
                    : "bg-white text-black hover:bg-neutral-200"}
                  disabled={isApproving}
                >
                  {isApproving ? 'Approving...' : isApproved ? 'Approved' : 'Approve'}
                </Button>
            </div>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
};

export default ReviewModal;

============================================================

FILE: .\features\phrases\WordCreatorModal.tsx
SIZE: 19.2 KB
LAST MODIFIED: 03/22/2025 22:17:43

'use client';

import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Loader2 } from 'lucide-react';
import { supabase } from '@/lib/services/supabase';
import { generateTags, generateHint, generatePhrases, suggestCategory } from '@/lib/services/claudeService';


interface WordCreatorModalProps {
  isOpen: boolean;
  onClose: () => void;
  reviewer: Reviewer;
  onWordAdded?: () => void;
}

interface NewWord {
  phrase: string;
  category: string;
  difficulty: number;
  hint?: string;
  tags: string[];
}

const WordCreatorModal: React.FC<WordCreatorModalProps> = ({
  isOpen,
  onClose,
  reviewer,
  onWordAdded
}) => {
  const [categories, setCategories] = useState<string[]>([]);
  const [inspiration, setInspiration] = useState('');
  const [newWord, setNewWord] = useState<NewWord>({
    phrase: '',
    category: '',
    difficulty: 1,
    hint: '',
    tags: ['', '', '']
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingTags, setIsGeneratingTags] = useState(false);
  const [isGeneratingHint, setIsGeneratingHint] = useState(false);
  const [isGeneratingCategory, setIsGeneratingCategory] = useState(false);
  const [generatedWords, setGeneratedWords] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [wordGenerated, setWordGenerated] = useState(false);

  // Fetch categories on load
  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const { data, error } = await supabase
          .from('categories')
          .select('name')
          .order('name');
        
        if (error) throw error;
        if (data) setCategories(data.map(c => c.name));
      } catch (err) {
        console.error('Error fetching categories:', err);
        setError('Failed to load categories');
      }
    };

    fetchCategories();
  }, []);

  // Reset form when modal opens
  useEffect(() => {
    if (isOpen) {
      setInspiration('');
      setNewWord({
        phrase: '',
        category: '',
        difficulty: 1,
        hint: '',
        tags: ['', '', '']
      });
      setError(null);
      setSuccess(null);
      setWordGenerated(false);
      setGeneratedWords([]);
    }
  }, [isOpen]);

  const handleChange = (field: keyof NewWord, value: string | number | string[]) => {
    setNewWord(prev => ({ ...prev, [field]: value }));
    setError(null);
  };

  const handleTagChange = (index: number, value: string) => {
    const newTags = [...newWord.tags];
    newTags[index] = value.trim().replace(/\s+/g, '');
    handleChange('tags', newTags);
  };

  const handleGenerateTags = async () => {
    if (!newWord.phrase) {
      setError('Please generate a phrase first');
      return;
    }

    setIsGeneratingTags(true);
    try {
      const result = await generateTags(newWord.phrase);
      if (result.tags.length > 0) {
        const aiTags = result.tags.slice(0, 3);
        const newTags = [...aiTags, ...Array(3 - aiTags.length).fill('')];
        handleChange('tags', newTags);
      }
    } catch (error) {
      console.error('Error generating tags:', error);
      setError('Failed to generate tags');
    } finally {
      setIsGeneratingTags(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!newWord.phrase) {
      setError('Please generate a phrase first');
      return;
    }

    setIsGeneratingHint(true);
    try {
      const result = await generateHint(newWord.phrase);
      if (result.hint) {
        handleChange('hint', result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
      setError('Failed to generate hint');
    } finally {
      setIsGeneratingHint(false);
    }
  };

  const handleGenerateWords = async () => {
    if (!inspiration) {
      setError('Please enter some inspiration first');
      return;
    }

    setIsGenerating(true);
    setError(null);
    
    try {
      // Use the real Claude API to generate phrases
      const result = await generatePhrases(inspiration, 5);
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      if (result.phrases.length > 0) {
        setGeneratedWords(result.phrases);
        
        // Select the first generated word
        const firstPhrase = result.phrases[0];
        
        // Generate tags and hint for the selected phrase
        setIsGeneratingTags(true);
        setIsGeneratingHint(true);
        
        try {
          const [tagsResult, hintResult] = await Promise.all([
            generateTags(firstPhrase),
            generateHint(firstPhrase)
          ]);
          
          setNewWord(prev => ({
            ...prev,
            phrase: firstPhrase,
            hint: hintResult.hint || '',
            tags: tagsResult.tags.slice(0, 3)
          }));
        } catch (error) {
          console.error('Error generating tags/hint:', error);
          // Fallback values if API calls fail
          setNewWord(prev => ({
            ...prev,
            phrase: firstPhrase,
            hint: `Information about ${inspiration}`,
            tags: [`${inspiration}`, 'new', 'word']
          }));
        } finally {
          setIsGeneratingTags(false);
          setIsGeneratingHint(false);
        }
        
        setWordGenerated(true);
      } else {
        setError('No phrases were generated. Please try again with different inspiration.');
      }
    } catch (error) {
      console.error('Error generating phrases:', error);
      setError('Failed to generate phrases. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSelectWord = async (phrase: string) => {
    // Update the word with the selected phrase
    setNewWord(prev => ({
      ...prev,
      phrase
    }));
    
    // Set loading states
    setIsGeneratingTags(true);
    setIsGeneratingHint(true);
    setIsGeneratingCategory(true);
    
    try {
      // Generate tags, hint and category for the selected phrase using Claude
      const [tagsResult, hintResult, categoryResult] = await Promise.all([
        generateTags(phrase),
        generateHint(phrase),
        suggestCategory(phrase, categories)
      ]);
      
      setNewWord(prev => ({
        ...prev,
        hint: hintResult.hint || '',
        tags: tagsResult.tags.slice(0, 3),
        category: categoryResult.category || prev.category
      }));
    } catch (error) {
      console.error('Error generating phrase metadata:', error);
      // Fallback values if API calls fail
      const words = phrase.split(/\s+/);
      setNewWord(prev => ({
        ...prev,
        hint: `About ${words[0]?.toLowerCase() || phrase}`,
        tags: [
          words[0]?.toLowerCase() || 'general',
          phrase.length > 6 ? 'complex' : 'simple',
          words.length > 1 ? 'multi' : 'single'
        ]
      }));
    } finally {
      // Reset loading states
      setIsGeneratingTags(false);
      setIsGeneratingHint(false);
      setIsGeneratingCategory(false);
      
      // Set word as generated
      setWordGenerated(true);
    }
  };

  const handleSubmit = async () => {
    // Validate form
    if (!newWord.phrase) {
      setError('Please enter or generate a phrase');
      return;
    }
    if (!newWord.category) {
      setError('Please select a category');
      return;
    }

    setIsSubmitting(true);
    setError(null);
    
    try {
      // Get category ID
      const { data: categoryData } = await supabase
        .from('categories')
        .select('id')
        .eq('name', newWord.category)
        .single();
      
      if (!categoryData) {
        throw new Error('Category not found');
      }
      
      // Insert phrase
      const { data: phraseData, error: phraseError } = await supabase
        .from('phrases')
        .insert({
          phrase: newWord.phrase,
          category_id: categoryData.id,
          subcategory_id: null, // No subcategory
          difficulty: newWord.difficulty,
          hint: newWord.hint || null,
          created_by: reviewer.id,
          created_at: new Date().toISOString()
        })
        .select('id')
        .single();
      
      if (phraseError) throw phraseError;
      
      // Process tags
      const validTags = newWord.tags.filter(Boolean);
      for (const tag of validTags) {
        // Check if tag exists
        const { data: existingTag } = await supabase
          .from('tags')
          .select('id')
          .eq('tag', tag)
          .single();
          
        let tagId;
        if (existingTag) {
          tagId = existingTag.id;
        } else {
          // Create new tag
          const { data: newTag } = await supabase
            .from('tags')
            .insert({ tag })
            .select('id')
            .single();
            
          if (newTag) tagId = newTag.id;
        }
        
        // Link tag to phrase
        if (tagId && phraseData) {
          await supabase
            .from('phrase_tags')
            .insert({
              phrase_id: phraseData.id,
              tag_id: tagId
            });
        }
      }
      
      // Update reviewer stats
      await supabase
        .from('reviewers')
        .update({
          total_reviews: reviewer.total_reviews + 1,
          last_review_at: new Date().toISOString()
        })
        .eq('id', reviewer.id);
      
      setSuccess('Word added successfully');
      
      // Reset form but keep inspiration
      setTimeout(() => {
        setNewWord({
          phrase: '',
          category: '',
          difficulty: 1,
          hint: '',
          tags: ['', '', '']
        });
        setSuccess(null);
        setWordGenerated(false);
        
        if (onWordAdded) {
          onWordAdded();
        }
      }, 1500);
      
    } catch (err) {
      console.error('Error adding word:', err);
      setError('Failed to add word');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-xl bg-black border border-neutral-800 max-h-[90vh] overflow-y-auto p-6 pt-10">
        <DialogTitle className="sr-only">Word Creator</DialogTitle>
        <DialogDescription className="sr-only">Create new phrases for your collection</DialogDescription>
        
        <div className="mb-6">
          <h2 className="text-xl font-bold text-white">Word Creator</h2>
          <p className="text-sm text-neutral-400">Reviewer: {reviewer.name}</p>
        </div>
        
        {error && (
          <div className="mb-4 p-3 rounded bg-red-900/30 border border-red-700 text-red-300 text-sm">
            {error}
          </div>
        )}
        
        {success && (
          <div className="mb-4 p-3 rounded bg-green-900/30 border border-green-700 text-green-300 text-sm">
            {success}
          </div>
        )}
        
        <div className="space-y-4">
          {/* Inspiration Field */}
          <div>
            <label className="block text-sm text-neutral-400 mb-2">Provide Inspiration</label>
            <div className="flex gap-2">
              <Input
                value={inspiration}
                onChange={(e) => setInspiration(e.target.value)}
                placeholder="Enter a theme, topic, or concept"
                className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
              />
              <Button
                onClick={handleGenerateWords}
                disabled={isGenerating || !inspiration}
                className="bg-white text-black hover:bg-neutral-200 whitespace-nowrap"
              >
                {isGenerating ? (
                  <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Generating...</>
                ) : (
                  <>ðŸ¤– Generate Phrase</>
                )}
              </Button>
            </div>
          </div>
          
          {/* Generated Words List (shown after generation) */}
          {generatedWords.length > 0 && (
            <div>
              <label className="block text-sm text-neutral-400 mb-2">Select a Phrase</label>
              <div className="grid grid-cols-1 gap-2 mb-4">
                {generatedWords.map((phrase, index) => (
                  <Button
                    key={index}
                    variant="outline"
                    className={`justify-start text-left p-3 border-neutral-700 ${newWord.phrase === phrase ? 'bg-neutral-800 border-blue-500' : 'bg-transparent hover:bg-neutral-800'}`}
                    onClick={() => handleSelectWord(phrase)}
                  >
                    {phrase}
                  </Button>
                ))}
              </div>
            </div>
          )}
          
          {/* Phrase Field */}
          {wordGenerated && (
            <>
              <div>
                <label className="block text-sm text-neutral-400 mb-2">Phrase</label>
                <Input
                  value={newWord.phrase}
                  onChange={(e) => handleChange('phrase', e.target.value)}
                  className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              </div>
              
              {/* Difficulty */}
              <div>
                <label className="block text-sm text-neutral-400 mb-2">Difficulty</label>
                <Select
                  value={newWord.difficulty.toString()}
                  onValueChange={(value) => handleChange('difficulty', parseInt(value))}
                >
                  <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                    <SelectValue placeholder="Select difficulty" />
                  </SelectTrigger>
                  <SelectContent className="bg-black border border-neutral-700 text-white">
                    <SelectItem value="1" className="hover:bg-neutral-800">Easy</SelectItem>
                    <SelectItem value="2" className="hover:bg-neutral-800">Medium</SelectItem>
                    <SelectItem value="3" className="hover:bg-neutral-800">Hard</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              {/* Category */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Category</label>
                  {isGeneratingCategory && (
                    <span className="text-xs text-neutral-400">
                      <Loader2 className="inline h-3 w-3 animate-spin mr-1" /> 
                      AI selecting...
                    </span>
                  )}
                </div>
                <Select
                  value={newWord.category}
                  onValueChange={(value) => handleChange('category', value)}
                >
                  <SelectTrigger className="bg-transparent border-neutral-700 text-white">
                    <SelectValue placeholder="Select category" />
                  </SelectTrigger>
                  <SelectContent className="bg-black border border-neutral-700 text-white">
                    {categories.map(category => (
                      <SelectItem 
                        key={category} 
                        value={category}
                        className="hover:bg-neutral-800"
                      >{category}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {newWord.category && (
                  <p className="text-xs text-neutral-400 mt-1">
                    Category selected by AI based on the phrase content
                  </p>
                )}
              </div>
              
              {/* Tags */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Tags</label>
                  <Button 
                    onClick={handleGenerateTags}
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs text-neutral-400 hover:text-white"
                    disabled={isGeneratingTags || !newWord.phrase}
                  >
                    {isGeneratingTags ? "..." : "ðŸ¤– Ask AI"}
                  </Button>
                </div>
                <div className="grid grid-cols-3 gap-2">
                  {Array.from({ length: 3 }).map((_, index) => (
                    <Input
                      key={`tag-${index}`}
                      type="text"
                      value={newWord.tags[index] || ''}
                      onChange={(e) => handleTagChange(index, e.target.value)}
                      className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                      placeholder={`Tag ${index + 1}`}
                      maxLength={16}
                    />
                  ))}
                </div>
              </div>
              
              {/* Hint */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="text-sm text-neutral-400">Hint</label>
                  <Button 
                    onClick={handleGenerateHint}
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs text-neutral-400 hover:text-white"
                    disabled={isGeneratingHint || !newWord.phrase}
                  >
                    {isGeneratingHint ? "..." : "ðŸ¤– Ask AI"}
                  </Button>
                </div>
                <Input
                  type="text"
                  value={newWord.hint || ''}
                  onChange={(e) => handleChange('hint', e.target.value)}
                  className="bg-transparent border-neutral-700 text-white focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              </div>
              
              {/* Submit Button */}
              <div className="flex justify-end pt-4 mt-4 border-t border-neutral-800">
                <Button
                  onClick={handleSubmit}
                  disabled={isSubmitting || !newWord.phrase || !newWord.category}
                  className="bg-white text-black hover:bg-neutral-200"
                >
                  {isSubmitting ? (
                    <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Adding...</>
                  ) : (
                    'Add Word'
                  )}
                </Button>
              </div>
            </>
          )}
          
          {!wordGenerated && !isGenerating && generatedWords.length === 0 && (
            <div className="flex flex-col items-center justify-center py-12 text-neutral-400">
              <p className="mb-2">Enter some inspiration and click Generate</p>
              <p className="text-sm">Example: "medical terms", "sports activities", "cooking verbs"</p>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default WordCreatorModal;

============================================================

FILE: .\features\phrases\hooks\useDeletePhrase.ts
SIZE: 0.97 KB
LAST MODIFIED: 03/21/2025 09:26:33

// features/phrases/hooks/useDeletePhrase.ts
import { useState } from 'react';
import { supabase } from '@/lib/services/supabase';

export const useDeletePhrase = () => {
  const [isDeleting, setIsDeleting] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const mutate = async (id: number, options?: { onSuccess?: () => void }) => {
    setIsDeleting(true);
    setError(null);
    
    try {
      const { error: deleteError } = await supabase
        .from('phrases')
        .delete()
        .eq('id', id);
        
      if (deleteError) {
        throw deleteError;
      }
      
      if (options?.onSuccess) {
        options.onSuccess();
      }
    } catch (err) {
      console.error('Error deleting phrase:', err);
      setError(err instanceof Error ? err : new Error('An unknown error occurred'));
    } finally {
      setIsDeleting(false);
    }
  };
  
  return {
    mutate,
    isDeleting,
    error
  };
};

============================================================

FILE: .\features\phrases\phrasesTable\index.tsx
SIZE: 17.01 KB
LAST MODIFIED: 03/22/2025 22:43:03

import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import { Search, Columns, Pencil, Trash, ChevronLeft, ChevronRight, MoreHorizontal, X } from 'lucide-react';
import TagDisplay from '@/components/ui/tags';
import { DifficultyIndicator } from '@/components/ui/difficulty-indicator';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuCheckboxItem,
} from "@/components/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Check } from 'lucide-react';
import { cn } from '@/lib/utils';
import { supabase } from '@/lib/services/supabase';

interface PhrasesTableProps {
  phrases: any[];
  loading?: boolean;
  tableState: TableState;
  onTableStateChange: (updates: Partial<TableState>) => void;
  onEdit?: (id: number) => void;
  onDelete?: (id: number) => void;
  newIds?: number[];
  onShowFilters?: () => void;
}

export function PhrasesTable({
  phrases,
  loading = false,
  tableState,
  onTableStateChange,
  onEdit,
  onDelete,
  newIds = [],
  onShowFilters
}: PhrasesTableProps) {
  const [selectedRows, setSelectedRows] = useState<number[]>([]);
  const [searchValue, setSearchValue] = useState(tableState.filters.search || '');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  // Columns configuration for dropdown
  const columns = [
    { key: 'phrase', label: 'Phrase' },
    { key: 'category', label: 'Category' },
    { key: 'hint', label: 'Hint' }, // Moved hint to be after category
    { key: 'tags', label: 'Tags' },
    { key: 'difficulty', label: 'Difficulty' },
    { key: 'reviewed', label: 'Reviewed' }
  ];

  // Current visible columns
  const [hiddenColumns, setHiddenColumns] = useState<string[]>([]);

  // Helper function to get difficulty bar
  const getDifficultyBar = (difficulty: number) => {
    return <DifficultyIndicator difficulty={difficulty} />;
  };

  // Handle search input changes
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchValue(e.target.value);
  };

  // Global search across the entire database - Only search phrase column
  const performGlobalSearch = async () => {
    if (!searchValue.trim()) {
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: ''
        }
      });
      return;
    }

    setIsSearching(true);
    try {
      const searchTerm = searchValue.toLowerCase().trim();
      
      // Search only the phrase column
      const { data, error } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(name),
          subcategories:subcategory_id(name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `)
        .ilike('phrase', `%${searchTerm}%`); // Only search in phrase column

      if (error) throw error;

      const transformedData = (data || []).map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      // Update search results and pagination
      setSearchResults(transformedData);
      
      // Update filter state
      onTableStateChange({
        filters: {
          ...tableState.filters,
          search: searchValue
        },
        pagination: {
          ...tableState.pagination,
          currentPage: 1,
          totalItems: transformedData.length,
          totalPages: Math.ceil(transformedData.length / tableState.pagination.rowsPerPage)
        }
      });
    } catch (err) {
      console.error('Error searching phrases:', err);
    } finally {
      setIsSearching(false);
    }
  };

  // Handle enter key
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      performGlobalSearch();
    }
  };

  // Clear search
  const clearSearch = () => {
    setSearchValue('');
    setSearchResults([]);
    onTableStateChange({
      filters: {
        ...tableState.filters,
        search: ''
      }
    });
  };

  const handleRowsPerPageChange = (value: string) => {
    const newRowsPerPage = parseInt(value, 10);
    
    // Call the parent component's handler
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        rowsPerPage: newRowsPerPage,
        currentPage: 1  // Reset to page 1 when changing rows per page
      }
    });
  };

  const handlePageChange = (newPage: number) => {
    onTableStateChange({
      pagination: {
        ...tableState.pagination,
        currentPage: newPage
      }
    });
  };

  const handleSort = (key: string) => {
    onTableStateChange({
      sortConfig: {
        key,
        direction: 
          tableState.sortConfig.key === key && 
          tableState.sortConfig.direction === 'asc' ? 'desc' : 'asc'
      }
    });
  };

  const toggleSelectAll = () => {
    if (selectedRows.length === phrases.length) {
      setSelectedRows([]);
    } else {
      setSelectedRows(phrases.map(phrase => phrase.id));
    }
  };

  const toggleRowSelection = (id: number) => {
    if (selectedRows.includes(id)) {
      setSelectedRows(prev => prev.filter(rowId => rowId !== id));
    } else {
      setSelectedRows(prev => [...prev, id]);
    }
  };

  const handleBulkDelete = async () => {
    if (selectedRows.length > 0 && window.confirm(`Are you sure you want to delete ${selectedRows.length} phrases?`)) {
      for (const id of selectedRows) {
        await onDelete?.(id);
      }
      setSelectedRows([]);
    }
  };



  // Determine which data to show
  const displayData = searchValue && searchResults.length > 0 ? searchResults : phrases;


  return (
    <div className="space-y-2">
      {/* Top toolbar with pagination and search */}
      <div className="flex flex-wrap items-center justify-between pb-4">
        <div className="flex items-center gap-4">
          {/* Rows per page dropdown */}
          <Select
  value={tableState.pagination.rowsPerPage.toString()}
  onValueChange={handleRowsPerPageChange}
>
  <SelectTrigger className="w-[120px]">
    <SelectValue placeholder={`${tableState.pagination.rowsPerPage} per page`} />
  </SelectTrigger>
  <SelectContent>
    {[10, 25, 50, 100].map(value => (  // Removed 20 from here
      <SelectItem key={value} value={value.toString()}>
        {value} per page
      </SelectItem>
    ))}
  </SelectContent>
</Select>
          
          {/* Page info */}
          <span className="text-sm text-muted-foreground">
            {tableState.pagination.totalPages > 0
              ? `Page ${tableState.pagination.currentPage} of ${tableState.pagination.totalPages}`
              : 'No results'}
          </span>
        </div>

        <div className="flex items-center gap-2">
          {/* Search input */}
          <div className="relative w-full md:w-64">
            <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
              <Search className="h-4 w-4 text-muted-foreground" />
            </div>
            <Input
              placeholder="Search phrases..."
              value={searchValue}
              onChange={handleSearchChange}
              onKeyDown={handleKeyDown}
              onBlur={performGlobalSearch}
              className="pl-10 pr-10"
            />
            {searchValue && (
              <button
                onClick={clearSearch}
                className="absolute inset-y-0 right-0 flex items-center pr-3 text-muted-foreground hover:text-foreground"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
          
          {/* Column visibility */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-9">
                <Columns className="mr-2 h-4 w-4" />
                Columns
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {columns.map((column) => (
                <DropdownMenuCheckboxItem
                  key={column.key}
                  checked={!hiddenColumns.includes(column.key)}
                  onCheckedChange={(checked) => {
                    setHiddenColumns(prev => 
                      checked 
                        ? prev.filter(key => key !== column.key)
                        : [...prev, column.key]
                    );
                  }}
                >
                  {column.label}
                </DropdownMenuCheckboxItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
          
          {/* Pagination buttons */}
          <Button
  variant="outline"
  size="sm"
  onClick={() => handlePageChange(tableState.pagination.currentPage - 1)}
  disabled={tableState.pagination.currentPage <= 1}
>
  <ChevronLeft className="h-4 w-4" />
</Button>
<Button
  variant="outline"
  size="sm"
  onClick={() => handlePageChange(tableState.pagination.currentPage + 1)}
  disabled={tableState.pagination.currentPage >= tableState.pagination.totalPages}
>
  <ChevronRight className="h-4 w-4" />
</Button>
        </div>
      </div>

      {/* Main table */}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              {/* Checkbox column */}
              <TableHead className="w-12">
                <Checkbox
                  checked={selectedRows.length > 0 && selectedRows.length === displayData.length}
                  indeterminate={selectedRows.length > 0 && selectedRows.length < displayData.length ? true : undefined}
  onCheckedChange={toggleSelectAll}
                />
              </TableHead>
              
              {/* Phrase column */}
              {!hiddenColumns.includes('phrase') && (
                <TableHead onClick={() => handleSort('phrase')} className="cursor-pointer">
                  Phrase
                </TableHead>
              )}
              
              {/* Category column */}
              {!hiddenColumns.includes('category') && (
                <TableHead onClick={() => handleSort('category')} className="cursor-pointer">
                  Category
                </TableHead>
              )}
              
              {/* Hint column - Moved here */}
              {!hiddenColumns.includes('hint') && (
                <TableHead onClick={() => handleSort('hint')} className="cursor-pointer">
                  Hint
                </TableHead>
              )}
              
              {/* Tags column */}
              {!hiddenColumns.includes('tags') && (
                <TableHead onClick={() => handleSort('tags')} className="cursor-pointer">
                  Tags
                </TableHead>
              )}
              
              {/* Difficulty column */}
              {!hiddenColumns.includes('difficulty') && (
                <TableHead onClick={() => handleSort('difficulty')} className="cursor-pointer">
                  Difficulty
                </TableHead>
              )}
              
              {/* Reviewed column */}
              {!hiddenColumns.includes('reviewed') && (
                <TableHead>Reviewed</TableHead>
              )}
              
              {/* Actions column */}
              <TableHead className="w-[80px]">
                {selectedRows.length > 0 ? (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={handleBulkDelete}
                    className="h-8"
                  >
                    <Trash className="h-4 w-4 mr-2" />
                    Delete
                  </Button>
                ) : null}
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading || isSearching ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  {isSearching ? 'Searching...' : 'Loading...'}
                </TableCell>
              </TableRow>
            ) : displayData.length === 0 ? (
              <TableRow>
                <TableCell colSpan={8} className="h-24 text-center">
                  No phrases found.
                </TableCell>
              </TableRow>
            ) : (
              displayData.map((phrase) => (
                <TableRow 
                  key={phrase.id}
                  className={cn(
                    selectedRows.includes(phrase.id) && "bg-muted",
                    newIds.includes(phrase.id) && "animate-flash"
                  )}
                >
                  {/* Checkbox */}
                  <TableCell className="w-12">
                    <Checkbox
                      checked={selectedRows.includes(phrase.id)}
                      onCheckedChange={() => toggleRowSelection(phrase.id)}
                    />
                  </TableCell>
                  
                  {/* Phrase */}
                  {!hiddenColumns.includes('phrase') && (
                    <TableCell className="font-medium">{phrase.phrase}</TableCell>
                  )}
                  
                  {/* Category */}
                  {!hiddenColumns.includes('category') && (
                    <TableCell>{phrase.category}</TableCell>
                  )}
                  
                  {/* Hint - Moved here */}
                  {!hiddenColumns.includes('hint') && (
                    <TableCell>{phrase.hint || '-'}</TableCell>
                  )}
                  
                  {/* Tags */}
                  {!hiddenColumns.includes('tags') && (
                    <TableCell>
                      <TagDisplay tags={phrase.tags || ''} />
                    </TableCell>
                  )}
                  
                  {/* Difficulty - Bar Style */}
                  {!hiddenColumns.includes('difficulty') && (
                    <TableCell>
                      {getDifficultyBar(phrase.difficulty)}
                    </TableCell>
                  )}
                  
                  {/* Reviewed Status */}
                  {!hiddenColumns.includes('reviewed') && (
                    <TableCell>
                      <div className="flex justify-center">
                        {phrase.reviewed ? (
                          <Check className="h-5 w-5 text-green-500" />
                        ) : (
                          <Check className="h-5 w-5 text-gray-300" />
                        )}
                      </div>
                    </TableCell>
                  )}
                  
                  {/* Actions */}
                  <TableCell>
                    <div className="flex justify-end">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" className="h-8 w-8 p-0">
                            <span className="sr-only">Open menu</span>
                            <MoreHorizontal className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuLabel>Actions</DropdownMenuLabel>
                          <DropdownMenuItem onClick={() => onEdit?.(phrase.id)}>
                            <Pencil className="h-4 w-4 mr-2" />
                            Edit
                          </DropdownMenuItem>
                          <DropdownMenuSeparator />
                          <DropdownMenuItem 
                            onClick={() => {
                              if (window.confirm('Are you sure you want to delete this phrase?')) {
                                onDelete?.(phrase.id);
                              }
                            }}
                            className="text-red-600"
                          >
                            <Trash className="h-4 w-4 mr-2" />
                            Delete
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}

============================================================

FILE: .\features\phrases\stores\filterContext.tsx
SIZE: 1.63 KB
LAST MODIFIED: 03/21/2025 09:15:13

// features/phrases/stores/filterContext.tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface FilterState {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
  page: number;
  pageSize: number;
  sortBy: string;
  sortDirection: 'asc' | 'desc';
}

interface FilterContextValue extends FilterState {
  setFilter: (key: string, value: string | number) => void;
  resetFilters: () => void;
}

const defaultState: FilterState = {
  searchTerm: '',
  category: '',
  difficulty: '',
  subcategory: '',
  part_of_speech: '',
  page: 1,
  pageSize: 10,
  sortBy: 'id',
  sortDirection: 'desc'
};

const FilterContext = createContext<FilterContextValue | undefined>(undefined);

export function FilterProvider({ children }: { children: ReactNode }) {
  const [filters, setFilters] = useState<FilterState>(defaultState);

  const setFilter = (key: string, value: string | number) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
      // Reset to page 1 when changing filters
      ...(key !== 'page' ? { page: 1 } : {})
    }));
  };

  const resetFilters = () => {
    setFilters(defaultState);
  };

  return (
    <FilterContext.Provider
      value={{
        ...filters,
        setFilter,
        resetFilters
      }}
    >
      {children}
    </FilterContext.Provider>
  );
}

export function useFilter() {
  const context = useContext(FilterContext);
  if (context === undefined) {
    throw new Error('useFilter must be used within a FilterProvider');
  }
  return context;
}

============================================================

FILE: .\lib\utils.ts
SIZE: 0.16 KB
LAST MODIFIED: 03/04/2025 21:05:08

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


============================================================

FILE: .\lib\services\claudeService.ts
SIZE: 5.79 KB
LAST MODIFIED: 03/04/2025 11:02:57

'use client';

export interface GenerateTagsResponse {
  tags: string[];
  error?: string;
}

export interface GenerateHintResponse {
  hint: string;
  error?: string;
}

export interface GeneratePhrasesResponse {
  phrases: string[];
  error?: string;
}

export interface SuggestCategoryResponse {
  category: string;
  error?: string;
}

const makeClaudeRequest = async (messages: Array<{ role: string; content: string }>) => {
  const response = await fetch('/api/claude', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ messages })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('API error response:', errorText);
    throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
  }

  return await response.json();
};

export const generateTags = async (phrase: string): Promise<GenerateTagsResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate exactly 3 descriptive tags for this catch phrase: "${phrase}".
                Rules for tags:
                1. Must be single words, no spaces or hyphens
                2. All lowercase
                3. Maximum 15 characters per tag
                4. No special characters or numbers
                5. No generic words like "fun" or "game"
                6. Focus on theme, subject matter, or skill required
                7. Avoid duplicate meaning tags
                
                Return only the 3 tags separated by commas, nothing else.
                Example format: strategy,teamwork,creativity`
    }]);

    const tags = data.content[0].text
      .split(',')
      .map((tag: string) => tag.trim())
      .filter((tag: string) => 
        tag.length <= 15 && 
        /^[a-z]+$/.test(tag) &&
        !['fun', 'game', 'play'].includes(tag)
      );

    if (tags.length !== 3) {
      throw new Error('Invalid tag generation result');
    }

    return { tags };
  } catch (error) {
    console.error('Error generating tags:', error);
    return {
      tags: [],
      error: error instanceof Error ? error.message : 'Failed to generate tags'
    };
  }
};

export const generateHint = async (phrase: string): Promise<GenerateHintResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Create a VERY SHORT helpful hint for the catch phrase: "${phrase}".
                Rules for hints:
                1. MUST BE 20 CHARACTERS OR LESS - THIS IS CRITICAL
                2. Don't reveal the exact answer
                3. Focus on context or category
                4. No direct synonyms
                5. Can be a clever riddle or wordplay
                6. Should help players think in right direction
                7. No explicit "This is..." or "Think about..." phrases
                
                Return only the hint text, nothing else.
                Example: For "BOOKWORM" -> "Reads a lot"`
    }]);

    const hint = data.content[0].text.trim();

    if (hint.length > 20) {
      // Truncate if still over limit, keeping it to 20 characters
      return { hint: hint.substring(0, 20) };
    }

    return { hint };
  } catch (error) {
    console.error('Error generating hint:', error);
    return {
      hint: '',
      error: error instanceof Error ? error.message : 'Failed to generate hint'
    };
  }
};

export const generatePhrases = async (inspiration: string, count: number = 5): Promise<GeneratePhrasesResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate ${count} unique and interesting catch phrases or words based on this inspiration: "${inspiration}".
                Rules for generated words/phrases:
                1. Mix of single words and short phrases (2-3 words)
                2. Suitable for a word game
                3. Each entry should be distinct and creative
                4. No extremely obscure terms
                5. Family-friendly content only
                6. No proper nouns unless very well known
                7. Varying difficulty levels
                
                Return only the list of words/phrases separated by commas, nothing else.
                Example format: Slumber party, DÃ©jÃ  vu, Photograph, Brain teaser, Pumpkin spice`
    }]);

    const phrases = data.content[0].text
      .split(',')
      .map((phrase: string) => phrase.trim())
      .filter((phrase: string) => phrase.length > 0);

    if (phrases.length === 0) {
      throw new Error('No phrases were generated');
    }

    return { phrases };
  } catch (error) {
    console.error('Error generating phrases:', error);
    return {
      phrases: [],
      error: error instanceof Error ? error.message : 'Failed to generate phrases'
    };
  }
};

export const suggestCategory = async (phrase: string, categories: string[]): Promise<SuggestCategoryResponse> => {
  try {
    const response = await fetch('/api/claude/suggest-category', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        phrase,
        categories
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('API error response:', errorText);
      throw new Error(`API request failed: ${response.status} - ${response.statusText}`);
    }

    const data = await response.json();
    return { category: data.category };
  } catch (error) {
    console.error('Error suggesting category:', error);
    return {
      category: '',
      error: error instanceof Error ? error.message : 'Failed to suggest category'
    };
  }
};

============================================================

FILE: .\lib\services\supabase.ts
SIZE: 0.55 KB
LAST MODIFIED: 02/18/2025 10:42:19

import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/supabase'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  }
})

export const checkAuth = async () => {
  if (typeof window === 'undefined') {
    return null
  }
  const { data: { session } } = await supabase.auth.getSession()
  return session
}

============================================================

FILE: .\providers\ThemeProvider.tsx
SIZE: 0.77 KB
LAST MODIFIED: 03/06/2025 21:02:46

"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

/**
 * Hook for using the theme
 * @returns Theme utilities including theme, setTheme, and systemTheme
 */
export function useTheme() {
  const { theme, setTheme, systemTheme } = React.useContext(
    // @ts-ignore - This context does exist in next-themes
    require("next-themes").ThemeContext
  )
  
  return { 
    theme, 
    setTheme, 
    systemTheme,
    toggleTheme: () => setTheme(theme === "dark" ? "light" : "dark")
  }
}

============================================================

FILE: .\services\dashboard-data-service.ts
SIZE: 10.85 KB
LAST MODIFIED: 03/21/2025 18:39:36

// src/services/dashboard-data-service.ts
import { supabase } from '@/lib/services/supabase';

export interface DashboardStats {
  newPhrases: {
    value: number;
    trend: number;
    sparkline: number[];
  };
  reviewedPhrases: {
    value: number;
    trend: number;
    sparkline: number[];
  };
  activeReviewers: {
    value: number;
    trend: number;
  };
  topReviewer: {
    name: string;
    count: number;
    streak: number;
  };
}

export const DashboardDataService = {
  // Fetch dashboard stats
  fetchDashboardStats: async (dateRange = 30): Promise<DashboardStats | null> => {
    try {
      // Calculate date ranges for current period and previous period
      const currentStart = new Date();
      currentStart.setDate(currentStart.getDate() - dateRange);
      
      const previousStart = new Date(currentStart);
      previousStart.setDate(previousStart.getDate() - dateRange);
      
      const currentStartStr = currentStart.toISOString();
      const previousStartStr = previousStart.toISOString();
      const now = new Date().toISOString();
      
      // 1. New Phrases in the Last Month
      const { data: newPhrasesData, error: newPhrasesError } = await supabase
        .from('phrases')
        .select('id, created_at')
        .gte('created_at', currentStartStr)
        .order('created_at', { ascending: true });
      
      if (newPhrasesError) {
        console.error("New phrases query error:", newPhrasesError);
        throw newPhrasesError;
      }
      
      // 2. Calculate previous period for trend
      const { count: previousNewPhrasesCount, error: previousNewPhrasesError } = await supabase
        .from('phrases')
        .select('id', { count: 'exact', head: true })
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousNewPhrasesError) {
        console.error("Previous phrases query error:", previousNewPhrasesError);
        throw previousNewPhrasesError;
      }
      
      // 3. Phrases Reviewed in the Last Month
      const { data: reviewedPhrasesData, error: reviewedPhrasesError } = await supabase
        .from('votes')
        .select('id, created_at')
        .gte('created_at', currentStartStr)
        .order('created_at', { ascending: true });
      
      if (reviewedPhrasesError) {
        console.error("Reviewed phrases query error:", reviewedPhrasesError);
        throw reviewedPhrasesError;
      }
      
      // 4. Calculate previous period for trend
      const { count: previousReviewedCount, error: previousReviewedError } = await supabase
        .from('votes')
        .select('id', { count: 'exact', head: true })
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousReviewedError) {
        console.error("Previous reviewed query error:", previousReviewedError);
        throw previousReviewedError;
      }
      
      // 5. Active Reviewers Count
      const { data: activeReviewers, error: activeReviewersError } = await supabase
        .from('votes')
        .select('reviewer_id')
        .gte('created_at', currentStartStr);
      
      if (activeReviewersError) {
        console.error("Active reviewers query error:", activeReviewersError);
        throw activeReviewersError;
      }
      
      // Get unique reviewer IDs
      const uniqueReviewerIds = [...new Set(activeReviewers?.map(item => item.reviewer_id))];
      
      // 6. Calculate previous period for trend
      const { data: previousActiveReviewers, error: previousActiveReviewersError } = await supabase
        .from('votes')
        .select('reviewer_id')
        .gte('created_at', previousStartStr)
        .lt('created_at', currentStartStr);
      
      if (previousActiveReviewersError) {
        console.error("Previous active reviewers query error:", previousActiveReviewersError);
        throw previousActiveReviewersError;
      }
      
      const previousUniqueReviewerIds = [...new Set(previousActiveReviewers?.map(item => item.reviewer_id))];
      
      // 7. Top Reviewer - Use a different approach for this query
      // First get counts for each reviewer
      const { data: reviewCounts, error: reviewCountsError } = await supabase
        .rpc('get_reviewer_counts', { start_date: currentStartStr });
        
      if (reviewCountsError) {
        console.error("Review counts query error:", reviewCountsError);
        // Fallback approach if RPC doesn't exist
        console.log("Falling back to manual aggregation...");
        // Get all reviewer_ids and manually count them
        const { data: allVotes, error: allVotesError } = await supabase
          .from('votes')
          .select('reviewer_id')
          .gte('created_at', currentStartStr);
          
        if (allVotesError) {
          console.error("All votes query error:", allVotesError);
          throw allVotesError;
        }
        
        // Create a counts object
        const counts = {};
        allVotes?.forEach(vote => {
          if (vote.reviewer_id) {
            counts[vote.reviewer_id] = (counts[vote.reviewer_id] || 0) + 1;
          }
        });
        
        // Convert to array and sort
        const reviewerCounts = Object.entries(counts).map(([reviewer_id, count]) => ({
          reviewer_id,
          count
        })).sort((a, b) => b.count - a.count);
        
        // Get top reviewer
        const topReviewerId = reviewerCounts.length > 0 ? reviewerCounts[0].reviewer_id : null;
        const topReviewerCount = reviewerCounts.length > 0 ? reviewerCounts[0].count : 0;
        
        // 8. Get reviewer details
        let topReviewer = { name: 'N/A', count: 0, streak: 0 };
        
        if (topReviewerId) {
          const { data: reviewerData, error: reviewerError } = await supabase
            .from('reviewers')
            .select('id, name, current_streak')
            .eq('id', topReviewerId)
            .single();
          
          if (reviewerError) {
            console.error("Reviewer details query error:", reviewerError);
          } else if (reviewerData) {
            topReviewer = {
              name: reviewerData.name || 'Unknown',
              count: typeof topReviewerCount === 'number' ? topReviewerCount : 0,
              streak: reviewerData.current_streak || 0
            };
          }
        }
        
        // Calculate sparkline data by grouping by day
        const newPhrasesByDay = groupByDay(newPhrasesData || []);
        const reviewsByDay = groupByDay(reviewedPhrasesData || []);
        
        // Calculate trends
        const newPhrasesTrend = calculateTrend(newPhrasesData?.length || 0, previousNewPhrasesCount || 0);
        const reviewedPhrasesTrend = calculateTrend(reviewedPhrasesData?.length || 0, previousReviewedCount || 0);
        const activeReviewersTrend = calculateTrend(uniqueReviewerIds.length, previousUniqueReviewerIds.length);
        
        return {
          newPhrases: {
            value: newPhrasesData?.length || 0,
            trend: newPhrasesTrend,
            sparkline: Object.values(newPhrasesByDay)
          },
          reviewedPhrases: {
            value: reviewedPhrasesData?.length || 0,
            trend: reviewedPhrasesTrend,
            sparkline: Object.values(reviewsByDay)
          },
          activeReviewers: {
            value: uniqueReviewerIds.length,
            trend: activeReviewersTrend
          },
          topReviewer
        };
      }
      
      // If RPC approach succeeded
      const topReviewerData = reviewCounts && reviewCounts.length > 0 ? reviewCounts[0] : null;
      
      // 8. Get reviewer details
      let topReviewer = { name: 'N/A', count: 0, streak: 0 };
      
      if (topReviewerData) {
        const { data: reviewerData, error: reviewerError } = await supabase
          .from('reviewers')
          .select('id, name, current_streak')
          .eq('id', topReviewerData.reviewer_id)
          .single();
        
        if (reviewerError) {
          console.error("Reviewer details query error:", reviewerError);
        } else if (reviewerData) {
          topReviewer = {
            name: reviewerData.name || 'Unknown',
            count: typeof topReviewerData.count === 'number' ? topReviewerData.count : parseInt(topReviewerData.count) || 0,
            streak: reviewerData.current_streak || 0
          };
        }
      }
      
      // Calculate sparkline data by grouping by day
      const newPhrasesByDay = groupByDay(newPhrasesData || []);
      const reviewsByDay = groupByDay(reviewedPhrasesData || []);
      
      // Calculate trends
      const newPhrasesTrend = calculateTrend(newPhrasesData?.length || 0, previousNewPhrasesCount || 0);
      const reviewedPhrasesTrend = calculateTrend(reviewedPhrasesData?.length || 0, previousReviewedCount || 0);
      const activeReviewersTrend = calculateTrend(uniqueReviewerIds.length, previousUniqueReviewerIds.length);
      
      return {
        newPhrases: {
          value: newPhrasesData?.length || 0,
          trend: newPhrasesTrend,
          sparkline: Object.values(newPhrasesByDay)
        },
        reviewedPhrases: {
          value: reviewedPhrasesData?.length || 0,
          trend: reviewedPhrasesTrend,
          sparkline: Object.values(reviewsByDay)
        },
        activeReviewers: {
          value: uniqueReviewerIds.length,
          trend: activeReviewersTrend
        },
        topReviewer
      };
    } catch (error) {
      console.error('Error fetching dashboard stats:', error);
      // Add detailed error information
      if (error instanceof Error) {
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
      }
      return null;
    }
  },
  
  // Other methods remain the same...
};

// Helper function to calculate percentage trend
function calculateTrend(current: number, previous: number): number {
  if (previous === 0) return current > 0 ? 100 : 0;
  const trend = ((current - previous) / previous) * 100;
  return Math.round(trend);
}

// Helper function to group data by day for sparklines
function groupByDay(data: any[]): Record<string, number> {
  const result: Record<string, number> = {};
  
  // Initialize all days in the period with 0
  const today = new Date();
  for (let i = 30; i >= 0; i--) {
    const date = new Date();
    date.setDate(today.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    result[dateStr] = 0;
  }
  
  // Fill in actual counts
  data.forEach(item => {
    if (item && item.created_at) {
      const dateStr = new Date(item.created_at).toISOString().split('T')[0];
      if (result[dateStr] !== undefined) {
        result[dateStr]++;
      }
    }
  });
  
  return result;
}

============================================================

FILE: .\types\types.ts
SIZE: 5.43 KB
LAST MODIFIED: 03/17/2025 11:40:41

import type { Session } from '@supabase/supabase-js';

export interface PhraseWithRelations extends Phrase {
  categories: Category;
  subcategories?: Subcategory;
  phrase_tags: {
    tags: Tag;
  }[];
}

export interface SupabaseQueryResponse<T> {
  data: T[] | null;
  error: any;
  count?: number | null;
}

export interface Category {
  id: number;
  name: string;
}

export interface PhraseTagWithTag {
  tag_id: number;
  tags: {
    id: number;
    tag: string;
  };
}

export type SubcategoryName = {
  name: string;
}

export interface Subcategory {
  id: number;
  name: string;
  category_id: number;
}

export interface Tag {
  id: number;
  tag: string;
}

export interface PhraseTag {
  phrase_id: number;
  tag_id: number;
}

export interface PhraseBase {
  phrase: string;
  category_id: number;
  subcategory_id?: number | null;
  difficulty: number;  // Changed from string to number
  part_of_speech: string;
  hint?: string | null;
}

export interface Phrase extends Omit<PhraseBase, 'category_id' | 'subcategory_id'> {
  id: number;
  category: string;
  subcategory?: string;
  tags: string;
  difficulty: number;
}

export interface NewPhrase {
  phrase: string;
  category: string;
  subcategory?: string;
  difficulty: string;
  part_of_speech: string;
  hint?: string;
  tags?: string;
}

export interface Vote {
  id: string;
  reviewer_id: string;
  phrase_id: number;
  category: VoteCategory;
  vote: boolean;
  created_at: string;
}

export type VoteCategory = 'phrase' | 'category' | 'subcategory' | 'hint' | 'tags' | 'difficulty';

export interface Filters {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
}

export interface PaginationState {
  currentPage: number;
  rowsPerPage: number;
  totalPages: number;
  totalItems?: number; // Make sure this is included
}
export interface TableState {
  sortConfig: SortConfig;
  pagination: PaginationState;
  filters: Filters;
}
export interface SortConfig {
  key: keyof Phrase | '';
  direction: 'asc' | 'desc';
}

export interface Stats {
  total: number;
  uniqueCategories: number;
  difficultyBreakdown: {
    easy: number;
    medium: number;
    hard: number;
  };
}

export interface Reviewer {
  id: string;
  name: string;
  pin: string;
  total_reviews: number;
  current_streak: number;
  last_review_at: string | null;
}

export interface BulkImportFormProps {
  onSuccess: (importedIds?: number[]) => void;
  onError: (errorMessage: string) => void;
  categories?: string[];
  difficulties?: string[];
  partsOfSpeech?: string[];
}

export interface ImportedPhrase extends NewPhrase {
  id: number;
}

export interface AddPhraseFormProps {
  onAddPhrase: (phrase: NewPhrase) => Promise<void>;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
}

export interface FilterControlsProps {
  filters: Filters;
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading?: boolean;
}

export interface PhrasesTableProps {
  phrases: any[]; // This should match the actual data structure
  loading?: boolean;
  tableState: TableState;
  onTableStateChange: (updates: Partial<TableState>) => void;
  onEdit?: (id: number) => void;
  onDelete?: (id: number) => void;
  newIds?: number[];
  onShowFilters?: () => void;
}

export interface CardViewModalProps {
  isOpen: boolean;
  onClose: () => void;
  phrases: Phrase[];
  currentIndex: number;
  onNavigate: (index: number) => void;
  isEditing: boolean;
  editedPhrase: Phrase | null;
  onEdit: () => void;
  onSave: () => void;
  onCancel: () => void;
  onEditChange: (field: keyof Phrase, value: string) => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  reviewer?: Reviewer;
  onTagClick?: (tag: string) => void;
  loading?: boolean;
  error?: string | null;
}

export interface UsePhrasesReturn {
  phrases: Phrase[];
  loading: boolean;
  error: string | null;
  setError: (error: string | null) => void;
  pagination: PaginationState;
  sortConfig: SortConfig;
  filters: Filters;
  handleSort: (key: keyof Phrase) => void;
  handlePageChange: (page: number) => void;
  handleRowsPerPageChange: (rowsPerPage: number) => void;
  handleFilterChange: (name: string, value: string) => void;
  addPhrase: (phrase: NewPhrase) => Promise<void>;
  editPhrase: (phrase: Phrase) => Promise<void>;
  deletePhrase: (id: number) => Promise<void>;
  fetchPhrases: () => Promise<void>;
  resetFilters: () => void;
  sortByIdDesc: () => void;
}

export interface TagValidationResult {
  isValid: boolean;
  formattedTags: string;
  errors?: string[];
}

export interface UsePaginationProps {
  totalItems: number;
  itemsPerPage: number;
  currentPage: number;
}

export interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

export interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
}

export interface SelectProps {
  value: string;
  onChange: (value: string) => void;
  options: string[];
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  className?: string;
}

export interface StatsSectionProps {
  stats: Stats | null;
  loading: boolean;
}
