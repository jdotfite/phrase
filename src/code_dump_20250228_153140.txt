PROJECT ANALYSIS
Generated: 02/28/2025 15:31:40
Directory: C:\_websites\catch-phrase\src

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: 5.1.19041.5486
OS: Microsoft Windows 10 Pro
Computer Name: OFFICE

============================================================

FILE CONTENTS:

============================================================

FILE: .\claude.ps1
SIZE: 2.94 KB
LAST MODIFIED: 02/13/2025 10:17:39

# Get current directory path and script start time
$currentPath = (Get-Location).Path
$startTime = Get-Date
$outputFile = "code_dump_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"

# Add exclusion patterns for folders and files
$excludedPaths = @(
    'node_modules',
    '.git',
    'bin',
    'obj',
    'dist',
    'build',
    '.vscode',
    'packages'
)

# Write initial info to console
Write-Host "Starting analysis of $currentPath"
Write-Host "Excluding folders: $($excludedPaths -join ', ')"

# Initial file header
$envInfo = @"
PROJECT ANALYSIS
Generated: $(Get-Date)
Directory: $currentPath

===========================================
ENVIRONMENT INFORMATION
===========================================
PowerShell Version: $($PSVersionTable.PSVersion)
OS: $(Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty Caption)
Computer Name: $env:COMPUTERNAME
"@
Set-Content -Path $outputFile -Value $envInfo -Encoding utf8

Write-Host "Gathering file list..."

# Get all files, excluding problematic paths
$allFiles = Get-ChildItem -Path $currentPath -Recurse -File | Where-Object {
    $fullPath = $_.FullName
    $exclude = $false
    foreach ($path in $excludedPaths) {
        if ($fullPath -like "*\$path\*") {
            $exclude = $true
            break
        }
    }
    -not $exclude -and
    $_.Name -ne $outputFile -and
    -not $_.Name.EndsWith(".tmp")
}

# Process each file
"`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
"FILE CONTENTS:" | Out-File $outputFile -Append -Encoding utf8

$fileCounter = 0
$totalFiles = $allFiles.Count

# Avoid division by zero
if ($totalFiles -eq 0) {
    Write-Host "No files found to process. Exiting."
    exit
}

$allFiles | Where-Object {
    $_.Extension -notmatch '\.(exe|dll|pdb|obj|bin|cache|jpg|jpeg|png|gif|bmp|ico|mp3|mp4|zip|rar|7z)$' -and
    $_.Length -lt 5MB
} | ForEach-Object {
    $fileCounter++
    $percentComplete = [math]::Round(($fileCounter / $totalFiles) * 100, 1)
    Write-Progress -Activity "Processing Files" -Status "$fileCounter of $totalFiles ($percentComplete%)" -PercentComplete $percentComplete
    Write-Host "Processing ($fileCounter/$totalFiles): $($_.Name)"

    try {
        # Write file metadata
        $relPath = $_.FullName.Replace($currentPath, ".")
        $fileSize = [math]::Round($_.Length / 1KB, 2)
        
        "`n============================================================`n" | Out-File $outputFile -Append -Encoding utf8
        "FILE: $relPath`nSIZE: $fileSize KB`nLAST MODIFIED: $($_.LastWriteTime)`n" | Out-File $outputFile -Append -Encoding utf8
        
        # Append file content
        Get-Content $_.FullName -Raw | Out-File $outputFile -Append -Encoding utf8
    } catch {
        Write-Warning "Error processing $($_.FullName): $_"
    }
}

Write-Host "Analysis complete. Output saved to $outputFile"


============================================================

FILE: .\db-structure.txt
SIZE: 5.06 KB
LAST MODIFIED: 02/28/2025 15:29:32

phrases table:
[
  {
    "column_name": "id",
    "data_type": "bigint",
    "is_nullable": "NO",
    "column_default": "nextval('phrases_id_seq'::regclass)",
    "character_maximum_length": null
  },
  {
    "column_name": "phrase",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "part_of_speech",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "hint",
    "data_type": "text",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "category_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "subcategory_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "difficulty",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  }
]

categories:
[
  {
    "column_name": "id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": "nextval('main_categories_id_seq'::regclass)",
    "character_maximum_length": null
  },
  {
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  }
]

subcategories:
[
  {
    "column_name": "id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": "nextval('subcategories_id_seq'::regclass)",
    "character_maximum_length": null
  },
  {
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "category_id",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  }
]

tags:
[
  {
    "column_name": "id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": "nextval('tags_id_seq'::regclass)",
    "character_maximum_length": null
  },
  {
    "column_name": "tag",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  }
]

phrase_tags:
[
  {
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "tag_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  }
]

votes:
[
  {
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()",
    "character_maximum_length": null
  },
  {
    "column_name": "reviewer_id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "phrase_id",
    "data_type": "integer",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "category",
    "data_type": "USER-DEFINED",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "vote",
    "data_type": "boolean",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "NO",
    "column_default": "timezone('utc'::text, now())",
    "character_maximum_length": null
  }
]

reveiwers:
[
  {
    "column_name": "id",
    "data_type": "uuid",
    "is_nullable": "NO",
    "column_default": "gen_random_uuid()",
    "character_maximum_length": null
  },
  {
    "column_name": "name",
    "data_type": "text",
    "is_nullable": "NO",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "total_reviews",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0",
    "character_maximum_length": null
  },
  {
    "column_name": "created_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "NO",
    "column_default": "timezone('utc'::text, now())",
    "character_maximum_length": null
  },
  {
    "column_name": "pin",
    "data_type": "character varying",
    "is_nullable": "NO",
    "column_default": "'000000'::character varying",
    "character_maximum_length": 4
  },
  {
    "column_name": "last_review_at",
    "data_type": "timestamp with time zone",
    "is_nullable": "YES",
    "column_default": null,
    "character_maximum_length": null
  },
  {
    "column_name": "current_streak",
    "data_type": "integer",
    "is_nullable": "YES",
    "column_default": "0",
    "character_maximum_length": null
  }
]

============================================================

FILE: .\app\globals.css
SIZE: 0.34 KB
LAST MODIFIED: 02/06/2025 09:46:52

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}


============================================================

FILE: .\app\layout.tsx
SIZE: 0.39 KB
LAST MODIFIED: 02/06/2025 21:36:04

import type { Metadata } from "next";
import "./globals.css";
export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="font-sans antialiased">
        {children}
      </body>
    </html>
  );
}

============================================================

FILE: .\app\page.tsx
SIZE: 0.23 KB
LAST MODIFIED: 02/07/2025 09:27:36

'use client'
 
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
 
export default function Home() {
  const router = useRouter()
  
  useEffect(() => {
    router.push('/admin')
  }, [router])
  
  return null
}

============================================================

FILE: .\app\admin\page.tsx
SIZE: 0.14 KB
LAST MODIFIED: 02/12/2025 00:28:00

'use client'

import AdminDashboard from '@/components/AdminDashboard';

export default function AdminPage() {
  return <AdminDashboard />;
}

============================================================

FILE: .\app\api\claude\route.ts
SIZE: 1.54 KB
LAST MODIFIED: 02/28/2025 15:29:32

import { NextResponse } from 'next/server';

const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';

export async function POST(req: Request) {
  if (!CLAUDE_API_KEY) {
    console.error('Claude API key is not configured');
    return NextResponse.json(
      { error: 'Claude API key is not configured' },
      { status: 500 }
    );
  }

  try {
    const body = await req.json();
    console.log('Received request for Claude API:', body); // Debug log
    
    const claudeResponse = await fetch(CLAUDE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-opus-20240229',
        max_tokens: 150,
        messages: body.messages
      })
    });

    if (!claudeResponse.ok) {
      const errorText = await claudeResponse.text();
      console.error('Claude API error:', errorText);
      return NextResponse.json(
        { error: `Claude API error: ${claudeResponse.statusText}` },
        { status: claudeResponse.status }
      );
    }

    const data = await claudeResponse.json();
    console.log('Successful response from Claude:', data); // Debug log
    return NextResponse.json(data);

  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

============================================================

FILE: .\app\api\test\route.ts
SIZE: 0.14 KB
LAST MODIFIED: 02/18/2025 21:17:34

import { NextResponse } from 'next/server';

export async function GET() {
 return NextResponse.json({ message: 'Hello from test API' });
}


============================================================

FILE: .\app\review\page.tsx
SIZE: 20.55 KB
LAST MODIFIED: 02/17/2025 15:59:57

'use client';

import React, { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import ReviewerSelection from '@/components/reviewer/ReviewerSelection';
import ReviewProgress from '@/components/reviewer/ReviewProgress';
import { CategoryFilter } from '@/components/reviewer/CategoryFilter';
import { usePhrases } from '@/hooks/usePhrases';
import { generateTags, generateHint } from '@/lib/claudeService';
import type {
  Phrase,
  Reviewer,
  Vote,
  VoteCategory,
  PhraseTag,
  PhraseTagWithTag,
  Tag,
  SubcategoryName
} from '@/types/types';

interface FieldProps {
  label: string;
  value: string | number | undefined;
  isEditing?: boolean;
  onChange?: (value: string) => void;
  options?: string[];
  type?: 'text' | 'select' | 'number';
  currentPhrase?: Phrase;
}

interface PhraseFieldProps {
  phrase: string;
  onVote: (isLike: boolean) => void;
  rating?: boolean;
}

interface EditedPhrase {
  id: number;
  category: string | undefined;
  subcategory?: string | undefined;
  hint?: string | undefined;
  difficulty?: number | undefined;
  tags?: string | undefined;
}

const Field: React.FC<FieldProps> = ({
  label,
  value,
  isEditing = false,
  onChange,
  options = [],
  type = 'text',
  currentPhrase
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [tagInputs, setTagInputs] = useState<string[]>(() => {
    if (value && label === 'Tags') {
      const tags = value.toString().split(',').map(tag => tag.trim());
      return [...tags.slice(0, 3), ...Array(3 - tags.length).fill('')].slice(0, 3);
    }
    return ['', '', ''];
  });

  useEffect(() => {
    if (value && label === 'Tags') {
      const tags = value.toString().split(',').map(tag => tag.trim());
      setTagInputs([...tags.slice(0, 3), ...Array(3 - tags.length).fill('')].slice(0, 3));
    }
  }, [value, label]);

  const handleGenerateTags = async () => {
    if (!isEditing || !onChange || !currentPhrase?.phrase) return;

    setIsLoading(true);
    try {
      const result = await generateTags(currentPhrase.phrase);
      if (result.tags.length > 0) {
        const newTags = result.tags.slice(0, 3);
        setTagInputs([...newTags, ...Array(3 - newTags.length).fill('')]);
        onChange(newTags.join(','));
      }
    } catch (error) {
      console.error('Error generating tags:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleGenerateHint = async () => {
    if (!isEditing || !onChange || !currentPhrase?.phrase) return;
  
    setIsLoading(true);
    try {
      const result = await generateHint(currentPhrase.phrase);
      if (result.hint) {
        onChange(result.hint);
      }
    } catch (error) {
      console.error('Error generating hint:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleTagChange = (index: number, newValue: string) => {
    if (!onChange) return;

    const newTags = [...tagInputs];
    newTags[index] = newValue.trim().replace(/\s+/g, '');
    setTagInputs(newTags);
    const validTags = newTags.filter(Boolean);
    onChange(validTags.join(','));
  };

  if (isEditing && label === 'Tags') {
    return (
      <div className="mb-4">
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <div className="space-y-2">
          <div className="grid grid-cols-3 gap-2">
            {tagInputs.map((tag, index) => (
              <input
                key={`tag-${index}`}
                type="text"
                value={tag}
                onChange={(e) => handleTagChange(index, e.target.value)}
                className="p-2 rounded bg-gray-700 text-white border border-gray-600"
                placeholder={`Tag ${index + 1}`}
                maxLength={16}
              />
            ))}
          </div>
          <button
            onClick={handleGenerateTags}
            disabled={isLoading}
            className="px-4 py-2 bg-blue-600 rounded hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed w-full"
          >
            {isLoading ? 'Generating...' : 'ðŸ¤– Ask AI'}
          </button>
        </div>
      </div>
    );
  }

  if (isEditing && label === 'Hint') {
    return (
      <div className="mb-4">
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <div className="flex items-center gap-2">
          <input
            type="text"
            value={value?.toString() || ''}
            onChange={(e) => onChange?.(e.target.value)}
            className="flex-1 p-2 rounded bg-gray-700 text-white border border-gray-600"
          />
          <button
            onClick={handleGenerateHint}
            disabled={isLoading}
            className="shrink-0 px-4 py-2 bg-blue-600 rounded hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center gap-2"
          >
            <span>ðŸ¤–</span>
            <span>Ask AI</span>
          </button>
        </div>
      </div>
    );
  }

  if (isEditing) {
    if (type === 'select') {
      return (
        <div className="mb-4">
          <label className="block text-gray-400 text-sm mb-1">{label}</label>
          <select
            value={value || ''}
            onChange={(e) => onChange?.(e.target.value)}
            className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
          >
            <option value="">Select {label}</option>
            {options.map((opt) => (
              <option key={opt} value={opt}>
                {opt}
              </option>
            ))}
          </select>
        </div>
      );
    }
    return (
      <div className="mb-4">
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <input
          type={type}
          value={value?.toString() || ''}
          onChange={(e) => onChange?.(e.target.value)}
          className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
        />
      </div>
    );
  }

  return (
    <div className="mb-4">
      <span className="block text-gray-400 text-sm">{label}</span>
      <span className="block text-white">{value || '-'}</span>
    </div>
  );
};

const PhraseField: React.FC<PhraseFieldProps> = ({
  phrase,
  onVote,
  rating = false
}) => {
  const buttonKey = `flag-button-${rating}`;
  
  return (
    <div className="mb-4">
      <label className="block text-gray-400 text-sm mb-1">Phrase</label>
      <div className="flex gap-2">
        <div className="flex-1 p-2 rounded bg-gray-700">
          <span className="text-white">{phrase}</span>
        </div>
        <button
          key={buttonKey}
          onClick={() => onVote(!rating)}
          type="button"
          className={`px-4 py-2 rounded flex items-center justify-center gap-2 ${
            rating 
              ? 'bg-blue-600 hover:bg-blue-700' 
              : 'bg-gray-700 hover:bg-blue-600'
          }`}
        >
          <span>ðŸš©</span>
          <span>Flag for Removal</span>
        </button>
      </div>
    </div>
  );
};

const ReviewPage: React.FC = () => {
  const [currentReviewer, setCurrentReviewer] = useState<Reviewer | null>(null);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [previousIndex, setPreviousIndex] = useState<number | null>(null);
  const [phraseRating, setPhraseRating] = useState<boolean>(false);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [categories, setCategories] = useState<string[]>([]);
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [isEditing] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [editedPhrase, setEditedPhrase] = useState<EditedPhrase>({
    id: -1,
    category: undefined,
    subcategory: undefined,
    hint: undefined,
    difficulty: undefined,
    tags: undefined
  });
  const [hasChanges, setHasChanges] = useState(false);

  const {
    phrases,
    loading: phrasesLoading,
    handleFilterChange,
    fetchCategories: fetchCategoriesFromHook,
    fetchPhrases
  } = usePhrases();

  useEffect(() => {
    const loadCategories = async () => {
      const fetchedCategories = await fetchCategoriesFromHook();
      if (fetchedCategories) {
        setCategories(fetchedCategories);
      }
    };
    loadCategories();
  }, [fetchCategoriesFromHook]);

  useEffect(() => {
    const loadSubcategories = async () => {
      if (editedPhrase.category) {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', editedPhrase.category)
          .single();

        if (categoryData) {
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');

          if (subcategoryData) {
            setSubcategories(subcategoryData.map(sub => sub.name));
          }
        }
      } else {
        setSubcategories([]);
      }
    };

    loadSubcategories();
  }, [editedPhrase.category]);

  useEffect(() => {
    const loadPhraseData = async () => {
      const currentPhrase = phrases[currentIndex];
      if (currentPhrase) {
        const { data: categoryData } = await supabase
          .from('categories')
          .select('name')
          .eq('id', currentPhrase.category_id)
          .single();

        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('name')
          .eq('id', currentPhrase.subcategory_id)
          .single();

        setEditedPhrase({
          id: currentPhrase.id,
          category: categoryData?.name || undefined,
          subcategory: subcategoryData?.name || undefined,
          hint: currentPhrase.hint || undefined,
          difficulty: currentPhrase.difficulty || undefined,
          tags: currentPhrase.tags || undefined
        });
        setHasChanges(false);
      }
    };

    loadPhraseData();
  }, [phrases, currentIndex]);

  const handleReviewerSelect = (reviewer: Reviewer) => {
    setCurrentReviewer(reviewer);
  };

  const handleCategorySelect = (category: string | null) => {
    setSelectedCategory(category);
    handleFilterChange('category', category ?? '');
    setCurrentIndex(0);
    setPhraseRating(undefined);
  };

  const handleVote = async (newFlagState: boolean) => {
    if (!currentReviewer || !phrases[currentIndex]) return;
  
    setPhraseRating(newFlagState);
  
    try {
      if (newFlagState) {
        const { error } = await supabase
          .from('votes')
          .insert({
            reviewer_id: currentReviewer.id,
            phrase_id: phrases[currentIndex].id,
            category: 'phrase',
            vote: false,
            created_at: new Date().toISOString()
          });
  
        if (error) {
          setPhraseRating(!newFlagState);
          throw error;
        }
      } else {
        const { error: deleteError } = await supabase
          .from('votes')
          .delete()
          .eq('reviewer_id', currentReviewer.id)
          .eq('phrase_id', phrases[currentIndex].id)
          .eq('category', 'phrase');
  
        if (deleteError) {
          setPhraseRating(!newFlagState);
          throw deleteError;
        }
      }
    } catch (err) {
      console.error('Error recording vote:', err);
    }
  };

  const handleFieldChange = (field: keyof EditedPhrase, value: string) => {
    setEditedPhrase(prev => ({ ...prev, [field]: value }));
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!editedPhrase.id || editedPhrase.id === -1) return;

    setIsSaving(true);
    try {
      const categoryId = await getCategoryId(editedPhrase.category);
      const subcategoryId = await getSubcategoryId(editedPhrase.category, editedPhrase.subcategory);

      const { error: phraseError } = await supabase
        .from('phrases')
        .update({
          hint: editedPhrase.hint,
          difficulty: editedPhrase.difficulty,
          category_id: categoryId,
          subcategory_id: subcategoryId
        })
        .eq('id', editedPhrase.id);

      if (phraseError) throw phraseError;

      if (editedPhrase.tags) {
        const newTags = editedPhrase.tags.split(',').map(tag => tag.trim()).filter(Boolean);
        const { data: existingTagsData } = await supabase
          .from('phrase_tags')
          .select('tags(id, tag)')
          .eq('phrase_id', editedPhrase.id);

        const existingTags = existingTagsData?.map((pt: PhraseTagWithTag) => pt.tags.tag) || [];

        const tagsToRemove = existingTags.filter((tag: string) => !newTags.includes(tag));
                for (const tagToRemove of tagsToRemove) {
          const { data: tagData } = await supabase
            .from('tags')
            .select('id')
            .eq('tag', tagToRemove)
            .single();

          if (tagData) {
            await supabase
              .from('phrase_tags')
              .delete()
              .eq('phrase_id', editedPhrase.id)
              .eq('tag_id', tagData.id);
          }
        }

        for (const newTag of newTags) {
          if (!existingTags.includes(newTag)) {
            let tagId: number | undefined;
            const { data: existingTag } = await supabase
              .from('tags')
              .select('id')
              .eq('tag', newTag)
              .single();

            if (existingTag) {
              tagId = existingTag.id;
            } else {
              const { data: newTagData } = await supabase
                .from('tags')
                .insert({ tag: newTag })
                .select('id')
                .single();

              if (newTagData) tagId = newTagData.id;
            }

            if (tagId) {
              await supabase
                .from('phrase_tags')
                .insert({
                  phrase_id: editedPhrase.id,
                  tag_id: tagId
                });
            }
          }
        }
      }

      await fetchPhrases();
      setHasChanges(false);
    } catch (err) {
      console.error('Error saving changes:', err);
    } finally {
      setIsSaving(false);
    }
  };

  const getCategoryId = async (categoryName: string | undefined) => {
    if (!categoryName) return null;
    const { data } = await supabase
      .from('categories')
      .select('id')
      .eq('name', categoryName)
      .single();
    return data?.id;
  };

  const getSubcategoryId = async (categoryName: string | undefined, subcategoryName: string | undefined) => {
    if (!categoryName || !subcategoryName) return null;
    const categoryId = await getCategoryId(categoryName);
    if (!categoryId) return null;

    const { data } = await supabase
      .from('subcategories')
      .select('id')
      .eq('name', subcategoryName)
      .eq('category_id', categoryId)
      .single();
    return data?.id;
  };

  const handleNext = () => {
    setPreviousIndex(currentIndex);
    setCurrentIndex(prev => prev + 1);
    setPhraseRating(false); // Reset rating for next phrase
  };

  const handleBack = () => {
    if (previousIndex !== null) {
      setCurrentIndex(previousIndex);
      setPreviousIndex(null);
      setPhraseRating(undefined);
    }
  };

  if (phrasesLoading) {
    return (
      <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
        Loading...
      </div>
    );
  }

  if (!currentReviewer) {
    return (
      <ReviewerSelection
        onSelectReviewer={handleReviewerSelect}
        onClose={() => {}}
      />
    );
  }

  const currentPhrase = phrases[currentIndex];

  if (!currentPhrase) {
    return (
      <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-4">All caught up! ðŸŽ‰</h2>
          <p>You've reviewed all available phrases.</p>
          <button
            onClick={() => setCurrentReviewer(null)}
            className="mt-4 px-4 py-2 bg-blue-600 rounded hover:bg-blue-700"
          >
            Switch Reviewer
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4">
      <div className="max-w-2xl mx-auto">
        <div className="mb-6">
          <div className="flex justify-between items-start">
            <div>
              <h1 className="text-2xl font-bold">Phrase Review</h1>
              <p className="text-gray-400 mt-2">
                Reviewer: {currentReviewer.name} ({currentReviewer.total_reviews} reviews)
              </p>
            </div>
            <button
              onClick={() => setCurrentReviewer(null)}
              className="px-4 py-2 bg-gray-800 rounded hover:bg-gray-700"
            >
              Switch Reviewer
            </button>
          </div>
        </div>

        <div className="flex items-center gap-4 mb-6">
          <CategoryFilter
            categories={categories}
            selectedCategory={selectedCategory}
            onSelect={handleCategorySelect}
          />
          <div className="flex-1">
            <ReviewProgress streak={currentReviewer.current_streak} />
          </div>
        </div>

        <div className="bg-gray-800 rounded p-6">
          <PhraseField
            phrase={currentPhrase.phrase}
            onVote={handleVote}
            rating={phraseRating}
          />
          <Field
            label="Difficulty"
            value={
              editedPhrase.difficulty === 1 ? 'Easy' :
              editedPhrase.difficulty === 2 ? 'Medium' :
              editedPhrase.difficulty === 3 ? 'Hard' :
              '-'
            }
            isEditing={isEditing}
            onChange={(value) => {
              const difficultyMap = { 'Easy': 1, 'Medium': 2, 'Hard': 3 };
              handleFieldChange('difficulty', difficultyMap[value as keyof typeof difficultyMap].toString());
            }}
            type="select"
            options={['Easy', 'Medium', 'Hard']}
          />
          <Field
            label="Category"
            value={editedPhrase.category || ''}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('category', value)}
            type="select"
            options={categories}
          />
          <Field
            label="Subcategory"
            value={editedPhrase.subcategory || ''}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('subcategory', value)}
            type="select"
            options={subcategories}
          />
          <Field
            label="Tags"
            value={editedPhrase.tags}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('tags', value)}
            currentPhrase={currentPhrase}
          />
          <Field
            label="Hint"
            value={editedPhrase.hint}
            isEditing={isEditing}
            onChange={(value) => handleFieldChange('hint', value)}
            currentPhrase={currentPhrase}
          />
          <div className="flex justify-between items-center mt-6">
            <button
              onClick={handleSave}
              disabled={!hasChanges || isSaving}
              className={`px-4 py-2 md:text-base rounded ${
                hasChanges ? 'bg-blue-600 hover:bg-blue-700' : 'bg-gray-600 cursor-not-allowed'
              }`}
            >
              {isSaving ? 'Saving...' : 'Save Changes'}
            </button>
            <div className="flex items-center gap-4">
              <div className="flex gap-2">
                {previousIndex !== null && (
                  <button
                    className="w-12 h-12 rounded-full flex items-center justify-center bg-gray-700 hover:bg-gray-600"
                    onClick={handleBack}
                  >
                    â†
                  </button>
                )}
                <button
                  className="w-12 h-12 rounded-full flex items-center justify-center bg-blue-600 hover:bg-blue-700"
                  onClick={handleNext}
                >
                  â†’
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ReviewPage;

============================================================

FILE: .\components\AdminDashboard.bak
SIZE: 37.98 KB
LAST MODIFIED: 02/07/2025 22:33:07

'use client'

import React, { useState, useEffect, useRef } from 'react';
import { supabase } from '@/lib/supabase';
import Papa from 'papaparse';
import { ChevronDown, ChevronUp, ChevronRight, ChevronLeft, X, Pencil, Save } from 'lucide-react';
import useCountUp from '@/hooks/useCountUp';  // Import the hook
import Login from '@/components/Login';

interface Phrase {
  id: number;
  phrase: string;
  category: string;
  difficulty: string;
  subcategory: string;
  tags: string;  
  hint: string;  
  part_of_speech: string;
  last_used?: string | null;
}

interface NewPhrase {
  phrase: string;
  category: string;
  difficulty: string;
  subcategory: string;
  tags: string;
  hint: string;
  part_of_speech: string;
}

interface Filters {
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
  searchTerm: string;
}

interface PaginationState {
  currentPage: number;
  rowsPerPage: number;
  totalPages: number;
}

interface FieldProps {
  label: string;
  value: any;
  onChange?: (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => void;
  type?: string;
  options?: string[];
}

const AdminDashboard = () => {
	const [showLoginModal, setShowLoginModal] = useState(false);
	const [session, setSession] = useState<any>(null);
	
useEffect(() => {
  // Remove initial checkAuth() call
  supabase.auth.onAuthStateChange((_event, session) => {
    setSession(session);
    if (session) {
      setShowLoginModal(false);
    }
  });
}, []);

  const [phrases, setPhrases] = useState<Phrase[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [newPhrase, setNewPhrase] = useState<NewPhrase>({
    phrase: '',
    category: '',
    difficulty: '',
    subcategory: '',
    tags: '',
    hint: '',
    part_of_speech: ''
  });
  


  const [stats, setStats] = useState({
    total: 0,
    uniqueCategories: 0,
    difficultyBreakdown: {
      easy: 0,
      medium: 0,
      hard: 0
    }
  });

  const [showCardModal, setShowCardModal] = useState(false);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isEditing, setIsEditing] = useState(false);
  const [editedPhrase, setEditedPhrase] = useState<Phrase | null>(null);
  const [selectedPhrase, setSelectedPhrase] = useState<Phrase | null>(null);
  const [expandedSection, setExpandedSection] = useState<string>('');
  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    rowsPerPage: 100,
    totalPages: 1
  });

  const isInitialRender = useRef(true);

  const animatedTotal = useCountUp(isInitialRender.current ? 0 : stats.total);
  const animatedUniqueCategories = useCountUp(isInitialRender.current ? 0 : stats.uniqueCategories);
  const animatedEasy = useCountUp(isInitialRender.current ? 0 : stats.difficultyBreakdown.easy);
  const animatedMedium = useCountUp(isInitialRender.current ? 0 : stats.difficultyBreakdown.medium);
  const animatedHard = useCountUp(isInitialRender.current ? 0 : stats.difficultyBreakdown.hard);

  useEffect(() => {
    if (isInitialRender.current) {
      isInitialRender.current = false;
    }
  }, []);

  const handleCancel = () => {
  
    setEditedPhrase(null);
    setIsEditing(false);
    resetFilters(); // Add this to reset search when closing modal
  };

const handleEdit = async () => {
  if (!(await checkAuth())) return;
  setEditedPhrase({
    ...phrases[currentIndex],
    id: phrases[currentIndex].id
  });
  setIsEditing(true);
};

const handleCardSave = async () => {
 if (!(await checkAuth())) return;
 await handleEditPhrase(editedPhrase!);
  setShowCardModal(false);
  setIsEditing(false);
};
 

  
  const [sortConfig, setSortConfig] = useState<{
    key: keyof Phrase | '';
    direction: 'asc' | 'desc'; 
  }>({ key: '', direction: 'asc' });
  
  const [filters, setFilters] = useState<Filters>({
    category: '',
    difficulty: '',
    subcategory: '',
    part_of_speech: '',
    searchTerm: ''
  });
  
  const displayPhrase = isEditing ? editedPhrase : phrases[currentIndex];
  
  const [categories, setCategories] = useState<string[]>([]);
  const [difficulties, setDifficulties] = useState<string[]>([]);
  const [partsOfSpeech, setPartsOfSpeech] = useState<string[]>([]);

const formatForDatabase = (value: string | null): string => {
  if (!value) return '';
  return value.trim();
};

  const cleanPhraseData = (phrase: Phrase): Phrase => {
    return {
      ...phrase,
      tags: formatForDatabase(phrase.tags),
      hint: formatForDatabase(phrase.hint)
    };
  };
  
   // Add Field component for card view
 const Field: React.FC<FieldProps> = ({ label, value, onChange, type = "text", options = [] }) => {
  if (isEditing) {
	// Add auth wrapper to onChange
	const handleAuthChange = async (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
      if (!(await checkAuth())) return;
      onChange?.(e);
    };
	
      if (type === "select") {
        return (
          <div className="mb-4">
            <label className="block text-gray-400 text-sm mb-1">{label}</label>
            <select
              value={value || ""}
              onChange={onChange}
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
            >
              <option value="">Select {label}</option>
              {options.map(opt => (
                <option key={opt} value={opt}>{opt}</option>
              ))}
            </select>
          </div>
        );
      }
      return (
        <div className="mb-4">
          <label className="block text-gray-400 text-sm mb-1">{label}</label>
          <input
            type={type}
            value={value || ""}
            onChange={onChange}
            className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
          />
        </div>
      );
    }

    const displayValue = (() => {
  if (!value) return '-';
  if (type === "tags") {
    const tags = value.split(',').map((t: string) => t.trim());
    return (
      <div className="flex flex-wrap gap-2 mt-2">
        {tags.map((tag: string, idx: number) => (
          <button
            key={idx}
            onClick={() => {
              setFilters(prev => ({ ...prev, searchTerm: tag }));
              setShowCardModal(false);
              applyFilters();
            }}
            className="px-3 py-1 bg-gray-700 rounded-full text-sm hover:bg-gray-600"
          >
            {tag}
          </button>
        ))}
      </div>
    );
  }
  return value;
})();

    return (
      <div className="mb-4">
        <span className="block text-gray-400 text-sm">{label}</span>
        <span className="block text-white">{displayValue}</span>
      </div>
    );
  };

  // Add card navigation handlers
  const handleNext = () => {
    if (currentIndex < phrases.length - 1) {
      setCurrentIndex(currentIndex + 1);
      setIsEditing(false);
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
      setIsEditing(false);
    }
  };

// Update table actions to include card view
  const renderTableActions = (phrase: Phrase) => (
    <div className="flex gap-4">
    <button
      onClick={() => setSelectedPhrase(phrase)}
      className="text-blue-400 hover:text-blue-300 transition-colors"
    >
      Edit
    </button>
    <button
      onClick={() => handleDeletePhrase(phrase.id)}
      className="text-red-400 hover:text-red-300 transition-colors"
    >
      Delete
    </button>
  </div>
  );
  
  useEffect(() => {
    fetchPhrases();
    calculateStats();
    fetchCategories();
    fetchDifficulties();
    fetchPartsOfSpeech();
  }, [filters, pagination.rowsPerPage, pagination.currentPage, sortConfig]);
  //centeral auth check
const checkAuth = async () => {
  const { data: { session } } = await supabase.auth.getSession();
  setSession(session);
  if (!session) {
    setShowLoginModal(true);
    return false;
  }
  return true;
};
  const handleSort = (key: keyof Phrase) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
    setPagination(prev => ({ ...prev, currentPage: 1 })); // Reset to first page when sorting
  };

  const fetchPhrases = async () => {
    try {
      setLoading(true);
      let query = supabase.from('phrases').select('*', { count: 'exact' });

      // Apply filters
      if (filters.category) query = query.eq('category', filters.category);
      if (filters.difficulty) query = query.eq('difficulty', filters.difficulty);
      if (filters.subcategory) query = query.eq('subcategory', filters.subcategory);
      if (filters.part_of_speech) query = query.eq('part_of_speech', filters.part_of_speech);
      if (filters.searchTerm) {
        query = query.or(`phrase.ilike.%${filters.searchTerm}%,tags.cs.{${filters.searchTerm}}`);
      }

      // Apply sorting
      if (sortConfig.key) {
        // Ensure we're sorting null values last
        query = query.order(sortConfig.key, { 
          ascending: sortConfig.direction === 'asc',
          nullsFirst: false 
        });
      } else {
        // Default sort by last_used if no sort is specified
        query = query.order('last_used', { ascending: true, nullsFirst: false });
      }

      // Calculate pagination range
      const start = (pagination.currentPage - 1) * pagination.rowsPerPage;
      const end = start + pagination.rowsPerPage - 1;
      query = query.range(start, end);

      const { data, error: supabaseError, count } = await query;

      if (supabaseError) throw supabaseError;
      
      const cleanedData = (data as Phrase[]).map(cleanPhraseData);
      setPhrases(cleanedData);
      
      if (count) {
        setPagination(prev => ({
          ...prev,
          totalPages: Math.ceil(count / prev.rowsPerPage)
        }));
      }
    } catch (err) {
      console.error('Error:', err);
      setError('Failed to fetch phrases');
    } finally {
      setLoading(false);
    }
  };
const formatNumber = (num: number): string => {
  return num.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};

const calculateStats = async () => {
  try {
    const { data: allPhrases, error, count } = await supabase
      .from('phrases')
      .select('*', { count: 'exact' })
      .range(0, 999999);  // This should cover all rows unless you have more than a million
    
    console.log('Supabase response:', { data: allPhrases, error, count });

    if (!allPhrases || allPhrases.length === 0) {
      console.error('No phrases data returned');
      return;
    }

    // Total count
    const totalCount = count || allPhrases.length;
    console.log('Total count (from Supabase count):', count);
    console.log('Total count (allPhrases.length):', allPhrases.length);

    // Difficulty distribution
    const difficultyCount = allPhrases.reduce((acc, p) => {
      acc[p.difficulty] = (acc[p.difficulty] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Category breakdown
    const uniqueCategories = new Set(allPhrases.map(p => p.category)).size;
    
    // Calculate percentages (note the capitalized difficulty levels)
    const easyPercentage = Math.round((difficultyCount['Easy'] || 0) / totalCount * 100) || 0;
    const mediumPercentage = Math.round((difficultyCount['Medium'] || 0) / totalCount * 100) || 0;
    const hardPercentage = Math.round((difficultyCount['Hard'] || 0) / totalCount * 100) || 0;

    console.log('Calculated percentages:', { easy: easyPercentage, medium: mediumPercentage, hard: hardPercentage });

     setStats({
      total: totalCount,
      uniqueCategories,
      difficultyBreakdown: {
        easy: easyPercentage,
        medium: mediumPercentage,
        hard: hardPercentage
      }
    });

    console.log('Set stats:', { total: totalCount, uniqueCategories, difficultyBreakdown: { easy: easyPercentage, medium: mediumPercentage, hard: hardPercentage } });
  } catch (err) {
    console.error('Error calculating stats:', err);
  }
};


  const fetchCategories = async () => {
    const { data, error } = await supabase
      .from('phrases')
      .select('category');
    if (!error && data) {
      const uniqueCategories = [...new Set(data.map(item => item.category))];
      setCategories(uniqueCategories);
    }
  };

  const fetchDifficulties = async () => {
    const { data, error } = await supabase
      .from('phrases')
      .select('difficulty');
    if (!error && data) {
      const uniqueDifficulties = [...new Set(data.map(item => item.difficulty))];
      setDifficulties(uniqueDifficulties);
    }
  };

  const fetchPartsOfSpeech = async () => {
    const { data, error } = await supabase
      .from('phrases')
      .select('part_of_speech');
    if (!error && data) {
      const uniquePartsOfSpeech = [...new Set(data.map(item => item.part_of_speech))];
      setPartsOfSpeech(uniquePartsOfSpeech);
    }
  };

  const handleFilterChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFilters(prev => ({ ...prev, [name]: value }));
  };

const handleAddPhrase = async (e: React.FormEvent<HTMLFormElement>) => {
 e.preventDefault();
 if (!(await checkAuth())) return;

 try {
   const phraseData = {
       ...newPhrase
   };

   const { error } = await supabase
     .from('phrases')
     .insert([phraseData]);

    if (error) {
      if (error.code === '42501') {
        setError('Permission denied. You may not have the correct permissions to add phrases.');
      } else {
        setError(`Failed to add phrase: ${error.message}`);
      }
      return;
    }

    setNewPhrase({
      phrase: '',
      category: '',
      difficulty: '',
      subcategory: '',
      tags: '',
      hint: '',
      part_of_speech: ''
    });

    fetchPhrases();
  } catch (err) {
    console.error('Error:', err);
    setError('An unexpected error occurred');
  }
};


const handleEditPhrase = async (phrase: Phrase) => {
  if (!(await checkAuth())) return;

  try {
    // No need for array conversion anymore
    const { error } = await supabase
      .from('phrases')
      .update(phrase)
      .eq('id', phrase.id);

    if (error) {
      if (error.code === '42501') {
        setError('Permission denied. You may not have the correct permissions to edit phrases.');
      } else {
        setError(`Failed to update phrase: ${error.message}`);
      }
      return;
    }

    setSelectedPhrase(null);
    fetchPhrases();
  } catch (err) {
    console.error('Error:', err);
    setError('An unexpected error occurred');
  }
};


  const handleDeletePhrase = async (id: number) => {
  if (!window.confirm('Are you sure you want to delete this phrase?')) {
    return;
  }

  if (!(await checkAuth())) return;

  try {
    const { error } = await supabase
      .from('phrases')
      .delete()
      .eq('id', id);

    if (error) {
      if (error.code === '42501') {
        setError('Permission denied. You may not have the correct permissions to delete phrases.');
      } else {
        setError(`Failed to delete phrase: ${error.message}`);
      }
      return;
    }
    
    fetchPhrases();
  } catch (err) {
    console.error('Error:', err);
    setError('An unexpected error occurred');
  }
};

const handleBulkImport = async (text: string) => {
  if (!(await checkAuth())) return;
  if (!text?.trim()) return;

  try {
    const rows = text.trim().split('\n').map((row, index) => {
      const parts = row.split(',').map(part => part.trim());

      if (parts.length !== 7) {
        throw new Error(`Row ${index + 1} has invalid format. Expected 7 fields, found ${parts.length}.`);
      }

      const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = parts;

      return {
        phrase,
        category,
        difficulty,
        subcategory,
        tags,  // No more processing needed
        hint,  // No more processing needed
        part_of_speech
      };
    });

    console.log(rows); // Log parsed rows for debugging

    const { error } = await supabase.from('phrases').insert(rows);
    if (error) throw error;
    
    setBulkImportText('');
    fetchPhrases();
    setError(null); // Clear any previous errors
  } catch (err) {
    console.error('Error:', err);
    setError(err.message || 'Failed to import phrases. Ensure the format is correct: phrase,category,difficulty,subcategory,tag1,tag2,hint,part_of_speech');
  }
};




const [bulkImportText, setBulkImportText] = useState('');
  const applyFilters = () => {
    setPagination(prev => ({ ...prev, currentPage: 1 }));
    fetchPhrases();
  };

  const resetFilters = () => {
    setFilters({
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: '',
      searchTerm: ''
    });
    setPagination(prev => ({ ...prev, currentPage: 1 }));
    fetchPhrases();
  };

  // Section header component
  const SectionHeader = ({ title, section }: { title: string, section: string }) => (
    <div 
      className="flex items-center gap-2 cursor-pointer"
      onClick={() => setExpandedSection(expandedSection === section ? '' : section)}
    >
      <ChevronRight 
        size={20}
        className={`transform transition-transform ${expandedSection === section ? 'rotate-90' : ''}`}
      />
      <h2 className="text-xl font-bold">{title}</h2>
    </div>
  );
  
  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
        <div className="text-xl">Loading dashboard...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4 lg:p-8">
	  {/* Login Modal */}
      {showLoginModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full">
            <Login />
          </div>
        </div>
      )}
	
      <div className="max-w-[1920px] mx-auto">
        {error && (
          <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-6">
            {error}
          </div>
        )}

        {/* Stats Section */}
<div className="grid grid-cols-2 md:grid-cols-5 gap-6 mb-8">
          <div className="bg-gray-800 p-6 rounded-lg shadow">

    <div className="text-2xl font-bold">{formatNumber(animatedTotal)}</div>

    <div className="text-gray-400">Total Phrases</div>
  </div>
          <div className="bg-gray-800 p-6 rounded-lg shadow">
            <div className="text-2xl font-bold">{animatedUniqueCategories}</div>
            <div className="text-gray-400">Unique Categories</div>
          </div>
          <div className="bg-gray-800 p-6 rounded-lg shadow">
            <div className="text-2xl font-bold">{animatedEasy}%</div>
            <div className="text-gray-400">Easy Phrases</div>
          </div>
          <div className="bg-gray-800 p-6 rounded-lg shadow">
            <div className="text-2xl font-bold">{animatedMedium}%</div>
            <div className="text-gray-400">Medium Phrases</div>
          </div>
          <div className="bg-gray-800 p-6 rounded-lg shadow">
            <div className="text-2xl font-bold">{animatedHard}%</div>
            <div className="text-gray-400">Hard Phrases</div>
          </div>

        </div>
<div className="grid grid-cols-2 gap-6 mb-8">
        {/* Add New Phrase Section */}
        <div className="bg-gray-800 p-6 rounded-lg shadow">
          <SectionHeader title="Add New Phrase" section="addPhrase" />
          {expandedSection === 'addPhrase' && (
            <form onSubmit={handleAddPhrase} className="space-y-4 mt-4">
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
    <input
      type="text"
      placeholder="Phrase"
      value={newPhrase.phrase}
      onChange={e => setNewPhrase({...newPhrase, phrase: e.target.value})}
      className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
      required
      minLength={2}
    />
    <select
      value={newPhrase.category}
      onChange={e => setNewPhrase({...newPhrase, category: e.target.value})}
      className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
      required
    >
      <option value="">Select Category</option>
      {categories.map(category => (
        <option key={category} value={category}>{category}</option>
      ))}
    </select>
    <input
      type="text"
      placeholder="Subcategory"
      value={newPhrase.subcategory}
      onChange={e => setNewPhrase({...newPhrase, subcategory: e.target.value})}
      className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
      required
      minLength={2}
    />
    <select
      value={newPhrase.difficulty}
      onChange={e => setNewPhrase({...newPhrase, difficulty: e.target.value})}
      className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
      required
    >
      <option value="">Select Difficulty</option>
      {difficulties.map(difficulty => (
        <option key={difficulty} value={difficulty}>{difficulty}</option>
      ))}
    </select>
    <input
      type="text"
      placeholder="Tags (comma separated)"
      value={newPhrase.tags}
      onChange={e => setNewPhrase({...newPhrase, tags: e.target.value})}
      className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
      required
      pattern="^[a-zA-Z0-9\s,]+$"
      title="Enter comma-separated tags using letters, numbers and spaces"
    />
    <input
      type="text"
      placeholder="Hint"
      value={newPhrase.hint}
      onChange={e => setNewPhrase({...newPhrase, hint: e.target.value})}
      className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
      required
      pattern="^[a-zA-Z0-9\s,]+$"
      title="Enter hint"
    />
    <select
      value={newPhrase.part_of_speech}
      onChange={e => setNewPhrase({...newPhrase, part_of_speech: e.target.value})}
      className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
      required
    >
      <option value="">Select Part of Speech</option>
      {partsOfSpeech.map(pos => (
        <option key={pos} value={pos}>{pos}</option>
      ))}
    </select>
  </div>
  <button
    type="submit"
    className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
  >
    Add Phrase
  </button>
</form>
          )}
        </div>

        {/* Bulk Import Section */}
<div className="bg-gray-800 p-6 rounded-lg shadow">
  <SectionHeader title="Bulk Import" section="bulkImport" />
  {expandedSection === 'bulkImport' && (
    <div className="mt-4">
      <textarea
        value={bulkImportText}
        onChange={(e) => setBulkImportText(e.target.value)}
        className="w-full h-32 p-2 bg-gray-700 border border-gray-600 rounded text-white mb-4"
  placeholder={`phrase,category,difficulty,subcategory,tags,hint,part_of_speech`}
/>
<p className="text-sm text-gray-400 mb-4">
  Format: phrase,category,difficulty,subcategory,tag1 tag2 tag3,hint1 hint2,part_of_speech
</p>
      <button 
        onClick={() => handleBulkImport(bulkImportText)}
        className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
      >
        Submit Import
      </button>
    </div>
  )}
</div>
</div>
        {/* Filters Section */}
        <div className="bg-gray-800 p-6 rounded-lg shadow mb-8">
          <h2 className="text-xl font-bold mb-4">Filters</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <input
              type="text"
              name="searchTerm"
              placeholder="Search phrases or tags"
              value={filters.searchTerm}
              onChange={handleFilterChange}
              className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
            />
            <select
              name="category"
              value={filters.category}
              onChange={handleFilterChange}
              className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
            >
              <option value="">Select Category</option>
              {categories.map(category => (
                <option key={category} value={category}>{category}</option>
              ))}
            </select>
            <input
              type="text"
              name="subcategory"
              placeholder="Subcategory"
              value={filters.subcategory}
              onChange={handleFilterChange}
              className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
            />
            <select
              name="difficulty"
              value={filters.difficulty}
              onChange={handleFilterChange}
              className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
            >
              <option value="">Select Difficulty</option>
              {difficulties.map(difficulty => (
                <option key={difficulty} value={difficulty}>{difficulty}</option>
              ))}
            </select>
            <select
              name="part_of_speech"
              value={filters.part_of_speech}
              onChange={handleFilterChange}
              className="p-2 border border-gray-600 rounded bg-gray-700 text-white"
            >
              <option value="">Select Part of Speech</option>
              {partsOfSpeech.map(pos => (
                <option key={pos} value={pos}>{pos}</option>
              ))}
            </select>
          </div>
          <div className="flex justify-end gap-4">
            <button
              onClick={resetFilters}
              className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
            >
              Reset Filters
            </button>
            <button
              onClick={applyFilters}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Apply Filters
            </button>
          </div>
        </div>

        {/* Table Section */}
        <div className="bg-gray-800/50 rounded-xl shadow-xl overflow-hidden">
  <div className="p-4 bg-gray-800 border-b border-gray-700 flex justify-between items-center">
    <select
      value={pagination.rowsPerPage}
      onChange={(e) => setPagination({
        ...pagination,
        rowsPerPage: Number(e.target.value),
        currentPage: 1
      })}
      className="bg-gray-700 border border-gray-600 rounded px-2 py-1"
    >
      {[100, 250, 500, 1000].map(value => (
        <option key={value} value={value}>{value} rows</option>
      ))}
    </select>
    
    <button
      onClick={() => setShowCardModal(true)}
      className="px-3 py-1  bg-blue-600 text-white rounded hover:bg-blue-700"
    >
      Mobile Card View
    </button>
            
            <div className="flex items-center gap-4">
              <button
                onClick={() => setPagination(prev => ({ ...prev, currentPage: prev.currentPage - 1 }))}
                disabled={pagination.currentPage === 1}
                className="px-3 py-1 bg-gray-700 rounded disabled:opacity-50"
              >
                Previous
              </button>
              <span>
                Page {pagination.currentPage} of {pagination.totalPages}
              </span>
              <button
                onClick={() => setPagination(prev => ({ ...prev, currentPage: prev.currentPage + 1 }))}
                disabled={pagination.currentPage === pagination.totalPages}
                className="px-3 py-1 bg-gray-700 rounded disabled:opacity-50"
              >
                Next
              </button>
            </div>
          </div>

          <div className="overflow-x-auto">
            <table className="w-full table-auto">
              <thead>
                <tr className="border-b border-gray-700">
                  {[
				    ['id', 'ID'],
                    ['phrase', 'Phrase'],
                    ['category', 'Category'],
                    ['subcategory', 'Subcategory'],
                    ['difficulty', 'Difficulty'],
                    ['tags', 'Tags'],
                    ['hint', 'Hint'],
                    ['part_of_speech', 'Part of Speech']
                  ].map(([key, label]) => (
                    <th
                      key={key}
                      onClick={() => handleSort(key as keyof Phrase)}
                      className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider bg-gray-800/80 cursor-pointer"
                    >
                      <div className="flex items-center gap-2">
                        {label}
                        {sortConfig.key === key && (
                          sortConfig.direction === 'asc' ? <ChevronUp size={14} /> : <ChevronDown size={14} />
                        )}
                      </div>
                    </th>
                  ))}
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider bg-gray-800/80">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody>
  {phrases.map((phrase, index) => (
    <tr 
      key={phrase.id} 
      className={`
        border-b border-gray-700/50 
        ${index % 2 === 0 ? 'bg-gray-800/30' : 'bg-gray-800/50'}
        hover:bg-gray-700/50 transition-colors duration-150
      `}
    >
      <td className="px-4 py-3 whitespace-nowrap">{phrase.id}</td>  {/* New ID cell */}
      <td className="px-4 py-3 whitespace-nowrap">{phrase.phrase}</td>
      <td className="px-4 py-3 whitespace-nowrap">{phrase.category}</td>
      <td className="px-4 py-3 whitespace-nowrap">{phrase.subcategory}</td>
      <td className="px-4 py-3 whitespace-nowrap">{phrase.difficulty}</td>
      <td className="px-4 py-3 whitespace-nowrap">{phrase.tags}</td>
      <td className="px-4 py-3 whitespace-nowrap">{phrase.hint}</td>
      <td className="px-4 py-3 whitespace-nowrap">{phrase.part_of_speech}</td>
      <td className="px-4 py-3 whitespace-nowrap">
        {renderTableActions(phrase)}
      </td>
    </tr>
  ))}
</tbody>
            </table>
          </div>
        </div>
      </div>
	
{/* Add Card Modal */}
{showCardModal && (
  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
    <div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full max-h-[90vh] overflow-y-auto">
      {/* Modal header */}
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold">Phrase Card View</h2>
        <button 
          onClick={() => setShowCardModal(false)}
          className="p-2 hover:bg-gray-700 rounded-full"
        >
          <X size={20} />
        </button>
      </div>

      {/* Navigation */}
      <div className="flex justify-between items-center mb-4">
        <span className="text-sm text-gray-400">
          Phrase {currentIndex + 1} of {phrases.length}
        </span>
        <div className="flex gap-4">
          <button
            onClick={() => setCurrentIndex(prev => Math.max(0, prev - 1))}
            disabled={currentIndex === 0}
            className="p-2 hover:bg-gray-700 rounded-full disabled:opacity-50"
          >
            <ChevronLeft size={20} />
          </button>
          <button
            onClick={() => setCurrentIndex(prev => Math.min(phrases.length - 1, prev + 1))}
            disabled={currentIndex === phrases.length - 1}
            className="p-2 hover:bg-gray-700 rounded-full disabled:opacity-50"
          >
            <ChevronRight size={20} />
          </button>
        </div>
      </div>
{/* Display current phrase */}
      {displayPhrase && (
        <>

      <Field
        label="Phrase"
        value={displayPhrase.phrase}
        onChange={e => setEditedPhrase({ ...editedPhrase!, phrase: e.target.value })}
      />
      <Field
        label="Category"
        value={displayPhrase.category}
        onChange={e => setEditedPhrase({ ...editedPhrase!, category: e.target.value })}
        type="select"
        options={categories}
      />
      <Field
        label="Subcategory"
        value={displayPhrase.subcategory}
        onChange={e => setEditedPhrase({ ...editedPhrase!, subcategory: e.target.value })}
      />
      <Field
        label="Difficulty"
        value={displayPhrase.difficulty}
        onChange={e => setEditedPhrase({ ...editedPhrase!, difficulty: e.target.value })}
        type="select"
        options={difficulties}
      />
      <Field
        label="Tags"
        value={displayPhrase.tags}
        onChange={e => setEditedPhrase({ ...editedPhrase!, tags: e.target.value })}
        type="tags"
      />
      <Field
        label="Hint"
        value={displayPhrase.hint}
        onChange={e => setEditedPhrase({ ...editedPhrase!, hint: e.target.value })}
      />
      <Field
        label="Part of Speech"
        value={displayPhrase.part_of_speech}
        onChange={e => setEditedPhrase({ ...editedPhrase!, part_of_speech: e.target.value })}
        type="select"
        options={partsOfSpeech}
      />

       {/* Edit controls */}
          <div className="flex justify-between mt-6">
            {isEditing ? (
              <>
                <button onClick={handleCancel} className="flex items-center gap-2 px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600">
                  <X size={16} />Cancel
                </button>
                <button onClick={handleCardSave} className="flex items-center gap-2 px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700">
                  <Save size={16} />Save
                </button>
              </>
            ) : (
              <button onClick={handleEdit} className="flex items-center gap-2 px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700">
                <Pencil size={16} />Edit
              </button>
            )}
          </div>
        </>
      )}
    </div>
  </div>
)}
      {/* Edit Modal */}
      {selectedPhrase && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full">
            <h2 className="text-xl font-bold mb-4">Edit Phrase</h2>
            <div className="space-y-4">
              <input
                type="text"
                value={selectedPhrase.tags}
                onChange={e => setSelectedPhrase({...selectedPhrase, phrase: e.target.value})}
                className="w-full p-2 border border-gray-600 rounded bg-gray-700 text-white"
                placeholder="Phrase"
              />
              <select
                value={selectedPhrase.category}
                onChange={e => setSelectedPhrase({...selectedPhrase, category: e.target.value})}
                className="w-full p-2 border border-gray-600 rounded bg-gray-700 text-white"
              >
                <option value="">Select Category</option>
                {categories.map(category => (
                  <option key={category} value={category}>{category}</option>
                ))}
              </select>
              <input
                type="text"
                value={selectedPhrase.subcategory}
                onChange={e => setSelectedPhrase({...selectedPhrase, subcategory: e.target.value})}
                className="w-full p-2 border border-gray-600 rounded bg-gray-700 text-white"
                placeholder="Subcategory"
              />
              <select
                value={selectedPhrase.difficulty}
                onChange={e => setSelectedPhrase({...selectedPhrase, difficulty: e.target.value})}
                className="w-full p-2 border border-gray-600 rounded bg-gray-700 text-white"
              >
                <option value="">Select Difficulty</option>
                {difficulties.map(difficulty => (
                  <option key={difficulty} value={difficulty}>{difficulty}</option>
                ))}
              </select>
              <input
  type="text"
  value={selectedPhrase.tags}
  onChange={e => setSelectedPhrase({...selectedPhrase, tags: e.target.value})}
  className="w-full p-2 border border-gray-600 rounded bg-gray-700 text-white"
  placeholder="Tags (comma separated)"
/>
<input
  type="text"
  value={selectedPhrase.hint}
  onChange={e => setSelectedPhrase({...selectedPhrase, hint: e.target.value})}
  className="w-full p-2 border border-gray-600 rounded bg-gray-700 text-white"
  placeholder="Hint"
/>
              <select
                value={selectedPhrase.part_of_speech}
                onChange={e => setSelectedPhrase({...selectedPhrase, part_of_speech: e.target.value})}
                className="w-full p-2 border border-gray-600 rounded bg-gray-700 text-white"
              >
                <option value="">Select Part of Speech</option>
                {partsOfSpeech.map(pos => (
                  <option key={pos} value={pos}>{pos}</option>
                ))}
              </select>
              <div className="flex justify-end gap-4">
                <button
                  onClick={() => setSelectedPhrase(null)}
                  className="px-4 py-2 text-gray-400 hover:text-gray-200"
                >
                  Cancel
                </button>
                <button
                  onClick={() => handleEditPhrase(selectedPhrase)}
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                  Save Changes
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default AdminDashboard;

============================================================

FILE: .\components\AdminNavBar.tsx
SIZE: 1.57 KB
LAST MODIFIED: 02/28/2025 15:29:32

import React from 'react';
import { supabase } from '@/lib/supabase';
import { Button } from "@/components/ui/button";
import type { Session } from '@supabase/supabase-js';

interface AdminNavBarProps {
  session: Session | null;
  setShowLoginModal: (show: boolean) => void;
}

const AdminNavBar: React.FC<AdminNavBarProps> = ({ 
  session, 
  setShowLoginModal 
}) => {
  const handleLogout = async () => {
    await supabase.auth.signOut();
    window.location.href = '/admin';
  };

  return (
    <nav className="bg-gray-800 p-6 rounded-lg shadow mb-8">
      <div className="max-w-7xl mx-auto flex justify-between items-center">
        <div className="flex items-center gap-4">
          <div className="text-white text-xl font-bold">
            Admin Dashboard
          </div>
          {session?.user && (
            <span className="text-gray-400 text-sm">
              {session.user.email}
            </span>
          )}
        </div>
        <div className="flex items-center gap-4">
          {session ? (
            <>
              <Button
                onClick={handleLogout}
                variant="destructive"
                className="hover:bg-red-700"
              >
                Logout
              </Button>
            </>
          ) : (
            <Button
              onClick={() => setShowLoginModal(true)}
              className="bg-blue-600 hover:bg-blue-700"
            >
              Login
            </Button>
          )}
        </div>
      </div>
    </nav>
  );
};

export default AdminNavBar;

============================================================

FILE: .\components\Login.tsx
SIZE: 3.09 KB
LAST MODIFIED: 02/09/2025 10:21:29

import React, { useState } from 'react';
import { supabase } from '@/lib/supabase';
import { X } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface LoginProps {
  onClose: () => void;
}

const Login: React.FC<LoginProps> = ({ onClose }) => {
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const handleLogin = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    setSuccess(false);

    try {
      const { error } = await supabase.auth.signInWithOtp({ 
        email,
        options: {
          emailRedirectTo: window.location.origin + '/admin'
        }
      });

      if (error) throw error;

      setSuccess(true);
    } catch (err) {
      console.error('Login error:', err);
      setError(
        err instanceof Error 
          ? err.message 
          : 'An unexpected error occurred'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="relative">
      <button
        onClick={onClose}
        className="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors"
      >
        <X className="h-6 w-6" />
      </button>

      <div className="p-6">
        <h2 className="text-2xl font-bold mb-6">Admin Login</h2>

        {error && (
          <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-6">
            {error}
          </div>
        )}

        {success ? (
          <div className="bg-green-900 border border-green-700 text-green-100 px-4 py-3 rounded mb-6">
            Check your email for the login link!
          </div>
        ) : (
          <form onSubmit={handleLogin} className="space-y-6">
            <div>
              <label 
                htmlFor="email"
                className="block text-sm font-medium mb-2"
              >
                Email Address
              </label>
              <input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Enter your email"
                required
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:outline-none focus:ring-2 
                         focus:ring-blue-500 focus:border-transparent"
              />
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="w-full"
            >
              {loading ? 'Sending...' : 'Send Magic Link'}
            </Button>

            <p className="text-sm text-gray-400 mt-4">
              A magic link will be sent to your email address.
              Click the link to log in to the admin dashboard.
            </p>
          </form>
        )}
      </div>
    </div>
  );
};

export default Login;

============================================================

FILE: .\components\AdminDashboard\index.tsx
SIZE: 7.82 KB
LAST MODIFIED: 02/14/2025 22:14:31

'use client'

import React, { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { AuthChangeEvent, Session } from '@supabase/supabase-js';
import type { 
  Phrase, 
  NewPhrase,
  Stats,
  Filters,
  PaginationState,
  SortConfig 
} from '@/types/types';

// Component imports
import AdminNavBar from '@/components/AdminNavBar';
import StatsSection from '@/components/stats/StatsSection';
import AddPhraseForm from '@/components/forms/AddPhraseForm';
import BulkImportForm from '@/components/forms/BulkImportForm';
import FilterControls from '@/components/filters/FilterControls';
import PhrasesTable from '@/components/table/PhrasesTable';
import CardViewModal from '@/components/modals/CardViewModal';
import Login from '@/components/Login';

// Hook imports
import { usePhrases } from '@/hooks/usePhrases';
import { usePhraseMetadata } from '@/hooks/usePhraseMetadata';
import { useStats } from '@/hooks/useStats';

// Type definitions
interface EditorState {
  showCardModal: boolean;
  currentCardIndex: number;
  isEditing: boolean;
  editedPhrase: Phrase | null;
  newIds: number[];
}

const AdminDashboard: React.FC = () => {
  // Auth State
  const [showLoginModal, setShowLoginModal] = useState<boolean>(false);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);

  // Initialize Hooks
  const {
    phrases,
    loading: phrasesLoading,
    error,
    setError,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    addPhrase,
    editPhrase,
    deletePhrase,
    fetchPhrases,
    resetFilters,
    sortByIdDesc
  } = usePhrases();

  const { 
    categories, 
    difficulties, 
    partsOfSpeech, 
    loading: metadataLoading 
  } = usePhraseMetadata();

  const { stats, loading: statsLoading } = useStats();

  // Editor State
  const [editorState, setEditorState] = useState<EditorState>({
    showCardModal: false,
    currentCardIndex: 0,
    isEditing: false,
    editedPhrase: null,
    newIds: []
  });

  // Initialize Auth
  useEffect(() => {
    const initializeAuth = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setSession(session);
      setIsLoading(false);
    };

    initializeAuth();

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event: AuthChangeEvent, session: Session | null) => {
        setSession(session);
        if (session) {
          setShowLoginModal(false);
        }
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  // Handlers
  const handleBulkImportSuccess = (importedIds: number[] = []) => {
    fetchPhrases();
    sortByIdDesc();
    setEditorState(prev => ({ ...prev, newIds: importedIds }));
    setError(null);

    if (importedIds.length > 0) {
      setTimeout(() => setEditorState(prev => ({ ...prev, newIds: [] })), 2000);
    }
  };

  const handleBulkImportError = (errorMessage: string) => {
    setError(errorMessage);
  };

  // Auth check
  const checkAuth = async (): Promise<boolean> => {
    const { data: { session } } = await supabase.auth.getSession();
    setSession(session);
    if (!session) {
      setShowLoginModal(true);
      return false;
    }
    return true;
  };

  // Card Modal Handlers
  const handleCardEdit = async () => {
    if (!(await checkAuth())) return;
    const phrase = phrases[editorState.currentCardIndex];
    if (!phrase) return;
    
    setEditorState(prev => ({
      ...prev,
      editedPhrase: phrase,
      isEditing: true
    }));
  };

  const handleCardSave = async () => {
    if (!editorState.editedPhrase) return;
    await editPhrase(editorState.editedPhrase);
    setEditorState(prev => ({
      ...prev,
      showCardModal: false,
      isEditing: false
    }));
  };

  const handleCardCancel = () => {
    setEditorState(prev => ({
      ...prev,
      editedPhrase: null,
      isEditing: false
    }));
  };

  const handleTagClick = (tag: string) => {
    handleFilterChange('searchTerm', tag);
    setEditorState(prev => ({ ...prev, showCardModal: false }));
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
        <div className="text-xl">Loading dashboard...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4 lg:p-8">
      {/* Navigation */}
      <AdminNavBar 
        session={session} 
        setShowLoginModal={setShowLoginModal} 
      />

      {/* Main Content */}
      <div className="max-w-[1920px] mx-auto">
        {/* Error Display */}
        {error && (
          <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-6">
            {error}
          </div>
        )}

        {/* Stats Section */}
        <StatsSection 
          stats={stats} 
          loading={statsLoading} 
        />

        {/* Forms Section */}
        <div className="grid grid-cols-2 gap-6 mb-8">
          <AddPhraseForm
            onAddPhrase={addPhrase}
            categories={categories}
            difficulties={difficulties}
            partsOfSpeech={partsOfSpeech}
            loading={metadataLoading}
          />
          <BulkImportForm
            onSuccess={handleBulkImportSuccess}
            onError={handleBulkImportError}
          />
        </div>

        {/* Filters */}
        <FilterControls
          filters={filters}
          onChange={handleFilterChange}
          onReset={resetFilters}
          categories={categories}
          difficulties={difficulties}
          partsOfSpeech={partsOfSpeech}
        />

        {/* Table */}
        <PhrasesTable
          phrases={phrases}
          loading={phrasesLoading}
          pagination={pagination}
          sortConfig={sortConfig}
          onSort={handleSort}
          onPageChange={handlePageChange}
          onRowsPerPageChange={handleRowsPerPageChange}
          onEdit={editPhrase}
          onDelete={deletePhrase}
          onShowCardView={() => setEditorState(prev => ({ ...prev, showCardModal: true }))}
          newIds={editorState.newIds}
        />

        {/* Modals */}
        {showLoginModal && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full">
              <Login onClose={() => setShowLoginModal(false)} />
            </div>
          </div>
        )}

        {editorState.showCardModal && (
          <CardViewModal
            isOpen={editorState.showCardModal}
            onClose={() => setEditorState(prev => ({ ...prev, showCardModal: false }))}
            phrases={phrases}
            currentIndex={editorState.currentCardIndex}
            onNavigate={(index) => setEditorState(prev => ({ ...prev, currentCardIndex: index }))}
            isEditing={editorState.isEditing}
            editedPhrase={editorState.editedPhrase}
            onEdit={handleCardEdit}
            onSave={handleCardSave}
            onCancel={handleCardCancel}
            onEditChange={(field, value) => {
              if (editorState.editedPhrase) {
                setEditorState(prev => ({
                  ...prev,
                  editedPhrase: { ...prev.editedPhrase!, [field]: value }
                }));
              }
            }}
            categories={categories}
            difficulties={difficulties}
            partsOfSpeech={partsOfSpeech}
            onTagClick={handleTagClick}
          />
        )}
      </div>
    </div>
  );
};

export default AdminDashboard;

============================================================

FILE: .\components\filters\FilterControls.tsx
SIZE: 7.78 KB
LAST MODIFIED: 02/14/2025 22:15:17

import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Search, X } from 'lucide-react';
import type { FilterControlsProps, Filters } from '@/types/types';
import { supabase } from '@/lib/supabase';

// Add interface for subcategory data
interface SubcategoryData {
  name: string;
}

const FilterControls: React.FC<FilterControlsProps> = ({
  filters,
  onChange,
  onReset,
  categories = [],
  difficulties = [],
  partsOfSpeech = [],
  loading = false
}) => {
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  // Fetch subcategories when category changes
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!filters.category) {
        setSubcategories([]);
        return;
      }

      setIsLoading(true);
      try {
        // First get category_id
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          // Then get subcategories for this category
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');

          if (subcategoryData) {
            setSubcategories(subcategoryData.map((sub: SubcategoryData) => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchSubcategories();
  }, [filters.category]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    // Reset subcategory when category changes
    if (name === 'category' && value !== filters.category) {
      onChange('subcategory', '');
    }
    onChange(name, value);
  };

  const handleSearchClear = () => {
    onChange('searchTerm', '');
  };

  const handleFilterClear = (filterName: keyof Filters) => {
    onChange(filterName, '');
  };

  // Render active filters pills
  const renderActiveFilters = () => {
    const activeFilters = Object.entries(filters).filter(([_, value]) => value);
    if (activeFilters.length === 0) return null;

    return (
      <div className="mt-4 flex flex-wrap gap-2">
        {activeFilters.map(([key, value]) => (
          <div
            key={key}
            className="flex items-center gap-1 px-2 py-1 bg-gray-700 rounded-full text-sm"
          >
            <span className="text-gray-400">
              {key === 'searchTerm' ? 'Search' : key}:
            </span>
            <span className="text-white">{value}</span>
            <button
              onClick={() => handleFilterClear(key as keyof Filters)}
              className="ml-1 text-gray-400 hover:text-white"
            >
              <X className="h-3 w-3" />
            </button>
          </div>
        ))}
      </div>
    );
  };

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow mb-8">
      <h2 className="text-xl font-semibold mb-4">Filters</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
        {/* Search Input */}
        <div className="relative">
          <label className="block text-sm font-medium mb-1">
            Search
          </label>
          <div className="relative">
            <input
              type="text"
              name="searchTerm"
              value={filters.searchTerm}
              onChange={handleChange}
              placeholder="Search phrases or tags..."
              className="w-full pl-10 pr-10 py-2 bg-gray-700 border border-gray-600 
                       rounded text-white placeholder-gray-400
                       focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <Search className="absolute left-3 top-2.5 h-5 w-5 text-gray-400" />
            {filters.searchTerm && (
              <button
                onClick={handleSearchClear}
                className="absolute right-3 top-2.5 text-gray-400 
                         hover:text-gray-300 transition-colors"
              >
                <X className="h-5 w-5" />
              </button>
            )}
          </div>
        </div>

        {/* Category Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Category
          </label>
          <select
            name="category"
            value={filters.category}
            onChange={handleChange}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Categories</option>
            {categories.map(category => (
              <option key={category} value={category}>
                {category}
              </option>
            ))}
          </select>
        </div>

        {/* Subcategory Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Subcategory
          </label>
          <select
            name="subcategory"
            value={filters.subcategory}
            onChange={handleChange}
            disabled={!filters.category || isLoading}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500 
                     disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <option value="">All Subcategories</option>
            {subcategories.map(subcategory => (
              <option key={subcategory} value={subcategory}>
                {subcategory}
              </option>
            ))}
          </select>
        </div>

        {/* Difficulty Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Difficulty
          </label>
          <select
            name="difficulty"
            value={filters.difficulty}
            onChange={handleChange}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Difficulties</option>
            {difficulties.map(difficulty => (
              <option key={difficulty} value={difficulty}>
                {difficulty}
              </option>
            ))}
          </select>
        </div>

        {/* Part of Speech Select */}
        <div>
          <label className="block text-sm font-medium mb-1">
            Part of Speech
          </label>
          <select
            name="part_of_speech"
            value={filters.part_of_speech}
            onChange={handleChange}
            className="w-full p-2 bg-gray-700 border border-gray-600 rounded 
                     text-white focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Parts of Speech</option>
            {partsOfSpeech.map(pos => (
              <option key={pos} value={pos}>
                {pos}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Filter Actions */}
      <div className="flex justify-end gap-4">
        <Button
          variant="outline"
          onClick={onReset}
          className="flex items-center gap-2"
        >
          <X className="h-4 w-4" />
          Reset Filters
        </Button>
      </div>

      {/* Active Filters */}
      {renderActiveFilters()}
    </div>
  );
};

export default FilterControls;

============================================================

FILE: .\components\forms\AddPhraseForm.tsx
SIZE: 9.54 KB
LAST MODIFIED: 02/14/2025 22:16:56

import React, { useState, useEffect } from 'react';
import { ChevronRight } from 'lucide-react';
import { Button } from '@/components/ui/button';
import type { NewPhrase, AddPhraseFormProps } from '@/types/types';
import { validateTags } from '@/utils/phraseUtils';
import { supabase } from '@/lib/supabase';

interface FormState extends NewPhrase {
  phrase: string;
  category: string;
  difficulty: string;
  subcategory: string;
  tags: string;
  hint: string;
  part_of_speech: string;
}

interface FormError {
  [key: string]: string;
}

const AddPhraseForm: React.FC<AddPhraseFormProps> = ({
  onAddPhrase,
  categories,
  difficulties,
  partsOfSpeech,
  loading
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [formState, setFormState] = useState<FormState>({
    phrase: '',
    category: '',
    difficulty: '',
    subcategory: '',
    tags: '',
    hint: '',
    part_of_speech: ''
  });

  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!formState.category) {
        setSubcategories([]);
        return;
      }

      const { data: categoryData } = await supabase
        .from('categories')
        .select('id')
        .eq('name', formState.category)
        .single();

      if (categoryData) {
        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('name')
          .eq('category_id', categoryData.id)
          .order('name');

        if (subcategoryData) {
          setSubcategories(subcategoryData.map(sub => sub.name));
        }
      }
    };

    fetchSubcategories();
  }, [formState.category]);

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    setFormState(prev => {
      if (name === 'category') {
        return { ...prev, [name]: value, subcategory: '' };
      }
      return { ...prev, [name]: value };
    });
  };

  const resetForm = () => {
    setFormState({
      phrase: '',
      category: '',
      difficulty: '',
      subcategory: '',
      tags: '',
      hint: '',
      part_of_speech: ''
    });
    setError(null);
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError(null);

    try {
      const tagValidation = validateTags(formState.tags);
      if (!tagValidation.isValid) {
        setError(tagValidation.errors?.[0] || 'Invalid tags');
        return;
      }

      await onAddPhrase(formState);
      resetForm();
      setIsExpanded(false);
    } catch (err) {
      console.error('Error adding phrase:', err);
      setError(err instanceof Error ? err.message : 'Failed to add phrase');
    }
  };

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow">
      <div 
        className="flex items-center gap-2 cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <ChevronRight 
          className={`transform transition-transform ${
            isExpanded ? 'rotate-90' : ''
          }`}
        />
        <h2 className="text-xl font-bold">Add New Phrase</h2>
      </div>

      {isExpanded && (
        <form onSubmit={handleSubmit} className="mt-6 space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Phrase Input */}
            <div>
              <label className="block text-sm font-medium mb-1">
                Phrase
              </label>
              <input
                type="text"
                name="phrase"
                value={formState.phrase}
                onChange={handleInputChange}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:ring-2 focus:ring-blue-500"
                required
                minLength={2}
                disabled={loading}
              />
            </div>

            {/* Category Select */}
            <div>
              <label className="block text-sm font-medium mb-1">
                Category
              </label>
              <select
                name="category"
                value={formState.category}
                onChange={handleInputChange}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:ring-2 focus:ring-blue-500"
                required
                disabled={loading}
              >
                <option value="">Select Category</option>
                {categories.map(category => (
                  <option key={category} value={category}>
                    {category}
                  </option>
                ))}
              </select>
            </div>

            {/* Subcategory Select */}
            <div>
              <label className="block text-sm font-medium mb-1">
                Subcategory
              </label>
              <select
                name="subcategory"
                value={formState.subcategory}
                onChange={handleInputChange}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:ring-2 focus:ring-blue-500"
                disabled={!formState.category || loading}
              >
                <option value="">Select Subcategory</option>
                {subcategories.map(subcategory => (
                  <option key={subcategory} value={subcategory}>
                    {subcategory}
                  </option>
                ))}
              </select>
            </div>

            {/* Difficulty Select */}
            <div>
              <label className="block text-sm font-medium mb-1">
                Difficulty
              </label>
              <select
                name="difficulty"
                value={formState.difficulty}
                onChange={handleInputChange}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:ring-2 focus:ring-blue-500"
                required
                disabled={loading}
              >
                <option value="">Select Difficulty</option>
                {difficulties.map(difficulty => (
                  <option key={difficulty} value={difficulty}>
                    {difficulty}
                  </option>
                ))}
              </select>
            </div>

            {/* Tags Input */}
            <div>
              <label className="block text-sm font-medium mb-1">
                Tags (comma separated)
              </label>
              <input
                type="text"
                name="tags"
                value={formState.tags}
                onChange={handleInputChange}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:ring-2 focus:ring-blue-500"
                required
                pattern="^[a-zA-Z0-9\s,]+$"
                title="Enter comma-separated tags using letters, numbers and spaces"
                disabled={loading}
              />
            </div>

            {/* Hint Input */}
            <div>
              <label className="block text-sm font-medium mb-1">
                Hint
              </label>
              <input
                type="text"
                name="hint"
                value={formState.hint}
                onChange={handleInputChange}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:ring-2 focus:ring-blue-500"
                disabled={loading}
              />
            </div>

            {/* Part of Speech Select */}
            <div>
              <label className="block text-sm font-medium mb-1">
                Part of Speech
              </label>
              <select
                name="part_of_speech"
                value={formState.part_of_speech}
                onChange={handleInputChange}
                className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                         text-white focus:ring-2 focus:ring-blue-500"
                required
                disabled={loading}
              >
                <option value="">Select Part of Speech</option>
                {partsOfSpeech.map(pos => (
                  <option key={pos} value={pos}>
                    {pos}
                  </option>
                ))}
              </select>
            </div>
          </div>

          {error && (
            <div className="bg-red-900 border border-red-700 text-red-100 
                         px-4 py-3 rounded">
              {error}
            </div>
          )}

          <div className="flex justify-end gap-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => {
                resetForm();
                setIsExpanded(false);
              }}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              disabled={loading}
            >
              {loading ? 'Adding...' : 'Add Phrase'}
            </Button>
          </div>
        </form>
      )}
    </div>
  );
};

export default AddPhraseForm;

============================================================

FILE: .\components\forms\BulkImportForm.tsx
SIZE: 10.41 KB
LAST MODIFIED: 02/14/2025 22:17:43

import React, { useState, useRef } from 'react';
import { ChevronRight, Upload } from 'lucide-react';
import { Button } from '@/components/ui/button';
import type { BulkImportFormProps, NewPhrase, ImportedPhrase } from '@/types/types';
import { supabase } from '@/lib/supabase';
import Papa from 'papaparse';

interface CategoryMap {
  [key: string]: number;
}

interface SubcategoryMap {
  [key: string]: number;
}

interface TagMap {
  [key: string]: number;
}

interface ParsedRow {
  phrase: string;
  category: string;
  difficulty: string;
  subcategory: string;
  tags: string;
  hint: string;
  part_of_speech: string;
}

const BulkImportForm: React.FC<BulkImportFormProps> = ({
  onSuccess,
  onError,
  categories = [],
  difficulties = [],
  partsOfSpeech = []
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [bulkImportText, setBulkImportText] = useState('');
  const [loading, setLoading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const processAndValidateCSV = (text: string): NewPhrase[] => {
    const result = Papa.parse<string[]>(text, {
      header: false,
      skipEmptyLines: true
    });

    if (result.errors.length > 0) {
      throw new Error(`CSV parsing error: ${result.errors[0].message}`);
    }

    return result.data.map((row: string[], index: number) => {
      if (row.length !== 7) {
        throw new Error(`Row ${index + 1}: Expected 7 fields but got ${row.length}`);
      }

      const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = row;

      if (!phrase?.trim()) throw new Error(`Row ${index + 1}: Phrase is required`);
      if (!category?.trim()) throw new Error(`Row ${index + 1}: Category is required`);
      if (!['Easy', 'Medium', 'Hard'].includes(difficulty)) {
        throw new Error(`Row ${index + 1}: Invalid difficulty value`);
      }

      return {
        phrase: phrase.trim(),
        category: category.trim(),
        difficulty: difficulty.trim(),
        subcategory: subcategory?.trim() || '',
        tags: tags?.trim() || '',
        hint: hint?.trim() || '',
        part_of_speech: part_of_speech?.trim() || ''
      };
    });
  };

  const handleBulkImport = async (text: string) => {
    if (!text?.trim()) return;
    setLoading(true);

    try {
      const phrases = processAndValidateCSV(text);
      
      // Step 1: Create/get categories and build mapping
      const categoryMap: CategoryMap = {};
      for (const phrase of phrases) {
        if (!categoryMap[phrase.category]) {
          const { data: existingCategory } = await supabase
            .from('categories')
            .select('id')
            .eq('name', phrase.category)
            .single();

          if (existingCategory) {
            categoryMap[phrase.category] = existingCategory.id;
          } else {
            const { data: newCategory } = await supabase
              .from('categories')
              .insert({ name: phrase.category })
              .select('id')
              .single();

            if (newCategory) categoryMap[phrase.category] = newCategory.id;
          }
        }
      }

      // Step 2: Create/get subcategories and build mapping
      const subcategoryMap: SubcategoryMap = {};
      for (const phrase of phrases) {
        if (phrase.subcategory && !subcategoryMap[phrase.subcategory]) {
          const categoryId = categoryMap[phrase.category];
          
          const { data: existingSubcategory } = await supabase
            .from('subcategories')
            .select('id')
            .eq('name', phrase.subcategory)
            .eq('category_id', categoryId)
            .single();

          if (existingSubcategory) {
            subcategoryMap[phrase.subcategory] = existingSubcategory.id;
          } else {
            const { data: newSubcategory } = await supabase
              .from('subcategories')
              .insert({
                name: phrase.subcategory,
                category_id: categoryId
              })
              .select('id')
              .single();

            if (newSubcategory) subcategoryMap[phrase.subcategory] = newSubcategory.id;
          }
        }
      }

      // Step 3: Create/get tags and build mapping
      const tagMap: TagMap = {};
      for (const phrase of phrases) {
        if (phrase.tags) {
          const tags = phrase.tags.split(',').map(t => t.trim());
          for (const tag of tags) {
            if (!tagMap[tag]) {
              const { data: existingTag } = await supabase
                .from('tags')
                .select('id')
                .eq('tag', tag)
                .single();

              if (existingTag) {
                tagMap[tag] = existingTag.id;
              } else {
                const { data: newTag } = await supabase
                  .from('tags')
                  .insert({ tag })
                  .select('id')
                  .single();

                if (newTag) tagMap[tag] = newTag.id;
              }
            }
          }
        }
      }

      // Step 4: Insert phrases
      const phrasesForInsert = phrases.map(phrase => ({
        phrase: phrase.phrase,
        category_id: categoryMap[phrase.category],
        subcategory_id: phrase.subcategory ? subcategoryMap[phrase.subcategory] : null,
        difficulty: phrase.difficulty,
        hint: phrase.hint || null,
        part_of_speech: phrase.part_of_speech
      }));

      const { data: insertedPhrases, error: phraseError } = await supabase
        .from('phrases')
        .insert(phrasesForInsert)
        .select('id');

      if (phraseError) throw phraseError;

      // Step 5: Create phrase-tag relationships
      if (insertedPhrases) {
        const phraseTagsToInsert = [];
        for (let i = 0; i < phrases.length; i++) {
          const phrase = phrases[i];
          const phraseId = insertedPhrases[i].id;
          
          if (phrase.tags) {
            const tags = phrase.tags.split(',').map(t => t.trim());
            for (const tag of tags) {
              phraseTagsToInsert.push({
                phrase_id: phraseId,
                tag_id: tagMap[tag]
              });
            }
          }
        }

        if (phraseTagsToInsert.length > 0) {
          await supabase
            .from('phrase_tags')
            .insert(phraseTagsToInsert);
        }
      }

      setBulkImportText('');
      onSuccess(insertedPhrases?.map(p => p.id));
    } catch (err) {
      console.error('Bulk import error:', err);
      onError(err instanceof Error ? err.message : 'Failed to import phrases');
    } finally {
      setLoading(false);
    }
  };

  const handleFileSelect = async (file: File) => {
    try {
      const text = await file.text();
      setBulkImportText(text);
    } catch (err) {
      console.error('File reading error:', err);
      onError('Failed to read file');
    }
  };

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(e.type === 'dragenter' || e.type === 'dragover');
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    const file = e.dataTransfer.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow">
      <div 
        className="flex items-center gap-2 cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <ChevronRight 
          className={`transform transition-transform ${
            isExpanded ? 'rotate-90' : ''
          }`}
        />
        <h2 className="text-xl font-bold">Bulk Import</h2>
      </div>

      {isExpanded && (
        <div className="mt-6">
          <div
            className={`relative border-2 border-dashed rounded-lg p-6
              ${dragActive 
                ? 'border-blue-500 bg-blue-500/10' 
                : 'border-gray-600'
              }`}
            onDragEnter={handleDrag}
            onDragLeave={handleDrag}
            onDragOver={handleDrag}
            onDrop={handleDrop}
          >
            <input
              ref={fileInputRef}
              type="file"
              onChange={handleFileInput}
              accept=".csv"
              className="hidden"
            />
            
            <div className="text-center">
              <Upload className="mx-auto h-12 w-12 text-gray-400" />
              <p className="mt-2 text-sm text-gray-400">
                Drag and drop a CSV file, or{' '}
                <button
                  type="button"
                  onClick={() => fileInputRef.current?.click()}
                  className="text-blue-500 hover:text-blue-400"
                >
                  browse
                </button>
              </p>
            </div>
          </div>

          <textarea
            value={bulkImportText}
            onChange={(e) => setBulkImportText(e.target.value)}
            className="w-full h-32 p-2 mt-4 bg-gray-700 border border-gray-600 
                     rounded text-white focus:ring-2 focus:ring-blue-500"
            placeholder="phrase,category,difficulty,subcategory,tags,hint,part_of_speech"
          />

          <p className="text-sm text-gray-400 mt-2">
            Format: phrase,category,difficulty,subcategory,tags,hint,part_of_speech
          </p>

          <div className="flex justify-end gap-4 mt-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => {
                setBulkImportText('');
                setIsExpanded(false);
              }}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              onClick={() => handleBulkImport(bulkImportText)}
              disabled={loading || !bulkImportText.trim()}
            >
              {loading ? 'Importing...' : 'Import Phrases'}
            </Button>
          </div>
        </div>
      )}
    </div>
  );
};

export default BulkImportForm;

============================================================

FILE: .\components\modals\CardViewModal.tsx
SIZE: 10.28 KB
LAST MODIFIED: 02/14/2025 19:48:49

import React, { useState } from 'react';
import { ChevronLeft, ChevronRight, X, Pencil, Save } from 'lucide-react';
import { Button } from '@/components/ui/button';
import TagDisplay from '@/components/shared/TagDisplay';
import { supabase } from '@/lib/supabase';
import type { CardViewModalProps, Phrase, VoteCategory } from '@/types/types';

interface FieldProps extends React.ComponentProps<'div'> {
  label: string;
  value: any;
  onChange?: (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => void;
  type?: string;
  options?: string[];
  isEditing: boolean;
  onTagClick?: (tag: string) => void;
  onVote?: (isLike: boolean) => void;
  rating?: boolean;
  showVoting?: boolean;
}

const Field: React.FC<FieldProps> = ({ 
  label, 
  value, 
  onChange, 
  type = "text", 
  options = [], 
  isEditing,
  onTagClick,
  onVote,
  rating,
  showVoting = false
}) => {
  const baseFieldClass = `mb-4 rounded-lg p-3 ${
    rating === true ? 'bg-green-900' :
    rating === false ? 'bg-red-900' :
    'bg-gray-700'
  }`;

  if (isEditing) {
    if (type === "select") {
      return (
        <div className={baseFieldClass}>
          <label className="block text-gray-400 text-sm mb-1">{label}</label>
          <select
            value={value || ""}
            onChange={onChange}
            className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 
                     focus:ring-2 focus:ring-blue-500"
          >
            <option value="">Select {label}</option>
            {options.map(opt => (
              <option key={opt} value={opt}>{opt}</option>
            ))}
          </select>
        </div>
      );
    }

    return (
      <div className={baseFieldClass}>
        <label className="block text-gray-400 text-sm mb-1">{label}</label>
        <input
          type={type}
          value={value || ""}
          onChange={onChange}
          className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 
                   focus:ring-2 focus:ring-blue-500"
        />
      </div>
    );
  }

  return (
    <div className={baseFieldClass}>
      <div className="grid grid-cols-[100px_1fr_auto] gap-3 items-center">
        <div className="text-gray-300 px-3 py-1 text-sm">
          {label}
        </div>
        <div className="px-3 py-2">
          {type === "tags" ? (
            <TagDisplay tags={value || ''} onClick={onTagClick} />
          ) : (
            <span className="text-lg text-white">{value || '-'}</span>
          )}
        </div>
        {showVoting && onVote && (
          <div className="flex gap-2 justify-end">
            <button
              onClick={() => onVote(true)}
              className={`w-8 h-8 rounded-full flex items-center justify-center ${
                rating === true ? 'bg-green-600' : 'hover:bg-gray-500'
              }`}
            >
              ðŸ‘
            </button>
            <button
              onClick={() => onVote(false)}
              className={`w-8 h-8 rounded-full flex items-center justify-center ${
                rating === false ? 'bg-red-600' : 'hover:bg-gray-500'
              }`}
            >
              ðŸ‘Ž
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

const CardViewModal: React.FC<CardViewModalProps> = ({
  isOpen,
  onClose,
  phrases,
  currentIndex,
  onNavigate,
  isEditing,
  editedPhrase,
  onEdit,
  onSave,
  onCancel,
  onEditChange,
  categories,
  difficulties,
  partsOfSpeech,
  reviewer,
  onTagClick
}) => {
  const [ratings, setRatings] = useState<Record<VoteCategory, boolean>>({});
  const [reviewCount, setReviewCount] = useState(0);

  if (!isOpen) return null;

  const displayPhrase = isEditing ? editedPhrase : phrases[currentIndex];
  if (!displayPhrase) return null;

  const handleVote = async (field: VoteCategory, isLike: boolean) => {
    if (!reviewer || !displayPhrase) return;

    try {
      const { error } = await supabase
        .from('votes')
        .insert({
          reviewer_id: reviewer.id,
          phrase_id: displayPhrase.id,
          category: field,
          vote: isLike,
          created_at: new Date().toISOString()
        });

      if (!error) {
        setRatings(prev => ({ ...prev, [field]: isLike }));
        
        // Update reviewer stats
        const { error: reviewerError } = await supabase
          .from('reviewers')
          .update({
            total_reviews: reviewer.total_reviews + 1,
            last_review_at: new Date().toISOString(),
            current_streak: reviewer.current_streak + 1
          })
          .eq('id', reviewer.id);

        if (reviewerError) {
          console.error('Error updating reviewer stats:', reviewerError);
        }
      }
    } catch (err) {
      console.error('Error recording vote:', err);
    }
  };

  const handleEditChange = (field: keyof Phrase) => (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    onEditChange(field, e.target.value);
  };

  const fieldsToRate: VoteCategory[] = ['phrase', 'hint', 'tags', 'difficulty'];
  const isFullyRated = fieldsToRate.every(field => ratings[field] !== undefined);

  const handleNext = () => {
    if (isFullyRated) {
      onNavigate(currentIndex + 1);
      setRatings({});
      setReviewCount(prev => prev + 1);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-gray-800 rounded-lg p-6 max-w-lg w-full max-h-[90vh] overflow-y-auto">
        {/* Modal Header */}
        <div className="flex justify-between items-center mb-4">
          <div>
            <h2 className="text-xl font-bold text-white">Phrase Card Review</h2>
            <span className="text-sm text-gray-400">Reviewed: {reviewCount}</span>
          </div>
          <Button variant="ghost" size="icon" onClick={onClose}>
            <X className="h-5 w-5" />
          </Button>
        </div>

        {/* Navigation */}
        <div className="flex justify-between items-center mb-4">
          <span className="text-sm text-gray-400">
            Phrase {currentIndex + 1} of {phrases.length}
          </span>
          <div className="flex gap-4">
            <Button
              onClick={() => onNavigate(Math.max(0, currentIndex - 1))}
              disabled={currentIndex === 0}
              variant="ghost"
              size="icon"
            >
              <ChevronLeft className="h-5 w-5" />
            </Button>
            <Button
              onClick={() => onNavigate(Math.min(phrases.length - 1, currentIndex + 1))}
              disabled={currentIndex === phrases.length - 1}
              variant="ghost"
              size="icon"
            >
              <ChevronRight className="h-5 w-5" />
            </Button>
          </div>
        </div>

        {/* Fields */}
        <div className="space-y-4">
          <Field
            label="Phrase"
            value={displayPhrase.phrase}
            onChange={handleEditChange('phrase')}
            isEditing={isEditing}
            onVote={!isEditing ? (isLike) => handleVote('phrase', isLike) : undefined}
            rating={ratings['phrase']}
            showVoting={!isEditing}
          />

          <Field
            label="Category"
            value={displayPhrase.category}
            onChange={handleEditChange('category')}
            type="select"
            options={categories}
            isEditing={isEditing}
          />

          <Field
            label="Difficulty"
            value={displayPhrase.difficulty}
            onChange={handleEditChange('difficulty')}
            type="select"
            options={difficulties}
            isEditing={isEditing}
            onVote={!isEditing ? (isLike) => handleVote('difficulty', isLike) : undefined}
            rating={ratings['difficulty']}
            showVoting={!isEditing}
          />

          <Field
            label="Tags"
            value={displayPhrase.tags}
            onChange={handleEditChange('tags')}
            type="tags"
            isEditing={isEditing}
            onTagClick={onTagClick}
            onVote={!isEditing ? (isLike) => handleVote('tags', isLike) : undefined}
            rating={ratings['tags']}
            showVoting={!isEditing}
          />

          <Field
            label="Hint"
            value={displayPhrase.hint}
            onChange={handleEditChange('hint')}
            isEditing={isEditing}
            onVote={!isEditing ? (isLike) => handleVote('hint', isLike) : undefined}
            rating={ratings['hint']}
            showVoting={!isEditing}
          />

          <Field
            label="Part of Speech"
            value={displayPhrase.part_of_speech}
            onChange={handleEditChange('part_of_speech')}
            type="select"
            options={partsOfSpeech}
            isEditing={isEditing}
          />
        </div>

        {/* Action Buttons */}
        {isEditing ? (
          <div className="flex justify-end gap-2 mt-6">
            <Button variant="outline" onClick={onCancel}>
              Cancel
            </Button>
            <Button onClick={onSave}>
              Save Changes
            </Button>
          </div>
        ) : (
          <div className="flex justify-between items-center mt-6">
            <Button variant="outline" onClick={onEdit}>
              <Pencil className="h-4 w-4 mr-2" />
              Edit
            </Button>
            {reviewer && (
              <div className="flex items-center gap-4">
                <span className="text-sm text-gray-400">
                  {isFullyRated ? 'All fields rated!' : 'Please rate all fields to continue'}
                </span>
                <Button
                  onClick={handleNext}
                  disabled={!isFullyRated}
                  className={!isFullyRated ? 'bg-gray-600 cursor-not-allowed' : ''}
                >
                  Next
                  <ChevronRight className="h-4 w-4 ml-2" />
                </Button>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default CardViewModal;

============================================================

FILE: .\components\modals\EditPhraseModal.tsx
SIZE: 10.39 KB
LAST MODIFIED: 02/14/2025 22:19:50

import React, { useState, useEffect } from 'react';
import { X, Save } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { supabase } from '@/lib/supabase';
import type { Phrase } from '@/types/types';

interface EditPhraseModalProps {
  phrase: Phrase;
  onChange: (updatedPhrase: Phrase) => void;
  onSave: (phrase: Phrase) => Promise<void>;
  onClose: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
}


interface FormErrors {
  [key: string]: string;
}

export const EditPhraseModal: React.FC<EditPhraseModalProps> = ({
  phrase,
  onChange,
  onSave,
  onClose,
  categories,
  difficulties,
  partsOfSpeech
}) => {
  const [subcategories, setSubcategories] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<FormErrors>({});

  // Fetch subcategories when category changes
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!phrase.category) {
        setSubcategories([]);
        return;
      }

      try {
        // Get category_id first
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', phrase.category)
          .single();

        if (categoryData) {
          // Then get subcategories for this category
          const { data: subcategoryData } = await supabase
            .from('subcategories')
            .select('name')
            .eq('category_id', categoryData.id)
            .order('name');

          if (subcategoryData) {
            setSubcategories(subcategoryData.map(sub => sub.name));
          }
        }
      } catch (err) {
        console.error('Error fetching subcategories:', err);
      }
    };

    fetchSubcategories();
  }, [phrase.category]);

  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};

    if (!phrase.phrase.trim()) {
      newErrors.phrase = 'Phrase is required';
    }

    if (!phrase.category) {
      newErrors.category = 'Category is required';
    }

    if (!phrase.difficulty) {
      newErrors.difficulty = 'Difficulty is required';
    }

    if (!phrase.part_of_speech) {
      newErrors.part_of_speech = 'Part of speech is required';
    }

    if (phrase.tags && !/^[a-zA-Z0-9\s,]+$/.test(phrase.tags)) {
      newErrors.tags = 'Tags can only contain letters, numbers, spaces, and commas';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    // Clear any existing error for this field
    setErrors(prev => ({ ...prev, [name]: '' }));

    // Reset subcategory when category changes
    if (name === 'category') {
      onChange({
        ...phrase,
        [name]: value,
        subcategory: ''
      });
    } else {
      onChange({
        ...phrase,
        [name]: value
      });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setLoading(true);
    try {
      await onSave(phrase);
      onClose();
    } catch (err) {
      console.error('Error saving phrase:', err);
      setErrors(prev => ({
        ...prev,
        submit: 'Failed to save changes. Please try again.'
      }));
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-gray-800 rounded-lg p-6 max-w-2xl w-full">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Edit Phrase</h2>
          <button 
            onClick={onClose}
            className="text-gray-400 hover:text-white transition-colors"
          >
            <X className="h-6 w-6" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Phrase Input */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Phrase
            </label>
            <input
              type="text"
              name="phrase"
              value={phrase.phrase}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.phrase ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            />
            {errors.phrase && (
              <p className="mt-1 text-sm text-red-500">{errors.phrase}</p>
            )}
          </div>

          {/* Category Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Category
            </label>
            <select
              name="category"
              value={phrase.category}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.category ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            >
              <option value="">Select Category</option>
              {categories.map(category => (
                <option key={category} value={category}>{category}</option>
              ))}
            </select>
            {errors.category && (
              <p className="mt-1 text-sm text-red-500">{errors.category}</p>
            )}
          </div>

          {/* Subcategory Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Subcategory
            </label>
            <select
              name="subcategory"
              value={phrase.subcategory || ''}
              onChange={handleChange}
              className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                     text-white focus:ring-2 focus:ring-blue-500"
              disabled={!phrase.category || loading}
            >
              <option value="">Select Subcategory</option>
              {subcategories.map(subcategory => (
                <option key={subcategory} value={subcategory}>{subcategory}</option>
              ))}
            </select>
          </div>

          {/* Difficulty Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Difficulty
            </label>
            <select
              name="difficulty"
              value={phrase.difficulty}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.difficulty ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            >
              <option value="">Select Difficulty</option>
              {difficulties.map(difficulty => (
                <option key={difficulty} value={difficulty}>{difficulty}</option>
              ))}
            </select>
            {errors.difficulty && (
              <p className="mt-1 text-sm text-red-500">{errors.difficulty}</p>
            )}
          </div>

          {/* Tags Input */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Tags (comma separated)
            </label>
            <input
              type="text"
              name="tags"
              value={phrase.tags}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.tags ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            />
            {errors.tags && (
              <p className="mt-1 text-sm text-red-500">{errors.tags}</p>
            )}
          </div>

          {/* Hint Input */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Hint
            </label>
            <input
              type="text"
              name="hint"
              value={phrase.hint || ''}
              onChange={handleChange}
              className="w-full p-2 rounded bg-gray-700 border border-gray-600 
                     text-white focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            />
          </div>

          {/* Part of Speech Select */}
          <div>
            <label className="block text-sm font-medium text-gray-400 mb-1">
              Part of Speech
            </label>
            <select
              name="part_of_speech"
              value={phrase.part_of_speech}
              onChange={handleChange}
              className={`w-full p-2 rounded bg-gray-700 border ${
                errors.part_of_speech ? 'border-red-500' : 'border-gray-600'
              } text-white focus:ring-2 focus:ring-blue-500`}
              disabled={loading}
            >
              <option value="">Select Part of Speech</option>
              {partsOfSpeech.map(pos => (
                <option key={pos} value={pos}>{pos}</option>
              ))}
            </select>
            {errors.part_of_speech && (
              <p className="mt-1 text-sm text-red-500">{errors.part_of_speech}</p>
            )}
          </div>

          {errors.submit && (
            <div className="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded">
              {errors.submit}
            </div>
          )}

          <div className="flex justify-end gap-4 mt-6">
            <Button
              type="button"
              variant="outline"
              onClick={onClose}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              disabled={loading}
              className="flex items-center gap-2"
            >
              <Save className="h-4 w-4" />
              {loading ? 'Saving...' : 'Save Changes'}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default EditPhraseModal;

============================================================

FILE: .\components\pagination\PaginationBar.tsx
SIZE: 1 KB
LAST MODIFIED: 02/09/2025 10:32:15

import React from 'react';

interface PaginationInfoProps {
  currentPage: number;
  pageSize: number;
  totalItems: number;
  className?: string;
}

const PaginationInfo: React.FC<PaginationInfoProps> = ({
  currentPage,
  pageSize,
  totalItems,
  className = ''
}) => {
  const startIndex = (currentPage - 1) * pageSize + 1;
  const endIndex = Math.min(startIndex + pageSize - 1, totalItems);

  return (
    <div className={`text-sm text-gray-400 ${className}`}>
      {totalItems === 0 ? (
        'No items'
      ) : (
        <>
          Showing{' '}
          <span className="font-medium text-white">
            {startIndex}
          </span>{' '}
          to{' '}
          <span className="font-medium text-white">
            {endIndex}
          </span>{' '}
          of{' '}
          <span className="font-medium text-white">
            {totalItems}
          </span>{' '}
          items
        </>
      )}
    </div>
  );
};

export default PaginationInfo;

============================================================

FILE: .\components\pagination\PaginationControls.tsx
SIZE: 3.22 KB
LAST MODIFIED: 02/09/2025 10:31:02

import React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface PaginationControlsProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  showPageNumbers?: boolean;
  siblingCount?: number;
  boundaryCount?: number;
}

const PaginationControls: React.FC<PaginationControlsProps> = ({
  currentPage,
  totalPages,
  onPageChange,
  showPageNumbers = true,
  siblingCount = 1,
  boundaryCount = 1
}) => {
  const getPageNumbers = () => {
    const totalNumbers = (siblingCount * 2) + 3;
    const totalBlocks = totalNumbers + 2;

    if (totalPages <= totalBlocks) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    const leftSiblingIndex = Math.max(currentPage - siblingCount, boundaryCount);
    const rightSiblingIndex = Math.min(
      currentPage + siblingCount,
      totalPages - boundaryCount
    );

    const shouldShowLeftDots = leftSiblingIndex > boundaryCount + 2;
    const shouldShowRightDots = rightSiblingIndex < totalPages - (boundaryCount + 1);

    if (!shouldShowLeftDots && shouldShowRightDots) {
      const leftItemCount = 3 + 2 * siblingCount;
      const leftRange = Array.from({ length: leftItemCount }, (_, i) => i + 1);
      return [...leftRange, '...', totalPages];
    }

    if (shouldShowLeftDots && !shouldShowRightDots) {
      const rightItemCount = 3 + 2 * siblingCount;
      const rightRange = Array.from(
        { length: rightItemCount },
        (_, i) => totalPages - rightItemCount + i + 1
      );
      return [1, '...', ...rightRange];
    }

    if (shouldShowLeftDots && shouldShowRightDots) {
      const middleRange = Array.from(
        { length: rightSiblingIndex - leftSiblingIndex + 1 },
        (_, i) => leftSiblingIndex + i
      );
      return [1, '...', ...middleRange, '...', totalPages];
    }
  };

  return (
    <div className="flex items-center justify-center gap-2">
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
        className="h-8 w-8 p-0"
      >
        <ChevronLeft className="h-4 w-4" />
      </Button>

      {showPageNumbers && getPageNumbers()?.map((page, index) => {
        if (page === '...') {
          return (
            <span 
              key={`ellipsis-${index}`}
              className="px-2 text-gray-400"
            >
              &#8230;
            </span>
          );
        }

        return (
          <Button
            key={page}
            variant={currentPage === page ? 'default' : 'outline'}
            size="sm"
            onClick={() => onPageChange(page as number)}
            className={`h-8 w-8 p-0 ${
              currentPage === page
                ? 'bg-blue-600 hover:bg-blue-700'
                : 'hover:bg-gray-700'
            }`}
          >
            {page}
          </Button>
        );
      })}

      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
        className="h-8 w-8 p-0"
      >
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
};

export default PaginationControls;

============================================================

FILE: .\components\pagination\PaginationInfo.tsx
SIZE: 1 KB
LAST MODIFIED: 02/09/2025 10:31:50

import React from 'react';

interface PaginationInfoProps {
  currentPage: number;
  pageSize: number;
  totalItems: number;
  className?: string;
}

const PaginationInfo: React.FC<PaginationInfoProps> = ({
  currentPage,
  pageSize,
  totalItems,
  className = ''
}) => {
  const startIndex = (currentPage - 1) * pageSize + 1;
  const endIndex = Math.min(startIndex + pageSize - 1, totalItems);

  return (
    <div className={`text-sm text-gray-400 ${className}`}>
      {totalItems === 0 ? (
        'No items'
      ) : (
        <>
          Showing{' '}
          <span className="font-medium text-white">
            {startIndex}
          </span>{' '}
          to{' '}
          <span className="font-medium text-white">
            {endIndex}
          </span>{' '}
          of{' '}
          <span className="font-medium text-white">
            {totalItems}
          </span>{' '}
          items
        </>
      )}
    </div>
  );
};

export default PaginationInfo;

============================================================

FILE: .\components\pagination\RowsPerPageSelect.tsx
SIZE: 1.11 KB
LAST MODIFIED: 02/09/2025 10:31:21

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';

interface RowsPerPageSelectProps {
  value: number;
  onChange: (value: number) => void;
  options?: number[];
  className?: string;
}

const RowsPerPageSelect: React.FC<RowsPerPageSelectProps> = ({
  value,
  onChange,
  options = [10, 25, 50, 100],
  className = ''
}) => {
  return (
    <div className={`flex items-center gap-2 ${className}`}>
      <span className="text-sm text-gray-400">
        Rows per page:
      </span>
      <Select
        value={value.toString()}
        onValueChange={(val) => onChange(Number(val))}
      >
        <SelectTrigger className="w-[100px] bg-gray-700 border-gray-600">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {options.map((option) => (
            <SelectItem 
              key={option} 
              value={option.toString()}
            >
              {option}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default RowsPerPageSelect;

============================================================

FILE: .\components\reviewer\CategoryFilter.tsx
SIZE: 1.06 KB
LAST MODIFIED: 02/17/2025 11:03:54

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface CategoryFilterProps {
  categories: string[];
  selectedCategory: string | null;
  onSelect: (category: string | null) => void;
}

export const CategoryFilter: React.FC<CategoryFilterProps> = ({
  categories,
  selectedCategory,
  onSelect
}) => {
  return (
    <div className="w-1/2">
      <Select 
        value={selectedCategory || "all"} 
        onValueChange={(value) => onSelect(value === "all" ? null : value)}
      >
        <SelectTrigger className="w-full bg-gray-800 border-gray-700">
          <SelectValue placeholder="Choose a Category" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">Choose a Category</SelectItem>
          {categories.map(category => (
            <SelectItem key={category} value={category}>
              {category}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default CategoryFilter;

============================================================

FILE: .\components\reviewer\Leaderboard.tsx
SIZE: 1.25 KB
LAST MODIFIED: 02/12/2025 10:08:18

// components/reviewer/Leaderboard.tsx
import React from 'react';
import { Award } from 'lucide-react';
import type { Reviewer } from '@/types/types';

interface LeaderboardProps {
  reviewers: Reviewer[];
}

const Leaderboard = ({ reviewers }: LeaderboardProps) => (
  <div className="bg-gray-800 p-4 rounded-lg mt-4">
    <div className="flex items-center gap-2 mb-4">
      <Award className="w-6 h-6 text-yellow-500" />
      <h3 className="text-lg font-bold text-white">Leaderboard</h3>
    </div>
    <div className="space-y-2">
      {reviewers
        .sort((a, b) => b.total_reviews - a.total_reviews)
        .slice(0, 5)
        .map((reviewer, index) => (
          <div
            key={reviewer.id}
            className="flex items-center justify-between p-2 rounded bg-gray-700"
          >
            <div className="flex items-center gap-2">
              <span className="text-xl">{['🥇', '🥈', '🥉', '4️⃣', '5️⃣'][index]}</span>
              <span className="text-white">{reviewer.name}</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="text-white">{reviewer.total_reviews}</span>
            </div>
          </div>
        ))}
    </div>
  </div>
);

export default Leaderboard;

============================================================

FILE: .\components\reviewer\PinPad.tsx
SIZE: 1.98 KB
LAST MODIFIED: 02/12/2025 00:51:24

// components/reviewer/PinPad.tsx
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { X } from 'lucide-react';

interface PinPadProps {
  onSubmit: (pin: string) => void;
  onCancel: () => void;
}

const PinPad = ({ onSubmit, onCancel }: PinPadProps) => {
  const [pin, setPin] = useState<string>('');
  const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '', '0', 'âŒ«'];

  const handleClick = (value: string) => {
    if (value === 'âŒ«') {
      setPin(prev => prev.slice(0, -1));
    } else if (pin.length < 4) {
      setPin(prev => prev + value);
    }
  };

  useEffect(() => {
    if (pin.length === 4) {
      onSubmit(pin);
      setPin('');
    }
  }, [pin, onSubmit]);

  return (
  <div className="flex items-center justify-center min-h-screen">
    <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm items-center justify-center">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">Enter PIN</h3>
        <Button variant="ghost" size="icon" onClick={onCancel}>
          <X className="h-5 w-5 text-white" />
        </Button>
      </div>
      
      <div className="flex justify-center mb-6">
        {[...Array(4)].map((_, i) => (
          <div
            key={i}
            className={`w-4 h-4 mx-2 rounded-full ${
              pin.length > i ? 'bg-blue-500' : 'bg-gray-600'
            }`}
          />
        ))}
      </div>

      <div className="grid grid-cols-3 gap-4">
        {numbers.map((num, index) => (
          <Button
            key={index}
            onClick={() => num && handleClick(num)}
            className={`h-16 text-2xl rounded-full text-white ${
              !num ? 'invisible' : ''
            }`}
            variant="outline"
          >
            {num}
          </Button>
        ))}
      </div>
    </div>
	</div>
  );
};

export default PinPad;

============================================================

FILE: .\components\reviewer\ReviewerCard.tsx
SIZE: 1.07 KB
LAST MODIFIED: 02/12/2025 10:06:04

// components/reviewer/ReviewerCard.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { Star } from 'lucide-react';
import type { Reviewer } from '@/types/types';

interface ReviewerCardProps {
  reviewer: Reviewer;
  avatar: string;
  onClick: () => void;
}

const ReviewerCard = ({ reviewer, avatar, onClick }: ReviewerCardProps) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    whileTap={{ scale: 0.95 }}
    className="bg-gray-800 p-4 rounded-lg cursor-pointer text-center w-full mb-8"
    onClick={onClick}
  >
    <div className="text-6xl mb-2">{avatar}</div>
    <h3 className="text-lg font-bold mb-1 text-white">{reviewer.name}</h3>
    <div className="flex items-center justify-center gap-2">
      <span className="text-sm text-gray-300">
        {reviewer.total_reviews} reviews
      </span>
      {reviewer.current_streak >= 3 && (
        <span className="text-lg">🔥</span>
      )}
      {reviewer.total_reviews >= 50 && (
        <Star className="w-4 h-4 text-yellow-500" />
      )}
    </div>
  </motion.div>
);

export default ReviewerCard;

============================================================

FILE: .\components\reviewer\ReviewerSelection.tsx
SIZE: 4.06 KB
LAST MODIFIED: 02/13/2025 11:41:10

import React, { useState, useEffect } from 'react';
import { AnimatePresence } from 'framer-motion';
import { Award } from 'lucide-react';
import ReviewerCard from './ReviewerCard';
import Leaderboard from './Leaderboard';
import PinPad from './PinPad';
import { supabase } from '@/lib/supabase';
import type { Reviewer } from '@/types/types';

const AVATARS = ['🦁', '🐯', '🐮', '🐷', '🐸', '🐙', '🦊', '🐨', '🐰', '🐼'];

interface ReviewerSelectionProps {
  onSelectReviewer: (reviewer: Reviewer) => void;
  onClose: () => void;
}

const ReviewerSelection: React.FC<ReviewerSelectionProps> = ({ 
  onSelectReviewer, 
  onClose 
}) => {
  const [selectedReviewer, setSelectedReviewer] = useState<Reviewer | null>(null);
  const [showPinPad, setShowPinPad] = useState<boolean>(false);
  const [reviewers, setReviewers] = useState<Reviewer[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchReviewers = async () => {
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });
      
      if (error) {
        console.error('Error fetching reviewers:', error);
        return;
      }
      
      if (data) {
        setReviewers(data);
      }
    };

    fetchReviewers();
  }, []);

  const handlePinSubmit = async (pin: string) => {
    if (!selectedReviewer) return;

    const { data, error } = await supabase
      .from('reviewers')
      .select('id')
      .match({ id: selectedReviewer.id, pin })
      .single();

    if (data) {
      // Handle successful login
      const now = new Date();
      const lastReview = selectedReviewer.last_review_at ? new Date(selectedReviewer.last_review_at) : null;
      
      // Calculate if streak should continue or reset
      const streakContinues = lastReview && 
        (now.getTime() - lastReview.getTime()) < (24 * 60 * 60 * 1000);
      
      const current_streak = streakContinues ? selectedReviewer.current_streak : 0;

      // Update reviewer stats
      const { error: updateError } = await supabase
        .from('reviewers')
        .update({ current_streak })
        .eq('id', selectedReviewer.id);

      if (updateError) {
        console.error('Error updating reviewer streak:', updateError);
      }

      onSelectReviewer({
        ...selectedReviewer,
        current_streak
      });
    } else {
      setError('Incorrect PIN');
      setShowPinPad(false);
      setSelectedReviewer(null);
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
      <div className="w-full max-w-4xl">
        <AnimatePresence>
          {showPinPad ? (
            <PinPad
              onSubmit={handlePinSubmit}
              onCancel={() => {
                setShowPinPad(false);
                setSelectedReviewer(null);
                setError(null);
              }}
            />
          ) : (
            <div className="text-center">
              <h2 className="text-2xl font-bold text-white mb-8">Who's reviewing?</h2>
              
              {error && (
                <div className="bg-red-900 text-red-100 p-4 rounded-lg mb-8">
                  {error}
                </div>
              )}

              <div
                className="grid gap-6 justify-items-center"
                style={{ gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))" }}
              >
                {reviewers.map((reviewer, index) => (
                  <ReviewerCard
                    key={reviewer.id}
                    reviewer={reviewer}
                    avatar={AVATARS[index % AVATARS.length]}
                    onClick={() => {
                      setSelectedReviewer(reviewer);
                      setShowPinPad(true);
                      setError(null);
                    }}
                  />
                ))}
              </div>
              
              <Leaderboard reviewers={reviewers} />
            </div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
};

export default ReviewerSelection;

============================================================

FILE: .\components\reviewer\ReviewProgress.tsx
SIZE: 0.82 KB
LAST MODIFIED: 02/17/2025 11:07:30

import React from 'react';
import { Flame } from 'lucide-react';

interface ReviewProgressProps {
  streak: number;
}

const ReviewProgress: React.FC<ReviewProgressProps> = ({ streak }) => {
  const percentage = (streak % 10) * 10; // Calculate percentage based on streak mod 10

  return (
    <div className="flex items-center gap-2 px-4 py-2 bg-gray-800 rounded-lg hover:bg-gray-700">
      <div className="text-gray-300 flex items-center gap-2 ">
       
        Review Hot Streak: {streak}
      </div>
      <div className="w-24 bg-gray-700 rounded-full h-2">
        <div
          className="bg-orange-500 h-2 rounded-full transition-all duration-300"
          style={{ width: `${percentage}%` }}
        />
      </div>
       <Flame className="w-4 h-4 text-orange-500" />
    </div>
  );
};

export default ReviewProgress;

============================================================

FILE: .\components\selects\CategorySelect.tsx
SIZE: 1.14 KB
LAST MODIFIED: 02/09/2025 10:30:14

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import type { SelectProps } from '@/types/types';

const CategorySelect: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  placeholder = "Select Category",
  required = false,
  disabled = false,
  className = ''
}) => {
  return (
    <div className={`w-full space-y-2 ${className}`}>
      <Select
        value={value}
        onValueChange={onChange}
        required={required}
        disabled={disabled}
      >
        <SelectTrigger className="w-full bg-gray-700 border-gray-600">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {!required && (
            <SelectItem value="">
              All Categories
            </SelectItem>
          )}
          {options.map((option) => (
            <SelectItem key={option} value={option}>
              {option}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default CategorySelect;

============================================================

FILE: .\components\selects\DifficultySelect.tsx
SIZE: 1.4 KB
LAST MODIFIED: 02/09/2025 10:30:23

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import type { SelectProps } from '@/types/types';

const difficultyColors = {
  Easy: 'text-green-400',
  Medium: 'text-yellow-400',
  Hard: 'text-red-400'
};

const DifficultySelect: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  placeholder = "Select Difficulty",
  required = false,
  disabled = false,
  className = ''
}) => {
  return (
    <div className={`w-full space-y-2 ${className}`}>
      <Select
        value={value}
        onValueChange={onChange}
        required={required}
        disabled={disabled}
      >
        <SelectTrigger className="w-full bg-gray-700 border-gray-600">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {!required && (
            <SelectItem value="">
              All Difficulties
            </SelectItem>
          )}
          {options.map((difficulty) => (
            <SelectItem 
              key={difficulty} 
              value={difficulty}
              className={difficultyColors[difficulty as keyof typeof difficultyColors]}
            >
              {difficulty}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DifficultySelect;

============================================================

FILE: .\components\selects\PartOfSpeechSelect.tsx
SIZE: 1.18 KB
LAST MODIFIED: 02/09/2025 10:30:30

import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import type { SelectProps } from '@/types/types';

const PartOfSpeechSelect: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  placeholder = "Select Part of Speech",
  required = false,
  disabled = false,
  className = ''
}) => {
  return (
    <div className={`w-full space-y-2 ${className}`}>
      <Select
        value={value}
        onValueChange={onChange}
        required={required}
        disabled={disabled}
      >
        <SelectTrigger className="w-full bg-gray-700 border-gray-600">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {!required && (
            <SelectItem value="">
              All Parts of Speech
            </SelectItem>
          )}
          {options.map((partOfSpeech) => (
            <SelectItem key={partOfSpeech} value={partOfSpeech}>
              {partOfSpeech}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default PartOfSpeechSelect;

============================================================

FILE: .\components\shared\LoadingSpinner.tsx
SIZE: 0.6 KB
LAST MODIFIED: 02/09/2025 10:29:05

import React from 'react';
import type { LoadingSpinnerProps } from '@/types/types';

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  size = 'medium',
  className = ''
}) => {
  const sizeClasses = {
    small: 'h-4 w-4',
    medium: 'h-8 w-8',
    large: 'h-12 w-12'
  };

  return (
    <div className={`flex justify-center items-center ${className}`}>
      <div
        className={`
          animate-spin rounded-full
          border-t-2 border-b-2 border-blue-500
          ${sizeClasses[size]}
        `}
      />
    </div>
  );
};

export default LoadingSpinner;

============================================================

FILE: .\components\shared\Select.tsx
SIZE: 0.84 KB
LAST MODIFIED: 02/08/2025 10:41:46

import React from 'react';

interface SelectProps {
  value: string | number;
  onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
  options: Array<{ value: string | number; label: string }>;
  className?: string;
  placeholder?: string;
}

export const Select: React.FC<SelectProps> = ({
  value,
  onChange,
  options,
  className = '',
  placeholder
}) => {
  return (
    <select
      value={value}
      onChange={onChange}
      className={`p-2 border rounded-md bg-white dark:bg-gray-800 dark:border-gray-700 ${className}`}
    >
      {placeholder && (
        <option value="" disabled>
          {placeholder}
        </option>
      )}
      {options.map((option) => (
        <option key={option.value} value={option.value}>
          {option.label}
        </option>
      ))}
    </select>
  );
};

============================================================

FILE: .\components\shared\StatCard.tsx
SIZE: 2.62 KB
LAST MODIFIED: 02/09/2025 15:30:45

import React from 'react';
import { useCountUp } from '@/hooks/useCountUp';
import { cn } from '@/lib/utils';

interface StatCardProps {
  title: string;
  value: number;
  prefix?: string;
  suffix?: string;
  change?: number;
  loading?: boolean;
  trend?: 'up' | 'down' | 'neutral';
  icon?: React.ReactNode;
  iconBackground?: string;
  description?: string;
  className?: string;
}

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  prefix = '',
  suffix = '',
  change,
  loading = false,
  trend,
  icon,
  iconBackground,
  description,
  className
}) => {
  const animatedValue = useCountUp(value, {
    duration: 2000
  });

  const trendColors = {
    up: 'text-green-500',
    down: 'text-red-500',
    neutral: 'text-gray-500'
  };

  if (loading) {
    return (
      <div className={cn(
        "bg-gray-800 p-6 rounded-lg shadow animate-pulse",
        className
      )}>
        <div className="h-4 bg-gray-700 rounded w-24 mb-3" />
        <div className="h-8 bg-gray-700 rounded w-32" />
      </div>
    );
  }

  return (
    <div className={cn(
      "bg-gray-800 p-6 rounded-lg shadow",
      className
    )}>
      <div className="flex justify-between">
        <div>
          <p className="text-sm font-medium text-gray-400">
            {title}
          </p>
          <div className="mt-2 flex items-baseline">
            {prefix && (
              <span className="text-xl font-semibold text-gray-300 mr-1">
                {prefix}
              </span>
            )}
            <span className="text-2xl font-bold text-white">
              {animatedValue.toLocaleString()}
            </span>
            {suffix && (
              <span className="text-xl font-semibold text-gray-300 ml-1">
                {suffix}
              </span>
            )}
          </div>
          {change !== undefined && (
            <p className={cn(
              "mt-2 flex items-center text-sm",
              trendColors[trend || 'neutral']
            )}>
              {trend === 'up' && 'â†‘'}
              {trend === 'down' && 'â†“'}
              {change > 0 && '+'}
              {change}%
            </p>
          )}
          {description && (
            <p className="mt-2 text-sm text-gray-400">
              {description}
            </p>
          )}
        </div>
        {icon && (
          <div className={cn(
            "rounded-lg p-3",
            iconBackground || 'bg-blue-500/10'
          )}>
            {icon}
          </div>
        )}
      </div>
    </div>
  );
};

export default StatCard;

============================================================

FILE: .\components\shared\TagDisplay.tsx
SIZE: 0.77 KB
LAST MODIFIED: 02/09/2025 10:28:54

import React from 'react';
import type { TagDisplayProps } from '@/types/types';

const TagDisplay: React.FC<TagDisplayProps> = ({ tags, onClick }) => {
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  return (
    <div className="flex flex-wrap gap-2">
      {tagArray.map((tag, idx) => (
        <button
          key={`${tag}-${idx}`}
          onClick={() => onClick?.(tag)}
          className={`
            px-2 py-1 text-xs rounded-full bg-gray-700
            ${onClick 
              ? 'hover:bg-gray-600 cursor-pointer' 
              : 'cursor-default'
            }
            transition-colors duration-150
          `}
        >
          {tag}
        </button>
      ))}
    </div>
  );
};

export default TagDisplay;

============================================================

FILE: .\components\stats\StatsSection.tsx
SIZE: 2.39 KB
LAST MODIFIED: 02/13/2025 12:32:44

import React from 'react';
import { useCountUp } from '@/hooks/useCountUp';
import type { StatsSectionProps } from '@/types/types';

interface StatCardProps {
  title: string;
  value: number;
  suffix?: string;
  delay?: number;
}

const StatCard: React.FC<StatCardProps> = ({ 
  title, 
  value, 
  suffix = '', 
  delay = 0 
}) => {
  const animatedValue = useCountUp(value, { 
    duration: 2000,
    delay 
  });

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow">
      <div className="text-2xl font-bold text-white">
        {animatedValue.toLocaleString()}{suffix}
      </div>
      <div className="text-gray-400">{title}</div>
    </div>
  );
};

const StatsSection: React.FC<StatsSectionProps> = ({ stats, loading }) => {
  if (loading) {
    return (
      <div className="grid grid-cols-2 md:grid-cols-5 gap-6 mb-8">
        {[...Array(5)].map((_, i) => (
          <div 
            key={i}
            className="bg-gray-800 p-6 rounded-lg shadow animate-pulse"
          >
            <div className="h-8 bg-gray-700 rounded w-24 mb-2" />
            <div className="h-4 bg-gray-700 rounded w-16" />
          </div>
        ))}
      </div>
    );
  }

  // Handle case where stats is null or undefined
  if (!stats) {
    return (
      <div className="grid grid-cols-2 md:grid-cols-5 gap-6 mb-8">
        <div className="bg-gray-800 p-6 rounded-lg shadow">
          <div className="text-2xl font-bold text-white">0</div>
          <div className="text-gray-400">No data available</div>
        </div>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-2 md:grid-cols-5 gap-6 mb-8">
      <StatCard
        title="Total Phrases"
        value={stats.total || 0}
        delay={0}
      />
      <StatCard
        title="Unique Categories"
        value={stats.uniqueCategories || 0}
        delay={100}
      />
      <StatCard
        title="Easy Phrases"
        value={stats.difficultyBreakdown?.easy || 0}
        suffix="%"
        delay={200}
      />
      <StatCard
        title="Medium Phrases"
        value={stats.difficultyBreakdown?.medium || 0}
        suffix="%"
        delay={300}
      />
      <StatCard
        title="Hard Phrases"
        value={stats.difficultyBreakdown?.hard || 0}
        suffix="%"
        delay={400}
      />
    </div>
  );
};

export default StatsSection;

============================================================

FILE: .\components\table\PhrasesTable.tsx
SIZE: 8.7 KB
LAST MODIFIED: 02/20/2025 13:30:59

import React from 'react';
import { ChevronDown, ChevronUp, Pencil, Trash2, Eye } from 'lucide-react';
import { Button } from '@/components/ui/button';
import TagDisplay from '@/components/shared/TagDisplay';
import type { PhrasesTableProps, Phrase } from '@/types/types';

const PhrasesTable: React.FC<PhrasesTableProps> = ({
  phrases = [],
  loading,
  sortConfig = { key: '', direction: 'asc' },
  pagination,
  onSort,
  onEdit,
  onDelete,
  onPageChange,
  onRowsPerPageChange,
  onShowCardView,
  newIds = []
}) => {
  const columnHeaders = [
    { key: 'id', label: 'ID' },
    { key: 'phrase', label: 'Phrase' },
    { key: 'category', label: 'Category' },
    { key: 'subcategory', label: 'Subcategory' },
    { key: 'difficulty', label: 'Difficulty' },
    { key: 'tags', label: 'Tags' },
    { key: 'hint', label: 'Hint' },
    { key: 'part_of_speech', label: 'Part of Speech' }
  ] as const;

  // Define difficulty labels
  const difficultyLabels = {
    1: 'Easy',
    2: 'Medium',
    3: 'Hard',
  };

  const handleDelete = async (id: number) => {
    if (window.confirm('Are you sure you want to delete this phrase?')) {
      await onDelete(id);
    }
  };

  if (loading) {
    return (
      <div className="bg-gray-900/50 rounded-xl shadow-xl p-8">
        <div className="text-center text-gray-400">Loading phrases...</div>
      </div>
    );
  }

  const getDifficultyColor = (difficulty: number | null | undefined) => {
    // If difficulty is null or undefined, return the default color
    if (difficulty === null || difficulty === undefined) {
      return 'bg-gray-900 text-gray-200';
    }

    // Handle numeric difficulty values
    switch (difficulty) {
      case 1: // Easy
        return 'bg-green-900 text-green-200';
      case 2: // Medium
        return 'bg-yellow-900 text-yellow-200';
      case 3: // Hard
        return 'bg-red-900 text-red-200';
      default:
        return 'bg-gray-900 text-gray-200'; // Fallback for unexpected values
    }
  };

  return (
    <div className="bg-gray-900/50 rounded-xl shadow-xl overflow-hidden">
      {/* Table Header Controls */}
      <div className="p-4 bg-gray-800 border-b border-gray-700 flex flex-wrap justify-between items-center gap-4">
        <div className="flex items-center gap-4">
          {/* Rows per page selector */}
          <select
            value={pagination.rowsPerPage}
            onChange={(e) => onRowsPerPageChange(Number(e.target.value))}
            className="bg-gray-700 text-white rounded px-2 py-1 text-sm"
          >
            {[10, 25, 50, 100].map(value => (
              <option key={value} value={value}>{value} per page</option>
            ))}
          </select>
          
          <span className="text-sm text-gray-400">
            {pagination.totalPages > 0
              ? `Page ${pagination.currentPage} of ${pagination.totalPages}`
              : 'No results'}
          </span>
        </div>

        <div className="flex gap-4">
          {/* Pagination Controls */}
          <div className="flex gap-2">
            <Button
              onClick={() => onPageChange(pagination.currentPage - 1)}
              disabled={pagination.currentPage === 1}
              variant="outline"
              size="sm"
            >
              Previous
            </Button>
            <Button
              onClick={() => onPageChange(pagination.currentPage + 1)}
              disabled={pagination.currentPage === pagination.totalPages}
              variant="outline"
              size="sm"
            >
              Next
            </Button>
          </div>

          {/* Card View Button */}
          <Button
            onClick={onShowCardView}
            variant="default"
            size="sm"
            className="flex items-center gap-2"
          >
            <Eye className="w-4 h-4" />
            Card View
          </Button>
        </div>
      </div>

      {/* Table */}
      <div className="overflow-x-auto">
        <table className="w-full table-auto text-sm">
          <thead>
            <tr className="border-b border-gray-700">
              {columnHeaders.map(({ key, label }) => (
                <th
                  key={key}
                  onClick={() => onSort(key)}
                  className="px-4 py-3 text-left text-xs font-medium text-gray-400 
                           uppercase tracking-wider bg-gray-800/80 cursor-pointer"
                >
                  <div className="flex items-center gap-2">
                    {label}
                    {sortConfig.key === key && (
                      sortConfig.direction === 'asc' 
                        ? <ChevronUp className="w-4 h-4" />
                        : <ChevronDown className="w-4 h-4" />
                    )}
                  </div>
                </th>
              ))}
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-400 
                         uppercase tracking-wider bg-gray-800/80">
                Actions
              </th>
            </tr>
          </thead>
          <tbody>
            {phrases.length === 0 ? (
              <tr>
                <td 
                  colSpan={columnHeaders.length + 1} 
                  className="px-4 py-8 text-center text-gray-400"
                >
                  No phrases found
                </td>
              </tr>
            ) : (
              phrases.map((phrase, index) => (
                <tr 
                  key={phrase.id}
                  className={`
                    border-b border-gray-700/50 
                    ${index % 2 === 0 ? 'bg-gray-800/30' : 'bg-gray-800/50'}
                    hover:bg-gray-700/50 transition-colors duration-150
                    ${newIds.includes(phrase.id) ? 'animate-flash' : ''}
                  `}
                >
                  <td className="px-4 py-3 whitespace-nowrap">{phrase.id}</td>
                  <td className="px-4 py-3 whitespace-nowrap">{phrase.phrase}</td>
                  <td className="px-4 py-3 whitespace-nowrap">{phrase.category}</td>
                  <td className="px-4 py-3 whitespace-nowrap">{phrase.subcategory || '-'}</td>
                  <td className="px-4 py-3 whitespace-nowrap">
                    <span className={`
                      px-2 py-1 rounded-full text-xs
                      ${getDifficultyColor(phrase.difficulty)}
                    `}>
                      {difficultyLabels[phrase.difficulty] || '-'}
                    </span>
                  </td>
                  <td className="px-4 py-2.5">
                    <TagDisplay tags={phrase.tags} />
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap">{phrase.hint || '-'}</td>
                  <td className="px-4 py-3 whitespace-nowrap">
                    {phrase.part_of_speech || '-'}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap">
                    <div className="flex gap-4">
                      <button
                        onClick={() => onEdit(phrase)}
                        className="text-blue-400 hover:text-blue-300 transition-colors"
                      >
                        <Pencil className="w-5 h-5" />
                      </button>
                      <button
                        onClick={() => handleDelete(phrase.id)}
                        className="text-red-400 hover:text-red-300 transition-colors"
                      >
                        <Trash2 className="w-5 h-5" />
                      </button>
                    </div>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {/* Bottom Pagination */}
      <div className="p-4 bg-gray-800 border-t border-gray-700 flex justify-between items-center">
        <span className="text-sm text-gray-400">
          {`Showing ${phrases.length} of ${pagination.totalPages * pagination.rowsPerPage} phrases`}
        </span>
        <div className="flex gap-2">
          <Button
            onClick={() => onPageChange(pagination.currentPage - 1)}
            disabled={pagination.currentPage === 1}
            variant="outline"
            size="sm"
          >
            Previous
          </Button>
          <Button
            onClick={() => onPageChange(pagination.currentPage + 1)}
            disabled={pagination.currentPage === pagination.totalPages}
            variant="outline"
            size="sm"
          >
            Next
          </Button>
        </div>
      </div>
    </div>
  );
};

export default PhrasesTable;

============================================================

FILE: .\components\ui\alert.tsx
SIZE: 2.23 KB
LAST MODIFIED: 02/09/2025 10:34:20

import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-gray-800 border-gray-700 text-white",
        destructive: "border-red-700 bg-red-900/50 text-red-100 [&>svg]:text-red-100",
        success: "border-green-700 bg-green-900/50 text-green-100 [&>svg]:text-green-100",
        warning: "border-yellow-700 bg-yellow-900/50 text-yellow-100 [&>svg]:text-yellow-100",
        info: "border-blue-700 bg-blue-900/50 text-blue-100 [&>svg]:text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> &
    VariantProps<typeof alertVariants> & {
      onClose?: () => void;
    }
>(({ className, variant, children, onClose, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  >
    {children}
    {onClose && (
      <button
        onClick={onClose}
        className="absolute top-4 right-4 p-1 rounded-full hover:bg-gray-700/50 transition-colors"
        aria-label="Close alert"
      >
        <X className="h-4 w-4" />
      </button>
    )}
  </div>
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

============================================================

FILE: .\components\ui\button.tsx
SIZE: 1.69 KB
LAST MODIFIED: 02/09/2025 10:32:42

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-blue-500 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-blue-600 text-white hover:bg-blue-700",
        destructive: "bg-red-600 text-white hover:bg-red-700",
        outline: "border border-gray-600 bg-transparent hover:bg-gray-700 hover:text-white",
        secondary: "bg-gray-600 text-white hover:bg-gray-700",
        ghost: "hover:bg-gray-700 hover:text-white",
        link: "text-blue-500 underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };

============================================================

FILE: .\components\ui\dialog.tsx
SIZE: 4.78 KB
LAST MODIFIED: 02/09/2025 15:31:45

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-700 bg-gray-800 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-gray-800 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-gray-700 data-[state=open]:text-gray-400">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-400", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

/* Example usage:
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function DialogDemo() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="outline">Edit Profile</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit profile</DialogTitle>
          <DialogDescription>
            Make changes to your profile here.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          Form content here
        </div>
        <DialogFooter>
          <Button type="submit">Save changes</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
*/

============================================================

FILE: .\components\ui\modal.tsx
SIZE: 3.93 KB
LAST MODIFIED: 02/09/2025 10:34:53

import * as React from "react";
import { X } from "lucide-react";
import { Button } from "./button";
import { cn } from "@/lib/utils";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: React.ReactNode;
  children: React.ReactNode;
  footer?: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  className?: string;
  showClose?: boolean;
  closeOnOverlayClick?: boolean;
}

const sizeClasses = {
  sm: 'max-w-sm',
  md: 'max-w-md',
  lg: 'max-w-lg',
  xl: 'max-w-xl',
  full: 'max-w-full mx-4'
};

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  size = 'md',
  className,
  showClose = true,
  closeOnOverlayClick = true,
}) => {
  // Handle ESC key
  React.useEffect(() => {
    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener('keydown', handleEsc);
    }
    return () => {
      document.removeEventListener('keydown', handleEsc);
    };
  }, [isOpen, onClose]);

  // Prevent body scroll when modal is open
  React.useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50"
      onClick={closeOnOverlayClick ? onClose : undefined}
    >
      <div
        className={cn(
          "relative bg-gray-800 rounded-lg shadow-xl w-full",
          sizeClasses[size],
          className
        )}
        onClick={e => e.stopPropagation()}
      >
        {/* Header */}
        {(title || showClose) && (
          <div className="flex items-center justify-between p-4 border-b border-gray-700">
            {title && (
              <h2 className="text-lg font-semibold text-white">
                {title}
              </h2>
            )}
            {showClose && (
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 rounded-full"
                onClick={onClose}
                aria-label="Close modal"
              >
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
        )}

        {/* Content */}
        <div className="p-4">
          {children}
        </div>

        {/* Footer */}
        {footer && (
          <div className="flex justify-end gap-2 p-4 border-t border-gray-700">
            {footer}
          </div>
        )}
      </div>
    </div>
  );
};

// Utility components for Modal
export const ModalTitle: React.FC<React.HTMLAttributes<HTMLHeadingElement>> = ({
  children,
  className,
  ...props
}) => (
  <h2
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  >
    {children}
  </h2>
);

export const ModalDescription: React.FC<React.HTMLAttributes<HTMLParagraphElement>> = ({
  children,
  className,
  ...props
}) => (
  <p
    className={cn("text-sm text-gray-400", className)}
    {...props}
  >
    {children}
  </p>
);

export const ModalFooter: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({
  children,
  className,
  ...props
}) => (
  <div
    className={cn(
      "flex justify-end gap-2",
      className
    )}
    {...props}
  >
    {children}
  </div>
);

// Example usage:
/*
<Modal
  isOpen={isOpen}
  onClose={onClose}
  title="Modal Title"
  footer={
    <>
      <Button variant="outline" onClick={onClose}>
        Cancel
      </Button>
      <Button onClick={handleConfirm}>
        Confirm
      </Button>
    </>
  }
>
  <p>Modal content goes here</p>
</Modal>
*/

============================================================

FILE: .\components\ui\select.tsx
SIZE: 4.36 KB
LAST MODIFIED: 02/09/2025 10:33:05

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";
import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;
const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-white placeholder:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 min-w-[8rem] overflow-hidden rounded-md border border-gray-600 bg-gray-700 text-white shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-gray-600 focus:text-white data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-gray-600", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
};

============================================================

FILE: .\components\ui\toast.tsx
SIZE: 4.88 KB
LAST MODIFIED: 02/09/2025 10:39:17

import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border-gray-700 bg-gray-800 text-white",
        destructive: "destructive group border-red-700 bg-red-900 text-red-100",
        success: "border-green-700 bg-green-900 text-green-100",
        warning: "border-yellow-700 bg-yellow-900 text-yellow-100",
        info: "border-blue-700 bg-blue-900 text-blue-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-gray-700 bg-transparent px-3 text-sm font-medium transition-colors hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-red-700 group-[.destructive]:hover:border-red-600 group-[.destructive]:hover:bg-red-600 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-white/50 opacity-0 transition-opacity hover:text-white focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

============================================================

FILE: .\components\ui\toaster.tsx
SIZE: 1.3 KB
LAST MODIFIED: 02/09/2025 10:39:36

import {
    Toast,
    ToastClose,
    ToastDescription,
    ToastProvider,
    ToastTitle,
    ToastViewport,
  } from "@/components/ui/toast";
  import { useToast } from "@/hooks/useToast";
  
  export function Toaster() {
    const { toasts } = useToast();
  
    return (
      <ToastProvider>
        {toasts.map(function ({ id, title, description, action, ...props }) {
          return (
            <Toast key={id} {...props}>
              <div className="grid gap-1">
                {title && <ToastTitle>{title}</ToastTitle>}
                {description && (
                  <ToastDescription>{description}</ToastDescription>
                )}
              </div>
              {action}
              <ToastClose />
            </Toast>
          );
        })}
        <ToastViewport />
      </ToastProvider>
    );
  }
  
  // Example usage:
  /*
  import { useToast } from '@/hooks/useToast';
  
  function MyComponent() {
    const { toast } = useToast();
    
    const showToast = () => {
      toast({
        title: "Success!",
        description: "Your action was completed successfully.",
        variant: "success", // or "default", "destructive", "warning", "info"
      });
    };
  
    return <button onClick={showToast}>Show Toast</button>;
  }
  */

============================================================

FILE: .\hooks\useCountUp.ts
SIZE: 1.99 KB
LAST MODIFIED: 02/09/2025 15:34:10

import { useState, useEffect, useRef } from 'react';

interface UseCountUpOptions {
  duration?: number;
  delay?: number;
  easing?: (t: number) => number;
  enabled?: boolean;
}

// Default easing function (easeOutExpo)
const easeOutExpo = (t: number): number => {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
};

export const useCountUp = (
  endValue: number,
  {
    duration = 2000,
    delay = 0,
    easing = easeOutExpo,
    enabled = true
  }: UseCountUpOptions = {}
): number => {
  const [count, setCount] = useState<number>(0);
  const frameRef = useRef<number | undefined>(undefined);
  const startTimeRef = useRef<number | null>(null);
  const endValueRef = useRef<number>(endValue);

  useEffect(() => {
    endValueRef.current = endValue;
  }, [endValue]);

  useEffect(() => {
    if (!enabled) {
      setCount(endValue);
      return;
    }

    // Clear any existing animation
    if (frameRef.current) {
      cancelAnimationFrame(frameRef.current);
    }

    const timeout = setTimeout(() => {
      const animate = (currentTime: number) => {
        if (startTimeRef.current === null) {
          startTimeRef.current = currentTime;
        }

        const elapsed = currentTime - startTimeRef.current;
        const progress = Math.min(elapsed / duration, 1);
        const easedProgress = easing(progress);
        
        setCount(Math.round(easedProgress * endValueRef.current));

        if (progress < 1) {
          frameRef.current = requestAnimationFrame(animate);
        }
      };

      frameRef.current = requestAnimationFrame(animate);
    }, delay);

    // Cleanup function
    return () => {
      clearTimeout(timeout);
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
    };
  }, [duration, delay, easing, enabled]);

  // If animation is disabled, return end value directly
  if (!enabled) {
    return endValue;
  }

  return count;
};

export default useCountUp;

============================================================

FILE: .\hooks\usePhraseMetadata.ts
SIZE: 2.38 KB
LAST MODIFIED: 02/13/2025 11:38:54

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';

interface PhraseMetadata {
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
  error: string | null;
}

interface CategoryRecord {
  name: string;
}

interface PartOfSpeechRecord {
  part_of_speech: string;
}

export const usePhraseMetadata = (): PhraseMetadata => {
  const [categories, setCategories] = useState<string[]>([]);
  const [difficulties, setDifficulties] = useState<string[]>([]);
  const [partsOfSpeech, setPartsOfSpeech] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchMetadata = async () => {
      setLoading(true);
      setError(null);
      
      try {
        // Fetch categories
        const { data: categoryData, error: categoryError } = await supabase
          .from('categories')
          .select('name')
          .order('name');

        if (categoryError) throw categoryError;

        // Fetch parts of speech from phrases
        const { data: posData, error: posError } = await supabase
          .from('phrases')
          .select('part_of_speech')
          .not('part_of_speech', 'is', null);

        if (posError) throw posError;

        // Process categories
        const uniqueCategories = Array.from(
          new Set((categoryData as CategoryRecord[]).map(record => record.name))
        );

        // Process parts of speech
        const uniquePartsOfSpeech = Array.from(
          new Set((posData as PartOfSpeechRecord[])
            .map(record => record.part_of_speech)
            .filter(Boolean))
        ).sort();

        // Set predefined difficulties
        const difficultyLevels = ['Easy', 'Medium', 'Hard'];

        setCategories(uniqueCategories);
        setDifficulties(difficultyLevels);
        setPartsOfSpeech(uniquePartsOfSpeech);
      } catch (err) {
        console.error('Error fetching metadata:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch metadata');
      } finally {
        setLoading(false);
      }
    };

    fetchMetadata();
  }, []);

  return {
    categories,
    difficulties,
    partsOfSpeech,
    loading,
    error
  };
};

export default usePhraseMetadata;

============================================================

FILE: .\hooks\usePhrases.ts
SIZE: 5.3 KB
LAST MODIFIED: 02/16/2025 18:09:57

// hooks/usePhrases.ts

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '../lib/supabase'
import type { Phrase, PaginationState, SortConfig, Filters } from '@/types/types';

export const usePhrases = () => {
  const [phrases, setPhrases] = useState<Phrase[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [pagination, setPagination] = useState<PaginationState>({
    currentPage: 1,
    rowsPerPage: 20,
    totalPages: 1
  });

  const [sortConfig, setSortConfig] = useState<SortConfig>({
    key: '',
    direction: 'asc'
  });

  const [filters, setFilters] = useState<Filters>({
    searchTerm: '',
    category: '',
    difficulty: '',
    subcategory: '',
    part_of_speech: ''
  });

  const fetchPhrases = useCallback(async () => {
    try {
      setLoading(true);
      let query = supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id(id, name),
          subcategories:subcategory_id(id, name),
          phrase_tags!inner(
            tags(id, tag)
          )
        `, { count: 'exact' });

      // Apply filters
      if (filters.category) {
        // First get the category id
        const { data: categoryData } = await supabase
          .from('categories')
          .select('id')
          .eq('name', filters.category)
          .single();

        if (categoryData) {
          query = query.eq('category_id', categoryData.id);
        }
      }

      if (filters.difficulty) {
        query = query.eq('difficulty', filters.difficulty);
      }

      if (filters.subcategory) {
        const { data: subcategoryData } = await supabase
          .from('subcategories')
          .select('id')
          .eq('name', filters.subcategory)
          .single();

        if (subcategoryData) {
          query = query.eq('subcategory_id', subcategoryData.id);
        }
      }

      if (filters.part_of_speech) {
        query = query.eq('part_of_speech', filters.part_of_speech);
      }

      if (filters.searchTerm) {
        query = query.or(`phrase.ilike.%${filters.searchTerm}%`);
      }

      // Apply sorting
      if (sortConfig.key) {
        query = query.order(sortConfig.key, {
          ascending: sortConfig.direction === 'asc',
          nullsFirst: false
        });
      } else {
        // Default sort
        query = query.order('id', { ascending: false });
      }

      // Apply pagination
      const start = (pagination.currentPage - 1) * pagination.rowsPerPage;
      const end = start + pagination.rowsPerPage - 1;
      query = query.range(start, end);

      const { data, error: supabaseError, count } = await query as SupabaseQueryResponse<PhraseWithRelations>;

      if (supabaseError) throw supabaseError;

      // Transform the data
      const transformedData = data?.map(item => ({
        ...item,
        category: item.categories?.name || '',
        subcategory: item.subcategories?.name || '',
        tags: item.phrase_tags
          ?.map((pt: any) => pt.tags.tag)
          .filter(Boolean)
          .join(',') || ''
      }));

      setPhrases(transformedData || []);
      
      if (count !== null) {
        setPagination(prev => ({
          ...prev,
          totalPages: Math.ceil(count / prev.rowsPerPage)
        }));
      }
    } catch (err) {
      console.error('Error fetching phrases:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch phrases');
    } finally {
      setLoading(false);
    }
  }, [filters, sortConfig, pagination.currentPage, pagination.rowsPerPage]);

  // Fetch categories for the filter
  const fetchCategories = async () => {
    try {
      const { data, error } = await supabase
        .from('categories')
        .select('name')
        .order('name');

      if (error) throw error;
      return data?.map(cat => cat.name) || [];
    } catch (err) {
      console.error('Error fetching categories:', err);
      return [];
    }
  };

  const handleFilterChange = (name: string, value: string) => {
    setFilters(prev => ({ ...prev, [name]: value }));
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const resetFilters = () => {
    setFilters({
      searchTerm: '',
      category: '',
      difficulty: '',
      subcategory: '',
      part_of_speech: ''
    });
    setPagination(prev => ({ ...prev, currentPage: 1 }));
  };

  const handleSort = (key: keyof Phrase) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };

  const handlePageChange = (page: number) => {
    setPagination(prev => ({ ...prev, currentPage: page }));
  };

  const handleRowsPerPageChange = (rowsPerPage: number) => {
    setPagination(prev => ({
      ...prev,
      rowsPerPage,
      currentPage: 1
    }));
  };

  useEffect(() => {
    fetchPhrases();
  }, [fetchPhrases]);

  return {
    phrases,
    loading,
    error,
    pagination,
    sortConfig,
    filters,
    handleSort,
    handlePageChange,
    handleRowsPerPageChange,
    handleFilterChange,
    resetFilters,
    fetchCategories,
    fetchPhrases,
    setError
  };
};

============================================================

FILE: .\hooks\useReviewers.ts
SIZE: 0.94 KB
LAST MODIFIED: 02/11/2025 23:49:03

// hooks/useReviewers.ts
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { Reviewer } from '@/types/types';

export const useReviewers = () => {
  const [reviewers, setReviewers] = useState<Reviewer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchReviewers = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('reviewers')
        .select('*')
        .order('total_reviews', { ascending: false });

      if (error) throw error;
      setReviewers(data || []);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to fetch reviewers'));
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchReviewers();
  }, []);

  return { reviewers, loading, error, refetch: fetchReviewers };
};

============================================================

FILE: .\hooks\useReviewProgress.ts
SIZE: 1.17 KB
LAST MODIFIED: 02/12/2025 00:20:31

import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";
import type { Reviewer } from "@/types/types";

interface ReviewProgress {
  reviewed: number;
  remaining: number;
  streak: number;
}

export const useReviewProgress = (
  reviewer: Reviewer | null,
  totalPhrases: number
): ReviewProgress => {
  const [progress, setProgress] = useState<ReviewProgress>({
    reviewed: 0,
    remaining: 0,
    streak: 0,
  });

  useEffect(() => {
    if (!reviewer) return;

    const fetchProgress = async () => {
      try {
        // Get count of reviewed phrases
        const { count: reviewedCount } = await supabase
          .from("votes")
          .select("phrase_id", { count: "exact", distinct: true })
          .eq("reviewer_id", reviewer.id);

        setProgress({
          reviewed: reviewedCount || 0,
          remaining: totalPhrases - (reviewedCount || 0),
          streak: reviewer.current_streak || 0,
        });
      } catch (error) {
        console.error("Error fetching review progress:", error);
        // Keep the current progress state on error
      }
    };

    fetchProgress();
  }, [reviewer, totalPhrases]);

  return progress;
};


============================================================

FILE: .\hooks\useStats.ts
SIZE: 2.83 KB
LAST MODIFIED: 02/13/2025 12:35:35

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/supabase';
import type { Stats, Phrase } from '@/types/types';

interface UseStatsReturn {
  stats: Stats;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const useStats = (): UseStatsReturn => {
  const [stats, setStats] = useState<Stats>({
    total: 0,
    uniqueCategories: 0,
    difficultyBreakdown: {
      easy: 0,
      medium: 0,
      hard: 0,
    },
  });

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const calculateStats = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const { data: phrases, error: fetchError, count } = await supabase
        .from('phrases')
        .select(`
          *,
          categories:category_id (name)
        `, { count: 'exact' });

      if (fetchError) throw fetchError;
      if (!phrases) throw new Error('No data received');

      // Calculate unique categories
      const uniqueCategories = new Set(phrases.map((p) => p.categories?.name)).size;

      // Map difficulty numbers to labels
      const difficultyLabels = {
        1: 'easy',
        2: 'medium',
        3: 'hard',
      };

      // Calculate difficulty breakdown
      const difficultyCount = phrases.reduce((acc: Record<string, number>, phrase) => {
        const difficultyLabel = difficultyLabels[phrase.difficulty] || 'unknown';
        acc[difficultyLabel] = (acc[difficultyLabel] || 0) + 1;
        return acc;
      }, {});

      const total = count || phrases.length;

      // Calculate percentages
      let easy = Math.round(((difficultyCount['easy'] || 0) / total) * 100);
      let medium = Math.round(((difficultyCount['medium'] || 0) / total) * 100);
      let hard = Math.round(((difficultyCount['hard'] || 0) / total) * 100);

      // Adjust for rounding errors
      const sum = easy + medium + hard;
      if (sum !== 100) {
        const diff = 100 - sum;
        if (easy >= medium && easy >= hard) {
          easy += diff;
        } else if (medium >= easy && medium >= hard) {
          medium += diff;
        } else {
          hard += diff;
        }
      }

      setStats({
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard,
        },
      });
    } catch (err) {
      console.error('Error calculating stats:', err);
      setError(err instanceof Error ? err.message : 'Failed to calculate stats');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    calculateStats();
  }, [calculateStats]);

  return {
    stats,
    loading,
    error,
    refetch: calculateStats,
  };
};

export default useStats;

============================================================

FILE: .\hooks\useToast.ts
SIZE: 3.94 KB
LAST MODIFIED: 02/09/2025 10:40:35

import * as React from "react";
import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_VALUE;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }

    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
    
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

export const useToast = () => {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
};

export { toast };
export type { Toast };

============================================================

FILE: .\lib\claudeService.ts
SIZE: 5.93 KB
LAST MODIFIED: 02/28/2025 15:29:32

// src/lib/claudeService.ts
'use client';

export interface GenerateTagsResponse {
  tags: string[];
  error?: string;
}

export interface GenerateHintResponse {
  hint: string;
  error?: string;
}

// src/lib/claudeService.ts
const makeClaudeRequest = async (messages: Array<{ role: string; content: string }>) => {
  console.log('Attempting API request with messages:', messages);
  try {
    const response = await fetch('/api/claude', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ messages })
    });
    console.log('Response status:', response.status);
    if (!response.ok) {
      const errorText = await response.text();
      console.log('Error response text:', errorText);
      throw new Error(`API request failed: ${response.status} - ${errorText}`);
    }
    return await response.json();
  } catch (error) {
    console.error('Request error details:', error);
    throw error;
  }
};

export const generateTags = async (phrase: string, currentHint: string = ''): Promise<GenerateTagsResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Generate exactly 3 descriptive tags for this catch phrase: "${phrase}"
                Current hint (for reference): "${currentHint}"

                Strict Rules for Tag Generation:
                1. Generate EXACTLY 3 tags
                2. Each tag must be a SINGLE word (no spaces, hyphens, or special characters)
                3. Each tag must be 16 characters or less
                4. Each tag must start with a capital letter
                5. Tags must be DIRECTLY related to the meaning, theme, or context of the phrase
                6. Tags MUST NOT contain any words from the phrase or the hint
                7. Tags must be distinct in meaning (no synonyms between tags)
                8. Tags should be specific and meaningful (avoid generic terms)
                
                Return exactly 3 tags separated by commas, nothing else.
                Example format for "Laser Hair Removal": MedSpa,Aesthetics,Grooming`
    }]);

    const tagsString = data.content[0].text.trim();
    const tags = tagsString
      .split(',')
      .map((tag: string) => tag.trim())
      .filter(Boolean); // Remove empty strings

    // Validate number of tags
    if (tags.length !== 3) {
      throw new Error(`Expected 3 tags, got ${tags.length}`);
    }

    // Validate each tag
    tags.forEach((tag: string, index: number) => {
      if (tag.length > 16) {
        throw new Error(`Tag ${index + 1} exceeds 16 characters: ${tag}`);
      }
      if (!/^[A-Z][a-zA-Z]*$/.test(tag)) {
        throw new Error(`Tag ${index + 1} has invalid format: ${tag}`);
      }
      if (phrase.toLowerCase().includes(tag.toLowerCase())) {
        throw new Error(`Tag ${index + 1} contains words from phrase: ${tag}`);
      }
      if (currentHint && currentHint.toLowerCase().includes(tag.toLowerCase())) {
        throw new Error(`Tag ${index + 1} contains words from hint: ${tag}`);
      }
    });

    return { tags };
  } catch (error) {
    console.error('Error generating tags:', error);
    return {
      tags: [],
      error: error instanceof Error ? error.message : 'Failed to generate tags'
    };
  }
};

export const generateHint = async (phrase: string): Promise<GenerateHintResponse> => {
  try {
    const data = await makeClaudeRequest([{
      role: 'user',
      content: `Create a clever hint for the catch phrase: "${phrase}"

                Strict Rules for Hint Generation:
                1. CRITICAL: Total length INCLUDING SPACES must be 18 or fewer characters
                2. Must be EXACTLY 3 short words
                3. Each word MUST start with a capital letter
                4. MUST NOT contain any words from the phrase
                5. Must be clever and indirect (no obvious synonyms)
                6. Should guide players toward the concept
                7. Keep words very short to meet character limit
                8. Count spaces in the 18-character limit
                
                Return only the 3-word hint with proper capitalization, nothing else.
                Valid Examples (note character counts):
                - For "Laser Hair Removal": "Spa Fix Beauty" (12 chars)
                - For "Mountain Climbing": "Up High Peak" (11 chars)
                - For "Birthday Party": "Fun Cake Day" (11 chars)
                
                Remember: Total characters (with spaces) MUST be 18 or less!`
    }]);

    let hint = data.content[0].text.trim();

    // Remove any punctuation that might have been added
    hint = hint.replace(/[.,!?]$/, '').trim();

    // Validate hint format
    const words = hint.split(' ').filter(Boolean); // Remove empty strings

    // Detailed validation with specific error messages
    if (words.length !== 3) {
      throw new Error(`Expected 3 words, got ${words.length}: "${hint}"`);
    }

    if (hint.length > 18) {
      throw new Error(`Hint exceeds 18 characters: "${hint}" (${hint.length} chars)`);
    }

    const invalidWords = words.filter(word => !/^[A-Z][a-zA-Z]*$/.test(word));
    if (invalidWords.length > 0) {
      throw new Error(`Invalid word format: ${invalidWords.join(', ')}`);
    }

    const phraseWords = phrase.toLowerCase().split(' ');
    const conflictingWords = words.filter(word => 
      phraseWords.some(phraseWord => 
        phraseWord.toLowerCase() === word.toLowerCase()
      )
    );
    
    if (conflictingWords.length > 0) {
      throw new Error(`Hint contains words from phrase: ${conflictingWords.join(', ')}`);
    }

    return { hint };
  } catch (error) {
    console.error('Error generating hint:', error);
    return {
      hint: '',
      error: error instanceof Error ? 
        error.message : 
        'Failed to generate hint'
    };
  }
};

============================================================

FILE: .\lib\supabase.ts
SIZE: 0.55 KB
LAST MODIFIED: 02/18/2025 10:42:19

import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/supabase'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  }
})

export const checkAuth = async () => {
  if (typeof window === 'undefined') {
    return null
  }
  const { data: { session } } = await supabase.auth.getSession()
  return session
}

============================================================

FILE: .\lib\utils.ts
SIZE: 2.73 KB
LAST MODIFIED: 02/09/2025 10:12:53

import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Combines class names using clsx and tailwind-merge
 */
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

/**
 * Formats a number with commas for thousands
 */
export function formatNumber(num: number): string {
  return num.toLocaleString('en-US');
}

/**
 * Formats a date string to localized format
 */
export function formatDate(date: string | Date): string {
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
}

/**
 * Debounces a function
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Validates an email address
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Capitalizes the first letter of a string
 */
export function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Truncates a string to a specified length
 */
export function truncateString(str: string, length: number): string {
  if (str.length <= length) return str;
  return str.slice(0, length) + '...';
}

/**
 * Creates a range of numbers
 */
export function range(start: number, end: number): number[] {
  return Array.from({ length: end - start + 1 }, (_, i) => start + i);
}

/**
 * Generates a random string
 */
export function generateId(length: number = 8): string {
  return Math.random().toString(36).substring(2, length + 2);
}

/**
 * Deep clones an object
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Checks if an object is empty
 */
export function isEmpty(obj: Record<string, any>): boolean {
  return Object.keys(obj).length === 0;
}

/**
 * Filters out nullish values from an array
 */
export function compact<T>(array: T[]): NonNullable<T>[] {
  return array.filter((item): item is NonNullable<T> => item != null);
}

/**
 * Groups an array by a key
 */
export function groupBy<T>(array: T[], key: keyof T): Record<string, T[]> {
  return array.reduce((groups, item) => {
    const groupKey = String(item[key]);
    groups[groupKey] = groups[groupKey] || [];
    groups[groupKey].push(item);
    return groups;
  }, {} as Record<string, T[]>);
}

============================================================

FILE: .\types\supabase.ts
SIZE: 3.57 KB
LAST MODIFIED: 02/16/2025 18:12:15

// src/types/supabase.ts
export type Database = {
  public: {
    Tables: {
      phrases: {
        Row: {
          id: number
          phrase: string | null
          part_of_speech: string | null
          hint: string | null
          category_id: number | null
          subcategory_id: number | null
          difficulty: number | null
        }
        Insert: {
          id?: number
          phrase?: string | null
          part_of_speech?: string | null
          hint?: string | null
          category_id?: number | null
          subcategory_id?: number | null
          difficulty?: number | null
        }
        Update: {
          id?: number
          phrase?: string | null
          part_of_speech?: string | null
          hint?: string | null
          category_id?: number | null
          subcategory_id?: number | null
          difficulty?: number | null
        }
      }
      categories: {
        Row: {
          id: number
          name: string
        }
        Insert: {
          id?: number
          name: string
        }
        Update: {
          id?: number
          name?: string
        }
      }
      subcategories: {
        Row: {
          id: number
          name: string
          category_id: number | null
        }
        Insert: {
          id?: number
          name: string
          category_id?: number | null
        }
        Update: {
          id?: number
          name?: string
          category_id?: number | null
        }
      }
      tags: {
        Row: {
          id: number
          tag: string
        }
        Insert: {
          id?: number
          tag: string
        }
        Update: {
          id?: number
          tag?: string
        }
      }
      phrase_tags: {
        Row: {
          phrase_id: number
          tag_id: number
        }
        Insert: {
          phrase_id: number
          tag_id: number
        }
        Update: {
          phrase_id?: number
          tag_id?: number
        }
      }
      votes: {
        Row: {
          id: string // uuid
          reviewer_id: string // uuid
          phrase_id: number
          category: string // USER-DEFINED type
          vote: boolean
          created_at: string // timestamp with time zone
        }
        Insert: {
          id?: string
          reviewer_id: string
          phrase_id: number
          category: string
          vote: boolean
          created_at?: string
        }
        Update: {
          id?: string
          reviewer_id?: string
          phrase_id?: number
          category?: string
          vote?: boolean
          created_at?: string
        }
      }
      reviewers: {
        Row: {
          id: string // uuid
          name: string
          total_reviews: number | null
          created_at: string // timestamp with time zone
          pin: string
          last_review_at: string | null // timestamp with time zone
          current_streak: number | null
        }
        Insert: {
          id?: string
          name: string
          total_reviews?: number | null
          created_at?: string
          pin?: string
          last_review_at?: string | null
          current_streak?: number | null
        }
        Update: {
          id?: string
          name?: string
          total_reviews?: number | null
          created_at?: string
          pin?: string
          last_review_at?: string | null
          current_streak?: number | null
        }
      }
    }
  }
}

============================================================

FILE: .\types\types.ts
SIZE: 5.35 KB
LAST MODIFIED: 02/16/2025 15:56:38

import type { Session } from '@supabase/supabase-js';

export interface PhraseWithRelations extends Phrase {
  categories: Category;
  subcategories?: Subcategory;
  phrase_tags: {
    tags: Tag;
  }[];
}

export interface SupabaseQueryResponse<T> {
  data: T[] | null;
  error: any;
  count?: number | null;
}

export interface Category {
  id: number;
  name: string;
}

export interface PhraseTagWithTag {
  tag_id: number;
  tags: {
    id: number;
    tag: string;
  };
}

export type SubcategoryName = {
  name: string;
}

export interface Subcategory {
  id: number;
  name: string;
  category_id: number;
}

export interface Tag {
  id: number;
  tag: string;
}

export interface PhraseTag {
  phrase_id: number;
  tag_id: number;
}

export interface PhraseBase {
  phrase: string;
  category_id: number;
  subcategory_id?: number | null;
  difficulty: number;  // Changed from string to number
  part_of_speech: string;
  hint?: string | null;
}

export interface Phrase extends Omit<PhraseBase, 'category_id' | 'subcategory_id'> {
  id: number;
  category: string;
  subcategory?: string;
  tags: string;
  difficulty: number;
}

export interface NewPhrase {
  phrase: string;
  category: string;
  subcategory?: string;
  difficulty: string;
  part_of_speech: string;
  hint?: string;
  tags?: string;
}

export interface Vote {
  id: string;
  reviewer_id: string;
  phrase_id: number;
  category: VoteCategory;
  vote: boolean;
  created_at: string;
}

export type VoteCategory = 'phrase' | 'category' | 'subcategory' | 'hint' | 'tags' | 'difficulty';

export interface Filters {
  searchTerm: string;
  category: string;
  difficulty: string;
  subcategory: string;
  part_of_speech: string;
}

export interface PaginationState {
  currentPage: number;
  rowsPerPage: number;
  totalPages: number;
}

export interface SortConfig {
  key: keyof Phrase | '';
  direction: 'asc' | 'desc';
}

export interface Stats {
  total: number;
  uniqueCategories: number;
  difficultyBreakdown: {
    easy: number;
    medium: number;
    hard: number;
  };
}

export interface Reviewer {
  id: string;
  name: string;
  pin: string;
  total_reviews: number;
  current_streak: number;
  last_review_at: string | null;
}

export interface BulkImportFormProps {
  onSuccess: (importedIds?: number[]) => void;
  onError: (errorMessage: string) => void;
  categories?: string[];
  difficulties?: string[];
  partsOfSpeech?: string[];
}

export interface ImportedPhrase extends NewPhrase {
  id: number;
}

export interface AddPhraseFormProps {
  onAddPhrase: (phrase: NewPhrase) => Promise<void>;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading: boolean;
}

export interface FilterControlsProps {
  filters: Filters;
  onChange: (name: string, value: string) => void;
  onReset: () => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  loading?: boolean;
}

export interface PhrasesTableProps {
  phrases: Phrase[];
  loading: boolean;
  pagination: PaginationState;
  sortConfig: SortConfig;
  onSort: (key: keyof Phrase) => void;
  onPageChange: (page: number) => void;
  onRowsPerPageChange: (rowsPerPage: number) => void;
  onEdit: (phrase: Phrase) => Promise<void>;
  onDelete: (id: number) => Promise<void>;
  onShowCardView: () => void;
  newIds?: number[];
}

export interface CardViewModalProps {
  isOpen: boolean;
  onClose: () => void;
  phrases: Phrase[];
  currentIndex: number;
  onNavigate: (index: number) => void;
  isEditing: boolean;
  editedPhrase: Phrase | null;
  onEdit: () => void;
  onSave: () => void;
  onCancel: () => void;
  onEditChange: (field: keyof Phrase, value: string) => void;
  categories: string[];
  difficulties: string[];
  partsOfSpeech: string[];
  reviewer?: Reviewer;
  onTagClick?: (tag: string) => void;
  loading?: boolean;
  error?: string | null;
}

export interface UsePhrasesReturn {
  phrases: Phrase[];
  loading: boolean;
  error: string | null;
  setError: (error: string | null) => void;
  pagination: PaginationState;
  sortConfig: SortConfig;
  filters: Filters;
  handleSort: (key: keyof Phrase) => void;
  handlePageChange: (page: number) => void;
  handleRowsPerPageChange: (rowsPerPage: number) => void;
  handleFilterChange: (name: string, value: string) => void;
  addPhrase: (phrase: NewPhrase) => Promise<void>;
  editPhrase: (phrase: Phrase) => Promise<void>;
  deletePhrase: (id: number) => Promise<void>;
  fetchPhrases: () => Promise<void>;
  resetFilters: () => void;
  sortByIdDesc: () => void;
}

export interface TagValidationResult {
  isValid: boolean;
  formattedTags: string;
  errors?: string[];
}

export interface UsePaginationProps {
  totalItems: number;
  itemsPerPage: number;
  currentPage: number;
}

export interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

export interface TagDisplayProps {
  tags: string;
  onClick?: (tag: string) => void;
}

export interface SelectProps {
  value: string;
  onChange: (value: string) => void;
  options: string[];
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  className?: string;
}

export interface StatsSectionProps {
  stats: Stats | null;
  loading: boolean;
}

============================================================

FILE: .\utils\bulkImport.ts
SIZE: 5.09 KB
LAST MODIFIED: 02/09/2025 15:41:57

import { supabase } from '@/lib/supabase';
import { validateBulkImport, sanitizePhrase } from './Validators';
import type { NewPhrase, Phrase } from '@/types/types';

interface BulkImportResult {
  success: boolean;
  message: string;
  newIds?: number[];
}

interface ImportedPhrase extends NewPhrase {
  id: number;
}

/**
 * Handles bulk import of phrases
 */
export const handleBulkImport = async (text: string): Promise<BulkImportResult> => {
  try {
    // Validate the input format
    const validation = validateBulkImport(text);
    if (!validation.isValid) {
      return {
        success: false,
        message: validation.errors.join('\n')
      };
    }

    // Parse and process the data
    const rows = text.trim().split('\n').map((row, index) => {
      const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = 
        row.split(',').map(field => field.trim());

      const newPhrase: NewPhrase = {
        phrase,
        category,
        difficulty,
        subcategory,
        tags,
        hint,
        part_of_speech
      };

      return sanitizePhrase(newPhrase) as NewPhrase;
    });

    // Insert the data
    const { data, error } = await supabase
      .from('phrases')
      .insert(rows)
      .select('id');

    if (error) {
      throw new Error(error.message);
    }

    const newIds = (data as ImportedPhrase[]).map(phrase => phrase.id);

    return {
      success: true,
      message: `Successfully imported ${rows.length} phrases.`,
      newIds
    };
  } catch (err) {
    console.error('Bulk import error:', err);
    return {
      success: false,
      message: err instanceof Error 
        ? err.message 
        : 'An error occurred during import'
    };
  }
};

/**
 * Validates a CSV file before import
 */
export const validateCSVFile = (file: File): Promise<{ isValid: boolean; message: string }> => {
  return new Promise((resolve, reject) => {
    // Check file type
    if (!file.name.endsWith('.csv')) {
      resolve({ 
        isValid: false, 
        message: 'File must be a CSV document' 
      });
      return;
    }

    // Check file size (e.g., 5MB limit)
    const maxSize = 5 * 1024 * 1024; // 5MB in bytes
    if (file.size > maxSize) {
      resolve({ 
        isValid: false, 
        message: 'File size must be less than 5MB' 
      });
      return;
    }

    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const validation = validateBulkImport(text);
        
        resolve({
          isValid: validation.isValid,
          message: validation.isValid 
            ? 'File is valid' 
            : validation.errors.join('\n')
        });
      } catch (err) {
        resolve({
          isValid: false,
          message: 'Error reading file content'
        });
      }
    };

    reader.onerror = () => {
      resolve({
        isValid: false,
        message: 'Error reading file'
      });
    };

    reader.readAsText(file);
  });
};

/**
 * Processes a CSV file and returns structured data
 */
export const processCSVFile = async (file: File): Promise<NewPhrase[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const phrases = text
          .trim()
          .split('\n')
          .map((row) => {
            const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = 
              row.split(',').map(field => field.trim());

            return sanitizePhrase({
              phrase,
              category,
              difficulty,
              subcategory,
              tags,
              hint,
              part_of_speech
            }) as NewPhrase;
          });

        resolve(phrases);
      } catch (err) {
        reject(new Error('Error processing CSV file'));
      }
    };

    reader.onerror = () => {
      reject(new Error('Error reading CSV file'));
    };

    reader.readAsText(file);
  });
};

/**
 * Downloads current phrases as CSV
 */
export const exportToCSV = async (): Promise<string> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*')
      .order('id');

    if (error) throw error;
    if (!data || data.length === 0) {
      throw new Error('No data to export');
    }

    // Create CSV header
    const headers = ['phrase', 'category', 'difficulty', 'subcategory', 'tags', 'hint', 'part_of_speech'];
    
    // Convert data to CSV rows
    const rows = data.map((phrase: Phrase) =>
      headers
        .map(header => phrase[header as keyof Phrase] || '')
        .map(field => `"${String(field).replace(/"/g, '""')}"`) // Escape quotes
        .join(',')
    );

    // Combine header and rows
    const csv = [headers.join(','), ...rows].join('\n');
    
    return csv;
  } catch (err) {
    console.error('Export error:', err);
    throw err;
  }
};

============================================================

FILE: .\utils\databaseMaintenance.ts
SIZE: 5.36 KB
LAST MODIFIED: 02/09/2025 15:42:12

import { supabase } from '@/lib/supabase';
import type { Phrase } from '@/types/types';

interface MaintenanceResult {
  success: boolean;
  message: string;
  details?: Record<string, any>;
}

interface PhraseTag {
  id: number;
  tags: string;
}

interface PhraseCategory {
  category: string;
}

/**
 * Updates existing tags format
 */
export const updateExistingTags = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('id, tags');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const updates = data.map((phrase: PhraseTag) => ({
      id: phrase.id,
      tags: phrase.tags
        .split(/[,\s]+/) // Split by comma or whitespace
        .map((tag: string) => tag.trim())
        .filter(Boolean)
        .join(',')
    }));

    const { error: updateError } = await supabase
      .from('phrases')
      .upsert(updates);

    if (updateError) throw updateError;

    return {
      success: true,
      message: `Successfully updated tags for ${updates.length} phrases.`,
      details: { updatedCount: updates.length }
    };
  } catch (err) {
    console.error('Error updating tags:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while updating tags'
    };
  }
};

/**
 * Cleans up unused categories
 */
export const cleanupCategories = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('category');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const categories = new Set(data.map((p: PhraseCategory) => p.category).filter(Boolean));
    const unusedCategories = Array.from(categories).filter(category => 
      !data.some((p: PhraseCategory) => p.category === category)
    );

    if (unusedCategories.length === 0) {
      return {
        success: true,
        message: 'No unused categories found.',
        details: { unusedCount: 0 }
      };
    }

    const { error: deleteError } = await supabase
      .from('phrases')
      .update({ category: 'Uncategorized' })
      .in('category', unusedCategories);

    if (deleteError) throw deleteError;

    return {
      success: true,
      message: `Cleaned up ${unusedCategories.length} unused categories.`,
      details: {
        unusedCount: unusedCategories.length,
        categories: unusedCategories
      }
    };
  } catch (err) {
    console.error('Error cleaning categories:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while cleaning categories'
    };
  }
};

/**
 * Validates all phrases in the database
 */
export const validateDatabase = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    const issues: Array<{ id: number; issues: string[] }> = [];

    data.forEach((phrase: Phrase) => {
      const phraseIssues: string[] = [];

      if (!phrase.phrase?.trim()) {
        phraseIssues.push('Missing phrase text');
      }
      if (!phrase.category?.trim()) {
        phraseIssues.push('Missing category');
      }
      if (!['Easy', 'Medium', 'Hard'].includes(phrase.difficulty)) {
        phraseIssues.push('Invalid difficulty level');
      }
      if (!phrase.tags?.trim()) {
        phraseIssues.push('Missing tags');
      }

      if (phraseIssues.length > 0) {
        issues.push({ id: phrase.id, issues: phraseIssues });
      }
    });

    return {
      success: true,
      message: `Validation complete. Found ${issues.length} phrases with issues.`,
      details: { issues }
    };
  } catch (err) {
    console.error('Error validating database:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while validating the database'
    };
  }
};

/**
 * Performs database backup
 */
export const backupDatabase = async (): Promise<MaintenanceResult> => {
  try {
    const { data, error } = await supabase
      .from('phrases')
      .select('*');

    if (error) throw error;
    if (!data) throw new Error('No data returned');

    // Convert to CSV
    const headers = Object.keys(data[0]);
    const csv = [
      headers.join(','),
      ...data.map((row: Record<string, any>) =>
        headers
          .map(header => {
            const cell = row[header]?.toString() ?? '';
            return `"${cell.replace(/"/g, '""')}"`;
          })
          .join(',')
      )
    ].join('\n');

    // Create backup timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `phrases-backup-${timestamp}.csv`;

    return {
      success: true,
      message: 'Backup created successfully.',
      details: {
        filename,
        content: csv,
        timestamp,
        recordCount: data.length
      }
    };
  } catch (err) {
    console.error('Error creating backup:', err);
    return {
      success: false,
      message: err instanceof Error ? err.message : 'An error occurred while creating backup'
    };
  }
};

============================================================

FILE: .\utils\formatters.ts
SIZE: 4.56 KB
LAST MODIFIED: 02/09/2025 10:16:11

/**
 * Formats a number with commas for thousands
 */
export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('en-US').format(num);
};

/**
 * Formats a number as a percentage
 */
export const formatPercent = (num: number, decimals: number = 0): string => {
  return `${num.toFixed(decimals)}%`;
};

/**
 * Formats a date in a localized format
 */
export const formatDate = (date: Date | string | null): string => {
  if (!date) return 'Never';
  
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

/**
 * Formats a date relative to now (e.g., "2 days ago")
 */
export const formatRelativeDate = (date: Date | string | null): string => {
  if (!date) return 'Never';

  const now = new Date();
  const then = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - then.getTime()) / 1000);
  
  if (diffInSeconds < 60) {
    return 'just now';
  }
  
  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes} minute${diffInMinutes === 1 ? '' : 's'} ago`;
  }
  
  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours} hour${diffInHours === 1 ? '' : 's'} ago`;
  }
  
  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 30) {
    return `${diffInDays} day${diffInDays === 1 ? '' : 's'} ago`;
  }
  
  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) {
    return `${diffInMonths} month${diffInMonths === 1 ? '' : 's'} ago`;
  }
  
  const diffInYears = Math.floor(diffInMonths / 12);
  return `${diffInYears} year${diffInYears === 1 ? '' : 's'} ago`;
};

/**
 * Formats difficulty level with color class
 */
export const formatDifficulty = (difficulty: string): { text: string; colorClass: string } => {
  const normalized = difficulty.toLowerCase();
  switch (normalized) {
    case 'easy':
      return { text: 'Easy', colorClass: 'text-green-400' };
    case 'medium':
      return { text: 'Medium', colorClass: 'text-yellow-400' };
    case 'hard':
      return { text: 'Hard', colorClass: 'text-red-400' };
    default:
      return { text: difficulty, colorClass: 'text-gray-400' };
  }
};

/**
 * Formats tags as an array with optional truncation
 */
export const formatTags = (tags: string, maxTags?: number): string[] => {
  const tagArray = tags.split(',').map(tag => tag.trim()).filter(Boolean);
  if (maxTags && tagArray.length > maxTags) {
    return [...tagArray.slice(0, maxTags), `+${tagArray.length - maxTags} more`];
  }
  return tagArray;
};

/**
 * Formats file size in bytes to human readable format
 */
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
};

/**
 * Formats a string to title case
 */
export const formatTitleCase = (str: string): string => {
  return str
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

/**
 * Formats text with ellipsis if it exceeds max length
 */
export const formatTruncate = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength)}...`;
};

/**
 * Formats category for display
 */
export const formatCategory = (category: string): { text: string; icon: string } => {
  const normalized = category.toLowerCase();
  switch (normalized) {
    case 'movies':
      return { text: 'Movies', icon: 'ðŸŽ¬' };
    case 'tv':
      return { text: 'TV Shows', icon: 'ðŸ“º' };
    case 'books':
      return { text: 'Books', icon: 'ðŸ“š' };
    case 'music':
      return { text: 'Music', icon: 'ðŸŽµ' };
    case 'games':
      return { text: 'Games', icon: 'ðŸŽ®' };
    default:
      return { text: formatTitleCase(category), icon: 'ðŸ“' };
  }
};

/**
 * Formats CSV data into a downloadable string
 */
export const formatCSV = (data: Record<string, any>[]): string => {
  if (data.length === 0) return '';

  const headers = Object.keys(data[0]);
  const rows = data.map(row => 
    headers
      .map(header => {
        const cell = row[header]?.toString() ?? '';
        return `"${cell.replace(/"/g, '""')}"`;
      })
      .join(',')
  );

  return [headers.join(','), ...rows].join('\n');
};

============================================================

FILE: .\utils\phraseUtils.ts
SIZE: 6.53 KB
LAST MODIFIED: 02/09/2025 10:18:26

import type { Phrase, NewPhrase, TagValidationResult } from '@/types/types';

/**
 * Validates and formats tags
 */
export const validateTags = (tags: string): TagValidationResult => {
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  const errors: string[] = [];
  
  if (tagArray.length === 0) {
    errors.push('At least one tag is required');
  }
  
  if (tagArray.some(tag => tag.length < 2)) {
    errors.push('Tags must be at least 2 characters long');
  }
  
  if (tagArray.some(tag => !/^[a-zA-Z0-9\s]+$/.test(tag))) {
    errors.push('Tags can only contain letters, numbers, and spaces');
  }

  const formattedTags = tagArray.join(',');

  return {
    isValid: errors.length === 0,
    formattedTags,
    errors
  };
};

/**
 * Formats and sanitizes a phrase object
 */
export const sanitizePhrase = (phrase: Partial<Phrase | NewPhrase>): Partial<Phrase | NewPhrase> => {
  return {
    ...phrase,
    phrase: phrase.phrase?.trim(),
    category: phrase.category?.trim(),
    difficulty: phrase.difficulty?.trim(),
    subcategory: phrase.subcategory?.trim(),
    tags: phrase.tags?.split(',').map(t => t.trim()).filter(Boolean).join(','),
    hint: phrase.hint?.trim(),
    part_of_speech: phrase.part_of_speech?.trim()
  };
};

/**
 * Groups phrases by category
 */
export const groupPhrasesByCategory = (phrases: Phrase[]): Record<string, Phrase[]> => {
  return phrases.reduce((acc, phrase) => {
    const category = phrase.category || 'Uncategorized';
    acc[category] = acc[category] || [];
    acc[category].push(phrase);
    return acc;
  }, {} as Record<string, Phrase[]>);
};

/**
 * Filters phrases based on search criteria
 */
export const filterPhrases = (
  phrases: Phrase[],
  filters: {
    searchTerm?: string;
    category?: string;
    difficulty?: string;
    subcategory?: string;
    part_of_speech?: string;
  }
): Phrase[] => {
  return phrases.filter(phrase => {
    const searchTermMatch = !filters.searchTerm || 
      phrase.phrase.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
      phrase.tags.toLowerCase().includes(filters.searchTerm.toLowerCase());

    const categoryMatch = !filters.category || 
      phrase.category.toLowerCase() === filters.category.toLowerCase();

    const difficultyMatch = !filters.difficulty || 
      phrase.difficulty.toLowerCase() === filters.difficulty.toLowerCase();

    const subcategoryMatch = !filters.subcategory || 
      phrase.subcategory.toLowerCase() === filters.subcategory.toLowerCase();

    const partOfSpeechMatch = !filters.part_of_speech || 
      phrase.part_of_speech.toLowerCase() === filters.part_of_speech.toLowerCase();

    return searchTermMatch && categoryMatch && difficultyMatch && 
           subcategoryMatch && partOfSpeechMatch;
  });
};

/**
 * Sorts phrases by specified criteria
 */
export const sortPhrases = (
  phrases: Phrase[],
  sortKey: keyof Phrase,
  sortDirection: 'asc' | 'desc'
): Phrase[] => {
  return [...phrases].sort((a, b) => {
    const aVal = a[sortKey];
    const bVal = b[sortKey];

    if (aVal === bVal) return 0;
    
    if (aVal === null || aVal === undefined) return 1;
    if (bVal === null || bVal === undefined) return -1;

    const comparison = aVal < bVal ? -1 : 1;
    return sortDirection === 'asc' ? comparison : -comparison;
  });
};

/**
 * Checks if a phrase needs review (hasn't been used in a while)
 */
export const needsReview = (phrase: Phrase, daysThreshold: number = 30): boolean => {
  if (!phrase.last_used) return true;
  
  const lastUsed = new Date(phrase.last_used);
  const now = new Date();
  const diffTime = Math.abs(now.getTime() - lastUsed.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  return diffDays > daysThreshold;
};

/**
 * Gets phrases that haven't been used in a while
 */
export const getPhrasesNeedingReview = (
  phrases: Phrase[],
  daysThreshold: number = 30
): Phrase[] => {
  return phrases.filter(phrase => needsReview(phrase, daysThreshold));
};

/**
 * Gets phrases by difficulty level
 */
export const getPhrasesByDifficulty = (
  phrases: Phrase[],
  difficulty: string
): Phrase[] => {
  return phrases.filter(
    phrase => phrase.difficulty.toLowerCase() === difficulty.toLowerCase()
  );
};

/**
 * Gets related phrases based on tags
 */
export const getRelatedPhrases = (
  phrases: Phrase[],
  currentPhrase: Phrase,
  maxResults: number = 5
): Phrase[] => {
  const currentTags = new Set(currentPhrase.tags.split(',').map(t => t.trim()));
  
  return phrases
    .filter(phrase => phrase.id !== currentPhrase.id)
    .map(phrase => {
      const phraseTags = new Set(phrase.tags.split(',').map(t => t.trim()));
      const commonTags = new Set(
        [...currentTags].filter(tag => phraseTags.has(tag))
      );
      return {
        phrase,
        commonTagCount: commonTags.size
      };
    })
    .filter(({ commonTagCount }) => commonTagCount > 0)
    .sort((a, b) => b.commonTagCount - a.commonTagCount)
    .slice(0, maxResults)
    .map(({ phrase }) => phrase);
};

/**
 * Gets phrase usage statistics
 */
export const getPhraseUsageStats = (phrases: Phrase[]) => {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.setDate(now.getDate() - 30));
  
  return phrases.reduce((stats, phrase) => {
    if (!phrase.last_used) {
      stats.neverUsed++;
    } else {
      const lastUsed = new Date(phrase.last_used);
      if (lastUsed < thirtyDaysAgo) {
        stats.notRecentlyUsed++;
      } else {
        stats.recentlyUsed++;
      }
    }
    return stats;
  }, {
    neverUsed: 0,
    notRecentlyUsed: 0,
    recentlyUsed: 0
  });
};

/**
 * Gets the most used tags across all phrases
 */
export const getMostUsedTags = (
  phrases: Phrase[],
  limit: number = 10
): Array<{ tag: string; count: number }> => {
  const tagCounts = phrases.reduce((acc, phrase) => {
    phrase.tags.split(',').forEach(tag => {
      const trimmedTag = tag.trim();
      acc[trimmedTag] = (acc[trimmedTag] || 0) + 1;
    });
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(tagCounts)
    .map(([tag, count]) => ({ tag, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, limit);
};

export default {
  validateTags,
  sanitizePhrase,
  groupPhrasesByCategory,
  filterPhrases,
  sortPhrases,
  needsReview,
  getPhrasesNeedingReview,
  getPhrasesByDifficulty,
  getRelatedPhrases,
  getPhraseUsageStats,
  getMostUsedTags
};

============================================================

FILE: .\utils\reviewerUtils.ts
SIZE: 0 KB
LAST MODIFIED: 02/11/2025 23:45:40


============================================================

FILE: .\utils\statsUtils.ts
SIZE: 4.29 KB
LAST MODIFIED: 02/09/2025 10:15:14

import { SupabaseClient } from '@supabase/supabase-js';
import type { Stats, Phrase } from '@/types/types';

interface StatsResult {
  data: Stats | null;
  error: string | null;
}

/**
 * Calculates statistics from phrase data
 */
export const calculateStats = async (supabase: SupabaseClient): Promise<StatsResult> => {
  try {
    const { data: phrases, error, count } = await supabase
      .from('phrases')
      .select('*', { count: 'exact' });

    if (error) throw error;
    if (!phrases || phrases.length === 0) {
      return {
        data: {
          total: 0,
          uniqueCategories: 0,
          difficultyBreakdown: { easy: 0, medium: 0, hard: 0 }
        },
        error: null
      };
    }

    // Calculate unique categories
    const uniqueCategories = new Set(phrases.map(p => p.category)).size;

    // Calculate difficulty breakdown
    const difficultyCount = phrases.reduce((acc, phrase) => {
      const difficulty = phrase.difficulty.toLowerCase();
      acc[difficulty] = (acc[difficulty] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const total = count || phrases.length;

    // Calculate percentages with rounding adjustments
    let easy = Math.round((difficultyCount['easy'] || 0) / total * 100);
    let medium = Math.round((difficultyCount['medium'] || 0) / total * 100);
    let hard = Math.round((difficultyCount['hard'] || 0) / total * 100);

    // Adjust for rounding errors to ensure sum is 100
    const sum = easy + medium + hard;
    if (sum !== 100) {
      const diff = 100 - sum;
      if (easy >= medium && easy >= hard) {
        easy += diff;
      } else if (medium >= easy && medium >= hard) {
        medium += diff;
      } else {
        hard += diff;
      }
    }

    return {
      data: {
        total,
        uniqueCategories,
        difficultyBreakdown: {
          easy,
          medium,
          hard
        }
      },
      error: null
    };
  } catch (err) {
    console.error('Error calculating stats:', err);
    return {
      data: null,
      error: err instanceof Error ? err.message : 'An unknown error occurred'
    };
  }
};

/**
 * Calculates usage statistics for phrases
 */
export const calculateUsageStats = (phrases: Phrase[]) => {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.setDate(now.getDate() - 30));

  return phrases.reduce((stats, phrase) => {
    if (!phrase.last_used) {
      stats.neverUsed++;
    } else {
      const lastUsed = new Date(phrase.last_used);
      if (lastUsed < thirtyDaysAgo) {
        stats.notRecentlyUsed++;
      } else {
        stats.recentlyUsed++;
      }
    }
    return stats;
  }, {
    neverUsed: 0,
    notRecentlyUsed: 0,
    recentlyUsed: 0
  });
};

/**
 * Calculates category distribution
 */
export const calculateCategoryStats = (phrases: Phrase[]) => {
  const categoryCount = phrases.reduce((acc, phrase) => {
    acc[phrase.category] = (acc[phrase.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Convert to percentages
  const total = phrases.length;
  const categoryPercentages = Object.entries(categoryCount).map(([category, count]) => ({
    category,
    percentage: Math.round((count / total) * 100)
  }));

  // Sort by percentage descending
  return categoryPercentages.sort((a, b) => b.percentage - a.percentage);
};

/**
 * Calculates difficulty distribution over time
 */
export const calculateDifficultyTrends = (phrases: Phrase[]) => {
  // Group by month
  const monthlyStats = phrases.reduce((acc, phrase) => {
    const date = phrase.last_used 
      ? new Date(phrase.last_used)
      : new Date();
    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    
    if (!acc[monthKey]) {
      acc[monthKey] = { easy: 0, medium: 0, hard: 0 };
    }
    
    const difficulty = phrase.difficulty.toLowerCase();
    acc[monthKey][difficulty as 'easy' | 'medium' | 'hard']++;
    
    return acc;
  }, {} as Record<string, Record<'easy' | 'medium' | 'hard', number>>);

  // Convert to array and sort by date
  return Object.entries(monthlyStats)
    .map(([month, stats]) => ({
      month,
      ...stats
    }))
    .sort((a, b) => a.month.localeCompare(b.month));
};

============================================================

FILE: .\utils\useCountUp.ts
SIZE: 0.8 KB
LAST MODIFIED: 02/08/2025 22:09:49

import { useState, useEffect } from 'react';

const useCountUp = (endValue: number, duration: number = 1000) => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    let startTime: number;
    let animationFrame: number;
    
    const animate = (currentTime: number) => {
      if (!startTime) startTime = currentTime;
      
      const progress = (currentTime - startTime) / duration;
      
      if (progress < 1) {
        setCount(Math.floor(endValue * progress));
        animationFrame = requestAnimationFrame(animate);
      } else {
        setCount(endValue);
      }
    };
    
    animationFrame = requestAnimationFrame(animate);
    
    return () => cancelAnimationFrame(animationFrame);
  }, [endValue, duration]);

  return count;
};

export default useCountUp;

============================================================

FILE: .\utils\useDebounce.ts
SIZE: 4.11 KB
LAST MODIFIED: 02/09/2025 15:42:39

import { useState, useEffect, useRef } from 'react';

interface DebouncedState<T> {
  debouncedValue: T;
  isDebouncing: boolean;
  flush: () => void;
  cancel: () => void;
}

/**
 * Custom hook for debouncing values
 */
export function useDebounce<T>(
  value: T,
  delay: number = 500,
  options: {
    leading?: boolean;
    maxWait?: number;
  } = {}
): DebouncedState<T> {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  const [isDebouncing, setIsDebouncing] = useState<boolean>(false);
  
  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const maxWaitTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const valueRef = useRef<T>(value);
  const maxWaitStartTimeRef = useRef<number | undefined>(undefined);

  // Update the latest value
  useEffect(() => {
    valueRef.current = value;
  }, [value]);

  // Cleanup function
  const cleanup = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    if (maxWaitTimeoutRef.current) {
      clearTimeout(maxWaitTimeoutRef.current);
    }
  };

  // Handle the debounced update
  const update = () => {
    setDebouncedValue(valueRef.current);
    setIsDebouncing(false);
    maxWaitStartTimeRef.current = undefined;
    cleanup();
  };

  // Reset effects on delay change
  useEffect(() => {
    cleanup();
    setIsDebouncing(false);
  }, [delay]);

  // Main debounce effect
  useEffect(() => {
    if (delay <= 0) {
      setDebouncedValue(value);
      return;
    }

    setIsDebouncing(true);

    // Handle leading edge
    if (options.leading && !timeoutRef.current) {
      setDebouncedValue(value);
      setIsDebouncing(false);
      return;
    }

    // Set up max wait timeout if specified
    if (options.maxWait && !maxWaitStartTimeRef.current) {
      maxWaitStartTimeRef.current = Date.now();
      maxWaitTimeoutRef.current = setTimeout(() => {
        if (maxWaitStartTimeRef.current) {
          update();
        }
      }, options.maxWait);
    }

    // Set up main timeout
    timeoutRef.current = setTimeout(update, delay);

    return cleanup;
  }, [value, delay, options.leading, options.maxWait]);

  // Flush function to immediately update value
  const flush = () => {
    if (timeoutRef.current) {
      update();
    }
  };

  // Cancel function to stop debouncing
  const cancel = () => {
    if (timeoutRef.current) {
      cleanup();
      setIsDebouncing(false);
    }
  };

  // Cleanup on unmount
  useEffect(() => cleanup, []);

  return {
    debouncedValue,
    isDebouncing,
    flush,
    cancel
  };
}

/**
 * Simplified version that only returns the debounced value
 */
export function useSimpleDebounce<T>(value: T, delay: number = 500): T {
  const { debouncedValue } = useDebounce(value, delay);
  return debouncedValue;
}

/**
 * Version specifically for debouncing callbacks
 */
export function useDebouncedCallback<T extends (...args: any[]) => any>(
  callback: T,
  delay: number = 500,
  deps: any[] = []
): [(...args: Parameters<T>) => void, boolean, () => void] {
  const [isDebouncing, setIsDebouncing] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const callbackRef = useRef(callback);

  // Update callback ref when it changes
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Cleanup on unmount or deps change
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, deps);

  const debouncedCallback = (...args: Parameters<T>) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    setIsDebouncing(true);

    timeoutRef.current = setTimeout(() => {
      callbackRef.current(...args);
      setIsDebouncing(false);
    }, delay);
  };

  const cancel = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      setIsDebouncing(false);
    }
  };

  return [debouncedCallback, isDebouncing, cancel];
}

export default useDebounce;

============================================================

FILE: .\utils\usePagination.ts
SIZE: 2.35 KB
LAST MODIFIED: 02/09/2025 10:17:17

import { UsePaginationProps } from '@/types/types';

interface PaginationResult {
  totalPages: number;
  startIndex: number;
  endIndex: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  pageRange: number[];
  currentPageItems: number;
}

/**
 * Custom hook for handling pagination logic
 */
export const usePagination = ({
  totalItems,
  itemsPerPage,
  currentPage,
  siblingCount = 1,
  boundaryCount = 1
}: UsePaginationProps & {
  siblingCount?: number;
  boundaryCount?: number;
}): PaginationResult => {
  const totalPages = Math.max(1, Math.ceil(totalItems / itemsPerPage));
  const currentPageSafe = Math.min(Math.max(1, currentPage), totalPages);
  
  const startIndex = (currentPageSafe - 1) * itemsPerPage;
  const endIndex = Math.min(startIndex + itemsPerPage - 1, totalItems - 1);
  
  // Calculate the range of page numbers to show
  const range = (start: number, end: number): number[] => {
    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  };

  const startPages = range(1, Math.min(boundaryCount, totalPages));
  const endPages = range(
    Math.max(totalPages - boundaryCount + 1, boundaryCount + 1),
    totalPages
  );

  const siblingsStart = Math.max(
    Math.min(
      currentPageSafe - siblingCount,
      totalPages - boundaryCount - siblingCount * 2 - 1
    ),
    boundaryCount + 2
  );

  const siblingsEnd = Math.min(
    Math.max(currentPageSafe + siblingCount, boundaryCount + siblingCount * 2 + 2),
    endPages.length > 0 ? endPages[0] - 2 : totalPages - 1
  );

  // Combine the ranges with ellipses
  const pageRange = [
    ...startPages,
    ...(siblingsStart > boundaryCount + 2
      ? ['ellipsis']
      : boundaryCount + 1 < totalPages - boundaryCount
      ? [boundaryCount + 1]
      : []),
    ...range(siblingsStart, siblingsEnd),
    ...(siblingsEnd < totalPages - boundaryCount - 1
      ? ['ellipsis']
      : totalPages - boundaryCount > boundaryCount
      ? [totalPages - boundaryCount]
      : []),
    ...endPages
  ].filter((page): page is number => typeof page === 'number');

  return {
    totalPages,
    startIndex,
    endIndex,
    hasNextPage: currentPageSafe < totalPages,
    hasPreviousPage: currentPageSafe > 1,
    pageRange,
    currentPageItems: endIndex - startIndex + 1
  };
};

export default usePagination;

============================================================

FILE: .\utils\Validators.ts
SIZE: 3.81 KB
LAST MODIFIED: 02/09/2025 10:13:27

import type { TagValidationResult, Phrase, NewPhrase } from '@/types/types';

/**
 * Validates tags input
 */
export const validateTags = (tags: string): TagValidationResult => {
  const tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
  
  const errors: string[] = [];
  
  if (tagArray.length === 0) {
    errors.push('At least one tag is required');
  }
  
  if (tagArray.some(tag => tag.length < 2)) {
    errors.push('Tags must be at least 2 characters long');
  }
  
  if (tagArray.some(tag => !/^[a-zA-Z0-9\s]+$/.test(tag))) {
    errors.push('Tags can only contain letters, numbers, and spaces');
  }

  return {
    isValid: errors.length === 0,
    formattedTags: tagArray.join(','),
    errors
  };
};

/**
 * Validates a complete phrase object
 */
export const validatePhrase = (phrase: Partial<Phrase | NewPhrase>): {
  isValid: boolean;
  errors: Record<string, string>;
} => {
  const errors: Record<string, string> = {};

  // Required fields
  if (!phrase.phrase?.trim()) {
    errors.phrase = 'Phrase is required';
  }

  if (!phrase.category?.trim()) {
    errors.category = 'Category is required';
  }

  if (!phrase.difficulty?.trim()) {
    errors.difficulty = 'Difficulty is required';
  }

  if (!phrase.part_of_speech?.trim()) {
    errors.part_of_speech = 'Part of speech is required';
  }

  // Length validations
  if (phrase.phrase && phrase.phrase.length < 2) {
    errors.phrase = 'Phrase must be at least 2 characters long';
  }

  if (phrase.subcategory && phrase.subcategory.length < 2) {
    errors.subcategory = 'Subcategory must be at least 2 characters long';
  }

  // Validate difficulty values
  if (
    phrase.difficulty &&
    !['Easy', 'Medium', 'Hard'].includes(phrase.difficulty)
  ) {
    errors.difficulty = 'Invalid difficulty value';
  }

  // Validate tags
  if (phrase.tags) {
    const tagValidation = validateTags(phrase.tags);
    if (!tagValidation.isValid) {
      errors.tags = tagValidation.errors?.[0] || 'Invalid tags';
    }
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

/**
 * Validates bulk import data format
 */
export const validateBulkImport = (
  data: string
): { isValid: boolean; errors: string[] } => {
  const errors: string[] = [];
  const lines = data.trim().split('\n');

  if (lines.length === 0) {
    errors.push('No data provided');
    return { isValid: false, errors };
  }

  lines.forEach((line, index) => {
    const fields = line.split(',').map(field => field.trim());

    if (fields.length !== 7) {
      errors.push(
        `Line ${index + 1}: Expected 7 fields but got ${fields.length}`
      );
      return;
    }

    const [phrase, category, difficulty, subcategory, tags, hint, part_of_speech] = fields;

    if (!phrase) {
      errors.push(`Line ${index + 1}: Phrase is required`);
    }

    if (!category) {
      errors.push(`Line ${index + 1}: Category is required`);
    }

    if (!['Easy', 'Medium', 'Hard'].includes(difficulty)) {
      errors.push(`Line ${index + 1}: Invalid difficulty value`);
    }

    const tagValidation = validateTags(tags);
    if (!tagValidation.isValid) {
      errors.push(`Line ${index + 1}: ${tagValidation.errors?.[0]}`);
    }
  });

  return {
    isValid: errors.length === 0,
    errors
  };
};

/**
 * Formats and sanitizes phrase data
 */
export const sanitizePhrase = (phrase: Partial<Phrase | NewPhrase>): Partial<Phrase | NewPhrase> => {
  return {
    ...phrase,
    phrase: phrase.phrase?.trim(),
    category: phrase.category?.trim(),
    subcategory: phrase.subcategory?.trim(),
    tags: phrase.tags?.split(',').map(t => t.trim()).filter(Boolean).join(','),
    hint: phrase.hint?.trim(),
    part_of_speech: phrase.part_of_speech?.trim()
  };
};
